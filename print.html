<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A guide to Telegram.Bot library</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
                <!-- Google tag (gtag.js) -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-B8JVQVCBTX"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());
        
                  gtag('config', 'G-B8JVQVCBTX');
                </script>
                <!--  -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="1/example-bot.html"><strong aria-hidden="true">1.2.</strong> Full Example</a></li></ol></li><li class="chapter-item expanded "><a href="2/index.html"><strong aria-hidden="true">2.</strong> Beginner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2/send-msg/index.html"><strong aria-hidden="true">2.1.</strong> Sending Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2/send-msg/text-msg.html"><strong aria-hidden="true">2.1.1.</strong> Text</a></li><li class="chapter-item expanded "><a href="2/send-msg/photo-sticker-msg.html"><strong aria-hidden="true">2.1.2.</strong> Photo & Sticker</a></li><li class="chapter-item expanded "><a href="2/send-msg/audio-voice-msg.html"><strong aria-hidden="true">2.1.3.</strong> Audio & Voice</a></li><li class="chapter-item expanded "><a href="2/send-msg/video-video_note-msg.html"><strong aria-hidden="true">2.1.4.</strong> Video & Video Note</a></li><li class="chapter-item expanded "><a href="2/send-msg/album-msg.html"><strong aria-hidden="true">2.1.5.</strong> Album (Media Group)</a></li><li class="chapter-item expanded "><a href="2/send-msg/document-animation-msg.html"><strong aria-hidden="true">2.1.6.</strong> Document & Animation</a></li><li class="chapter-item expanded "><a href="2/send-msg/native-polls-msg.html"><strong aria-hidden="true">2.1.7.</strong> Native Polls</a></li><li class="chapter-item expanded "><a href="2/send-msg/other-msg.html"><strong aria-hidden="true">2.1.8.</strong> Other Messages</a></li></ol></li><li class="chapter-item expanded "><a href="2/reply-markup.html"><strong aria-hidden="true">2.2.</strong> Reply Markup</a></li><li class="chapter-item expanded "><a href="2/forward-copy-delete.html"><strong aria-hidden="true">2.3.</strong> Forward, Copy or Delete</a></li></ol></li><li class="chapter-item expanded "><a href="3/index.html"><strong aria-hidden="true">3.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/updates/index.html"><strong aria-hidden="true">3.1.</strong> Getting Updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/updates/polling.html"><strong aria-hidden="true">3.1.1.</strong> Long Polling</a></li><li class="chapter-item expanded "><a href="3/updates/webhook.html"><strong aria-hidden="true">3.1.2.</strong> Webhooks</a></li></ol></li><li class="chapter-item expanded "><a href="3/inline.html"><strong aria-hidden="true">3.2.</strong> Inline Mode</a></li><li class="chapter-item expanded "><a href="3/files/index.html"><strong aria-hidden="true">3.3.</strong> Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/files/download.html"><strong aria-hidden="true">3.3.1.</strong> Download</a></li><li class="chapter-item expanded "><a href="3/files/upload.html"><strong aria-hidden="true">3.3.2.</strong> Upload</a></li></ol></li><li class="chapter-item expanded "><a href="3/sticker.html"><strong aria-hidden="true">3.4.</strong> Stickers</a></li></ol></li><li class="chapter-item expanded "><a href="4/index.html"><strong aria-hidden="true">4.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4/proxy.html"><strong aria-hidden="true">4.1.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="4/passport/index.html"><strong aria-hidden="true">4.2.</strong> Passport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4/passport/quickstart.html"><strong aria-hidden="true">4.2.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="4/passport/files-docs.html"><strong aria-hidden="true">4.2.2.</strong> Files & Documents</a></li><li class="chapter-item expanded "><a href="4/passport/errors.html"><strong aria-hidden="true">4.2.3.</strong> Data Errors</a></li><li class="chapter-item expanded "><a href="4/passport/key.html"><strong aria-hidden="true">4.2.4.</strong> RSA Key</a></li><li class="chapter-item expanded "><a href="4/passport/faq.html"><strong aria-hidden="true">4.2.5.</strong> Decryption FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="4/login-widget.html"><strong aria-hidden="true">4.3.</strong> Login Widget</a></li><li class="chapter-item expanded "><a href="4/tests.html"><strong aria-hidden="true">4.4.</strong> Systems Integration Tests</a></li><li class="chapter-item expanded "><a href="4/logging.html"><strong aria-hidden="true">4.5.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-14.x.html"><strong aria-hidden="true">5.</strong> Migration guide =&gt; v14</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-17.x.html"><strong aria-hidden="true">6.</strong> Migration guide =&gt; v17</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-18.x.html"><strong aria-hidden="true">7.</strong> Migration guide =&gt; v18</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-19.x.html"><strong aria-hidden="true">8.</strong> Migration guide =&gt; v19</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-21.x.html"><strong aria-hidden="true">9.</strong> Migration guide =&gt; v21</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">10.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A guide to Telegram.Bot library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TelegramBots/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="telegram-bots-book"><a class="header" href="#telegram-bots-book">Telegram Bots Book</a></h1>
<p><a href="https://nuget.voids.site/packages/Telegram.Bot"><img src="https://img.shields.io/nuget/dt/Telegram.Bot.svg?style=flat-square" alt="NuGet" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot"><img src="https://img.shields.io/github/stars/TelegramBots/Telegram.Bot.svg?style=social&amp;label=Stars" alt="Repository" /></a></p>
<p><strong><a href="https://github.com/TelegramBots/Telegram.Bot">Telegram.Bot</a></strong> is the most popular .NET client for <a href="https://core.telegram.org/bots/api">Telegram Bot API</a>, allowing <a href="https://core.telegram.org/bots">developers to build bots</a> for <a href="https://www.telegram.org">Telegram</a> messaging app.</p>
<p>Telegram Bot API is <a href="https://core.telegram.org/bots/api">officially documented</a> but this book covers all you need to know to create a
chatbot in .NET. There are also many concrete examples written in C#.
The guides here can even be useful to bot developers using other languages/platforms as it shows best practices
in developing Telegram chatbots with examples.</p>
<p>‚û°Ô∏è Access the book pages via the Table Of Content (top/left), or start your journey with our <a href="1/quickstart.html"><em>Quickstart</em></a> guide.</p>
<h2 id="-installation"><a class="header" href="#-installation">üß© Installation</a></h2>
<p>‚ö†Ô∏è <em>Latest versions of the library are not available on Nuget‚Ä§org due to false-positive malware detection. We are working with Nuget/ESET teams to resolve this issue.</em></p>
<p>In the mean time, latest versions are available on our <a href="https://nuget.voids.site/packages/Telegram.Bot">special nuget feed</a>: <code>https://nuget.voids.site/v3/index.json</code></p>
<p>Follow the pictures below to configure the Package source in Visual Studio:
<img src="1/docs/NugetPackageManager.jpg" alt="In Visual Studio" /></p>
<p>Alternatively you can set up a <code>nuget.config</code> file at the root of your project/solution:</p>
<pre><code class="language-xml">&lt;configuration&gt;
  &lt;packageSources&gt;
    &lt;add key=&quot;nuget.org&quot; value=&quot;https://api.nuget.org/v3/index.json&quot; protocolVersion=&quot;3&quot; /&gt;
    &lt;add key=&quot;nuget voids.site&quot; value=&quot;https://nuget.voids.site/v3/index.json&quot; /&gt;
  &lt;/packageSources&gt;
&lt;/configuration&gt;
</code></pre>
<h2 id="-more-examples"><a class="header" href="#-more-examples">ü™Ñ More examples</a></h2>
<p>This book is filled with ready-to-use snippets of code, but you can also find full project examples at our <a href="https://github.com/TelegramBots/Telegram.Bot.Examples">Telegram.Bot.Examples</a> Github repository, featuring:</p>
<ul>
<li>Simple Console apps (long polling)</li>
<li>Webhook ASP.NET example (with Controllers or Minimal APIs)</li>
<li>Full-featured advanced solution</li>
<li>Serverless Functions implementations</li>
</ul>
<h2 id="-more-useful-links"><a class="header" href="#-more-useful-links">üîó More useful links</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Visit our</th><th>URL</th></tr></thead><tbody>
<tr><td>Nuget feed</td><td>https://nuget.voids.site/packages/Telegram.Bot</td></tr>
<tr><td>Github repo</td><td>https://github.com/TelegramBots/Telegram.Bot</td></tr>
<tr><td>Examples repo</td><td>https://github.com/TelegramBots/Telegram.Bot.Examples</td></tr>
<tr><td>Telegram news channel</td><td>https://t.me/tgbots_dotnet</td></tr>
<tr><td>Telegram support group</td><td>https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA</td></tr>
<tr><td>Team page</td><td>https://github.com/orgs/TelegramBots/people</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="bot-father"><a class="header" href="#bot-father">Bot Father</a></h2>
<p>Before you start, you need to talk to <a href="https://t.me/botfather"><code>@BotFather</code></a> on Telegram.
<a href="https://core.telegram.org/bots/tutorial#obtain-your-bot-token">Create a new bot</a>, acquire the bot token and get back here.</p>
<p><a href="https://t.me/botfather"><img src="1/docs/logo-bot-father.jpg" alt="Bot Father" /></a></p>
<p>Bot token is a key that required to authorize the bot and send requests to the Bot API. Keep your token secure and store it safely, it can be used to control your bot. It should look like this:</p>
<pre><code class="language-text">1234567:4TT8bAc8GHUspu3ERYn-KGcvsvGB9u_n4ddy
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Now that you have a bot, it's time to bring it to life!</p>
<blockquote>
<p>We recommend a recent .NET version like .NET 8, but we also support older .NET Framework (4.6.1+), .NET Core (2.0+) or .NET (5.0+)
ne</p>
</blockquote>
<p>Create a new console project for your bot and add a reference to <code>Telegram.Bot</code> package:</p>
<pre><code class="language-bash">dotnet new console
dotnet add package Telegram.Bot --source https://nuget.voids.site/v3/index.json
</code></pre>
<p>The code below fetches Bot information based on its access token by calling the Bot API <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method. Open <code>Program.cs</code> and use the following content:</p>
<blockquote>
<p>‚ö†Ô∏è Replace <code>{YOUR_ACCESS_TOKEN_HERE}</code> with your access token from the <a href="https://t.me/botfather"><code>@BotFather</code></a>.</p>
</blockquote>
<pre><code class="language-c#">using Telegram.Bot;

var bot = new TelegramBotClient(&quot;{YOUR_ACCESS_TOKEN_HERE}&quot;);

var me = await bot.GetMeAsync();
Console.WriteLine($&quot;Hello, World! I am user {me.Id} and my name is {me.FirstName}.&quot;);
</code></pre>
<p>Running the program gives you the following output:</p>
<pre><code class="language-bash">dotnet run

Hello, World! I am user 1234567 and my name is Awesome Bot.
</code></pre>
<p>Great! This bot is self-aware. To make the bot interact with a user, head to the <a href="1/example-bot.html">next page</a>.</p>
<!-- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-example---your-first-bot"><a class="header" href="#full-example---your-first-bot">Full Example - Your first bot</a></h1>
<p>On the <a href="1/quickstart.html">previous page</a> we got an access token and used the <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method to check our setup.
Now, it is time to make an <em>interactive</em> bot that gets users' messages and replies to them like in this screenshot:</p>
<p><img src="1/docs/shot-example_bot.jpg" alt="Example Image" /></p>
<p>Copy the following code to <code>Program.cs</code>.</p>
<blockquote>
<p>‚ö†Ô∏è Replace <code>{YOUR_ACCESS_TOKEN_HERE}</code> with the access token from the [<code>@BotFather</code>].</p>
</blockquote>
<pre><code class="language-c#">using Telegram.Bot;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;

using var cts = new CancellationTokenSource();
var bot = new TelegramBotClient(&quot;{YOUR_ACCESS_TOKEN_HERE}&quot;, cancellationToken: cts.Token);
bot.StartReceiving(OnUpdate, async (bot, ex, ct) =&gt; Console.WriteLine(ex));

var me = await bot.GetMeAsync();
Console.WriteLine($&quot;@{me.Username} is running... Press Enter to terminate&quot;);
Console.ReadLine();
cts.Cancel(); // stop the bot

// method that handle updates coming for the bot:
async Task OnUpdate(ITelegramBotClient bot, Update update, CancellationToken ct)
{
    if (update.Message is null) return;			// we want only updates about new Message
    if (update.Message.Text is null) return;	// we want only updates about new Text Message
    var msg = update.Message;
    Console.WriteLine($&quot;Received message '{msg.Text}' in {msg.Chat}&quot;);
    // let's echo back received text in the chat
    await bot.SendTextMessageAsync(msg.Chat, $&quot;{msg.From} said: {msg.Text}&quot;);
}
</code></pre>
<p>Run the program:</p>
<pre><code class="language-bash">dotnet run
</code></pre>
<p>It runs waiting for text messages unless forcefully stopped by pressing Enter. Open a private chat with your bot in
Telegram and send a text message to it. Bot should reply in no time.</p>
<p>By invoking <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Polling/blob/master/src/Telegram.Bot.Extensions.Polling/Extensions/TelegramBotClientPollingExtensions.cs"><code>StartReceiving(...)</code></a> bot client starts fetching updates using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method for the bot
from Telegram servers. This operation does not block the caller thread, because it is done on the ThreadPool. We use <code>Console.ReadLine()</code> to keep the app running.</p>
<p>When user sends a message, the <code>OnUpdate(...)</code> method gets invoked with the <code>Update</code> object passed as an argument.
We check <code>Message.Type</code> and skip the rest if it is not a text message.
Finally, we send a text message back to the same chat we got the message from.</p>
<p>The second argument to <code>StartReceiving</code> is a lambda method invoked in case of an error that occurred while fetching updates.</p>
<p>If you take a look at the console, the program outputs the <code>chatId</code> value. <strong>Copy the chat id number</strong> to make testing easier
for yourself on the next pages.</p>
<pre><code class="language-text">Received a 'text' message in chat 123456789.
</code></pre>
<!-- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginner"><a class="header" href="#beginner">Beginner</a></h1>
<ul>
<li><a href="2/send-msg/">Sending Messages</a>
<ul>
<li><a href="2/send-msg/text-msg.html">Text</a></li>
<li><a href="2/send-msg/photo-sticker-msg.html">Photo &amp; Sticker</a></li>
<li><a href="2/send-msg/audio-voice-msg.html">Audio &amp; Voice</a></li>
<li><a href="2/send-msg/video-video_note-msg.html">Video &amp; Video Note</a></li>
<li><a href="2/send-msg/album-msg.html">Album (Media Group)</a></li>
<li><a href="2/send-msg/document-animation-msg.html">Document &amp; Animation</a></li>
<li><a href="2/send-msg/native-polls-msg.html">Native Polls</a></li>
<li><a href="2/send-msg/other-msg.html">Other Messages</a></li>
</ul>
</li>
<li><a href="2/reply-markup.html">Reply Markup</a></li>
<li><a href="2/forward-copy-delete.html">Forward, Copy or Delete</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-messages"><a class="header" href="#sending-messages">Sending Messages</a></h1>
<p>There are many different types of message that a bot can send.
Fortunately, methods for sending such messages are similar. Take a look at these examples:</p>
<h2 id="sending-text-message"><a class="header" href="#sending-text-message">Sending text message</a></h2>
<p><img src="2/send-msg/../docs/shot-text_msg.jpg" alt="text message screenshot" /></p>
<pre><code class="language-c#">await bot.SendTextMessageAsync(chatId, &quot;Hello, World!&quot;);
</code></pre>
<h2 id="sending-sticker-message"><a class="header" href="#sending-sticker-message">Sending sticker message</a></h2>
<p><img src="2/send-msg/../docs/shot-sticker.jpg" alt="sticker message screenshot" /></p>
<pre><code class="language-c#">await bot.SendStickerAsync(chatId, &quot;https://telegrambots.github.io/book/docs/sticker-dali.webp&quot;);
</code></pre>
<h2 id="sending-video-message"><a class="header" href="#sending-video-message">Sending video message</a></h2>
<p><img src="2/send-msg/../docs/shot-video.jpg" alt="video message screenshot" /></p>
<pre><code class="language-c#">await bot.SendVideoAsync(chatId, &quot;https://telegrambots.github.io/book/docs/video-hawk.mp4&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-messages-and-more"><a class="header" href="#text-messages-and-more">Text Messages and More</a></h1>
<p><a href="https://core.telegram.org/bots/api#sendmessage"><img src="https://img.shields.io/badge/Bot_API_method-sendMessage-blue.svg?style=flat-square" alt="send message method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/TextMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Text_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Text is a powerful interface for your bot and <a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> probably is the most used method of the Telegram Bot API.
Text messages are easy to send and fast to display on devices with slower networking.</p>
<p><em>Don't send boring plain text to users all the time</em>. Telegram allows you to format the text using HTML or Markdown.</p>
<blockquote>
<p>We highly recommend you use HTML instead of Markdown because Markdown has lots of annoying aspects</p>
</blockquote>
<h2 id="send-text-message"><a class="header" href="#send-text-message">Send Text Message</a></h2>
<p>The code snippet below sends a message with multiple parameters that looks like this:</p>
<p><img src="2/send-msg/../docs/shot-text_msg2.jpg" alt="text message screenshot" /></p>
<blockquote>
<p>You can use this code snippet in the event handler from Example Bot page and use <code>chatId</code>
or put the <code>chatId</code> value if you know it.</p>
</blockquote>
<pre><code class="language-c#">var message = await bot.SendTextMessageAsync(chatId, &quot;Trying &lt;b&gt;all the parameters&lt;/b&gt; of &lt;code&gt;sendMessage&lt;/code&gt; method&quot;,
    parseMode: ParseMode.Html,
    protectContent: true,
    replyParameters: update.Message.MessageId,
    replyMarkup: new InlineKeyboardMarkup(
        InlineKeyboardButton.WithUrl(&quot;Check sendMessage method&quot;, &quot;https://core.telegram.org/bots/api#sendmessage&quot;)));
</code></pre>
<p>The method <code>SendTextMessageAsync</code> of .NET Bot Client maps to <a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> on Telegram's Bot API. This method sends a
text message and returns the message object sent.</p>
<p><code>text</code> is written in <a href="https://core.telegram.org/bots/api#html-style">HTML format</a> and <code>parseMode</code> indicates that. You can also write in Markdown or plain text.</p>
<p>By passing <code>protectContent</code> we prevent the message (and eventual media) to be copiable/forwardable elsewhere.</p>
<p>It's a good idea to make it clear to a user the reason why the bot is sending this message and that's why we pass the user's
message id for <code>replyParameters</code>.</p>
<p>You have the option of specifying a <code>replyMarkup</code> when sending messages.
Reply markups are explained in details later in this book.
Here we used an <em>Inline Keyboard Markup</em> with a button that attaches to the message itself. Clicking that opens
<a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> method documentation in the browser.</p>
<h2 id="the-sent-message"><a class="header" href="#the-sent-message">The Sent Message</a></h2>
<p>Almost all of the methods for sending messages return you the message you just sent. Let's have a look at this object. Add this statement after the previous code.</p>
<pre><code class="language-c#">Console.WriteLine(
    $&quot;{message.From.FirstName} sent message {message.MessageId} &quot; +
    $&quot;to chat {message.Chat.Id} at {message.Date}. &quot; +
    $&quot;It is a reply to message {message.ReplyToMessage.MessageId} &quot; +
    $&quot;and has {message.Entities.Length} message entities.&quot;);
</code></pre>
<p>Output should look similar to this:</p>
<pre><code class="language-text">Awesome bot sent message 123 to chat 123456789 at 8/21/18 11:25:09 AM. It is a reply to message 122 and has 2 message entities.
</code></pre>
<p>There are a few things to note.</p>
<p>Date and time is in <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC format</a> and not your local timezone.
Convert it to local time by calling <code>message.Date.ToLocalTime()</code> method.</p>
<p><a href="https://core.telegram.org/bots/api#messageentity">Message Entity</a> refers to those formatted parts of the text: <em>all the parameters</em> in bold and
<em>sendMessage</em> in mono-width font.
Property <code>message.Entities</code> holds the formatting information and <code>message.EntityValues</code> gives you the actual value.
For example, in the message we just sent:</p>
<pre><code class="language-c#">message.Entities.First().Type == MessageEntityType.Bold
message.EntityValues.First()  == &quot;all the parameters&quot;
</code></pre>
<p>Try putting a breakpoint in the code to examine all the properties on a message objects you get.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="photo-and-sticker-messages"><a class="header" href="#photo-and-sticker-messages">Photo and Sticker Messages</a></h1>
<p>You can provide the source file for almost all multimedia messages (e.g. photo, video) in 3 ways:</p>
<ul>
<li>Uploading a file with the HTTP request</li>
<li>HTTP URL for Telegram to get a file from the internet</li>
<li><code>file_id</code> of an existing file on Telegram servers (<em>recommended</em>)</li>
</ul>
<p>Examples in this section show all three.
You will learn more about them later on when we discuss file <a href="2/send-msg/../../3/files/upload.html">upload</a> and <a href="2/send-msg/../../3/files/download.html">download</a>.</p>
<h2 id="photo"><a class="header" href="#photo">Photo</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendphoto"><img src="https://img.shields.io/badge/Bot_API_method-sendPhoto-blue.svg?style=flat-square" alt="send photo method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingPhotoMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Photo_Messages-green.svg?style=flat-square" alt="photo tests" /></a></p>
<p>Sending a photo is simple. Here is an example:</p>
<pre><code class="language-c#">var message = await bot.SendPhotoAsync(chatId, &quot;https://telegrambots.github.io/book/docs/photo-ara.jpg&quot;,
    caption: &quot;&lt;b&gt;Ara bird&lt;/b&gt;. &lt;i&gt;Source&lt;/i&gt;: &lt;a href=\&quot;https://pixabay.com\&quot;&gt;Pixabay&lt;/a&gt;&quot;, parseMode: ParseMode.Html);
</code></pre>
<p><img src="2/send-msg/../docs/shot-photo_msg.jpg" alt="photo message" /></p>
<h3 id="caption"><a class="header" href="#caption">Caption</a></h3>
<p>Multimedia messages can <em>optionally</em> have a caption attached to them. Here we sent a caption in HTML format.
A user can click on <em>Pixabay</em> in the caption to open its URL in the browser.</p>
<p>Similar to message entities discussed before, caption entities on <a href="https://core.telegram.org/bots/api#message"><code>Message</code></a> object are the result of
parsing formatted(Markdown or HTML) caption text.
Try inspecting these properties in debug mode:</p>
<ul>
<li><code>message.Caption</code>: caption in plain text without formatting</li>
<li><code>message.CaptionEntities</code>: info about special entities in the caption</li>
<li><code>message.CaptionEntityValues</code>: text values of mentioned entities</li>
</ul>
<h3 id="photo-message"><a class="header" href="#photo-message">Photo Message</a></h3>
<p>The <code>message</code> returned from this method represents a <em>photo message</em> because <code>message.Photo</code> has a value.
Its value is a <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> array with each element representing the same photo in different dimensions.
If your bot needs to send this photo again at some point, it is recommended to store this array
so you can reuse the <code>file_id</code> value.</p>
<p>Here is how <code>message.Photo</code> array looks like in JSON:</p>
<pre><code class="language-json">[
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABCQawlb-dBXqBZUEAAEC&quot;,
    &quot;file_size&quot;: 1254,
    &quot;width&quot;: 90,
    &quot;height&quot;: 60
  },
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABAKByRnc22RmBpUEAAEC&quot;,
    &quot;file_size&quot;: 16419,
    &quot;width&quot;: 320,
    &quot;height&quot;: 213
  },
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABHezqGiNOz9yB5UEAAEC&quot;,
    &quot;file_size&quot;: 57865,
    &quot;width&quot;: 640,
    &quot;height&quot;: 426
  }
]
</code></pre>
<h2 id="sticker"><a class="header" href="#sticker">Sticker</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendsticker"><img src="https://img.shields.io/badge/Bot_API_method-sendSticker-blue.svg?style=flat-square" alt="send sticker method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Stickers/StickersTests.cs"><img src="https://img.shields.io/badge/Examples-Sticker_Messages-green.svg?style=flat-square" alt="sticker tests" /></a></p>
<p>Telegram stickers are fun and our bot is about to send its very first sticker.
Sticker files should be in <a href="https://developers.google.com/speed/webp/">WebP</a> format.</p>
<p>This code sends the same sticker twice. First by passing HTTP URL to a <a href="https://developers.google.com/speed/webp/">WebP</a> sticker file and
second by reusing <code>FileId</code> of the same sticker on Telegram servers.</p>
<pre><code class="language-c#">var message1 = await bot.SendStickerAsync(chatId, &quot;https://telegrambots.github.io/book/docs/sticker-fred.webp&quot;);

var message2 = await bot.SendStickerAsync(chatId, message1.Sticker!.FileId);
</code></pre>
<p><img src="2/send-msg/../docs/shot-sticker_msgs.jpg" alt="sticker messages" /></p>
<p>Try inspecting the <code>sticker1.Sticker</code> property. It is of type <a href="https://core.telegram.org/bots/api#sticker"><code>Sticker</code></a> and its schema looks similar to a photo.</p>
<blockquote>
<p>There is more to stickers and we will talk about them in greater details later.</p>
</blockquote>
<!-- -------------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-and-voice-messages"><a class="header" href="#audio-and-voice-messages">Audio and Voice Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AudioMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Audio_Messages-green.svg?style=flat-square" alt="audio tests" /></a></p>
<p>These two types of messages are pretty similar. Audio is MP3-encoded file that can be played in music player.
A voice file has OGG format and is not shown in music player.</p>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendaudio"><img src="https://img.shields.io/badge/Bot_API_method-sendAudio-blue.svg?style=flat-square" alt="send audio method" /></a></p>
<p>This is the code to send an MP3 soundtrack. You might be wondering why some parameters are commented out?
That's because this MP3 file has metadata on it and Telegram does a good job at reading it.</p>
<pre><code class="language-c#">var message = await bot.SendAudioAsync(chatId, &quot;https://telegrambots.github.io/book/docs/audio-guitar.mp3&quot;
    //  , performer: &quot;Joel Thomas Hunger&quot;, title: &quot;Fun Guitar and Ukulele&quot;, duration: 91    // optional
    );
</code></pre>
<p><img src="2/send-msg/../docs/shot-audio_msg.jpg" alt="audio message" /></p>
<p>And a user can see the audio in Music Player:</p>
<p><img src="2/send-msg/../docs/shot-music_player.jpg" alt="music player" /></p>
<p>Method returns an audio message. Let's take a look at the value of <code>message.Audio</code> property in JSON format:</p>
<pre><code class="language-json">{
  &quot;duration&quot;: 91,
  &quot;mime_type&quot;: &quot;audio/mpeg&quot;,
  &quot;title&quot;: &quot;Fun Guitar and Ukulele&quot;,
  &quot;performer&quot;: &quot;Joel Thomas Hunger&quot;,
  &quot;file_id&quot;: &quot;CQADBAADKQADA3oUUKalqDOOcqesAg&quot;,
  &quot;file_size&quot;: 1102154
}
</code></pre>
<h2 id="voice"><a class="header" href="#voice">Voice</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvoice"><img src="https://img.shields.io/badge/Bot_API_method-sendVoice-blue.svg?style=flat-square" alt="send voice method" /></a></p>
<p>A voice message is an OGG audio file.
Let's send it differently this time by uploading the file from disk alongside with an HTTP request.</p>
<p>To run this example, download the <a href="https://telegrambots.github.io/book/docs/voice-nfl_commentary.ogg">NFL Commentary voice file</a> to your disk.</p>
<p>A value is passed for <code>duration</code> because Telegram can't figure that out from a file's metadata.</p>
<blockquote>
<p>‚ö†Ô∏è Replace <code>/path/to/voice-nfl_commentary.ogg</code> with an actual file path.</p>
</blockquote>
<pre><code class="language-c#">await using Stream stream = System.IO.File.OpenRead(&quot;/path/to/voice-nfl_commentary.ogg&quot;);
var message = await bot.SendVoiceAsync(chatId, stream, duration: 36);
</code></pre>
<p><img src="2/send-msg/../docs/shot-voice_msg.jpg" alt="voice message" /></p>
<p>A voice message is returned from the method. Inspect the <code>message.Voice</code> property to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="video-and-video-note-messages"><a class="header" href="#video-and-video-note-messages">Video and Video Note Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/VideoMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Video_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>You can send MP4 files as a regular video or a <em>video note</em>.
Other video formats may be sent as documents.</p>
<h2 id="video"><a class="header" href="#video">Video</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvideo"><img src="https://img.shields.io/badge/Bot_API_method-sendVideo-blue.svg?style=flat-square" alt="method sendVideo" /></a></p>
<p>Videos, like other multimedia messages, can have caption, reply, reply markup, and etc.
You can optionally specify the duration and resolution of the video.</p>
<p>In the example below, we send a video of a 10 minute countdown
and expect the Telegram clients to stream that long video instead of downloading it completely.
We also set a thumbnail image for our video.</p>
<pre><code class="language-c#">await bot.SendVideoAsync(chatId, &quot;https://telegrambots.github.io/book/docs/video-countdown.mp4&quot;,
    thumbnail: &quot;https://telegrambots.github.io/book/2/docs/thumb-clock.jpg&quot;, supportsStreaming: true);
</code></pre>
<blockquote>
<p>Check the Bot API docs for <code>sendVideo</code> method to learn more about video size limits and the thumbnail images.</p>
</blockquote>
<p><img src="2/send-msg/../docs/shot-video_thumb1.jpg" alt="vide screenshot 1" /></p>
<p>User should be able to seek through the video without the video being downloaded completely.</p>
<p><img src="2/send-msg/../docs/shot-video_thumb2.jpg" alt="vide screenshot 2" /></p>
<h2 id="video-note"><a class="header" href="#video-note">Video Note</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvideonote"><img src="https://img.shields.io/badge/Bot_API_method-sendVideoNote-blue.svg?style=flat-square" alt="method sendVideoNote" /></a></p>
<p>Video notes, shown in circles to the user, are usually short (1 minute or less) with the same width and height.</p>
<p>You can send a video note only by uploading the video file or reusing the <code>file_id</code> of another video note.
Sending video note by its HTTP URL is not supported currently.</p>
<p>Download the <a href="https://telegrambots.github.io/book/docs/video-waves.mp4">Sea Waves video</a> to your disk for this example.</p>
<pre><code class="language-c#">await using Stream stream = System.IO.File.OpenRead(&quot;/path/to/video-waves.mp4&quot;);

await bot.SendVideoNoteAsync(chatId, stream,
    duration: 47, length: 360); // value of width/height
</code></pre>
<p><img src="2/send-msg/../docs/shot-video_note.jpg" alt="vide note screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="album-messages"><a class="header" href="#album-messages">Album Messages</a></h1>
<p><a href="https://core.telegram.org/bots/api#sendmediagroup"><img src="https://img.shields.io/badge/Bot_API_method-sendMediaGroup-blue.svg?style=flat-square" alt="send media group method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AlbumMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Album_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Using <a href="https://core.telegram.org/bots/api#sendmediagroup"><code>sendMediaGroup</code></a> method you can send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type.</p>
<pre><code class="language-c#">var messages = await bot.SendMediaGroupAsync(chatId, new IAlbumInputMedia[]
    {
        new InputMediaPhoto(&quot;https://cdn.pixabay.com/photo/2017/06/20/19/22/fuchs-2424369_640.jpg&quot;),
        new InputMediaPhoto(&quot;https://cdn.pixabay.com/photo/2017/04/11/21/34/giraffe-2222908_640.jpg&quot;),
    });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-and-animation-messages"><a class="header" href="#document-and-animation-messages">Document and Animation Messages</a></h1>
<h2 id="send-documents"><a class="header" href="#send-documents">Send documents</a></h2>
<p><a href="https://core.telegram.org/bots/api#senddocument"><img src="https://img.shields.io/badge/Bot_API_method-sendDocument-blue.svg?style=flat-square" alt="sendDocument method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/DocumentMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Document_Message-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Use <a href="https://core.telegram.org/bots/api#senddocument"><code>sendDocument</code></a> method to send general files.</p>
<pre><code class="language-c#">await bot.SendDocumentAsync(chatId, &quot;https://telegrambots.github.io/book/docs/photo-ara.jpg&quot;,
    caption: &quot;&lt;b&gt;Ara bird&lt;/b&gt;. &lt;i&gt;Source&lt;/i&gt;: &lt;a href=\&quot;https://pixabay.com\&quot;&gt;Pixabay&lt;/a&gt;&quot;, parseMode: ParseMode.Html);
</code></pre>
<h2 id="send-animations"><a class="header" href="#send-animations">Send animations</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendanimation"><img src="https://img.shields.io/badge/Bot_API_method-sendAnimation-blue.svg?style=flat-square" alt="sendAnimation method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AnimationMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Animation_Message-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Use <a href="https://core.telegram.org/bots/api#sendanimation"><code>sendAnimation</code></a> method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).</p>
<pre><code class="language-c#">await bot.SendAnimationAsync(chatId, &quot;https://telegrambots.github.io/book/docs/video-waves.mp4&quot;,
    caption: &quot;Waves&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-poll-messages"><a class="header" href="#native-poll-messages">Native Poll Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Polls/AnonymousPollTests.cs"><img src="https://img.shields.io/badge/Examples-Native_Polls-green.svg?style=flat-square" alt="native poll tests" /></a></p>
<p>Just as regular users bots can only send native polls to groups and channels, but not to private chats.</p>
<h2 id="send-a-poll"><a class="header" href="#send-a-poll">Send a poll</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendpoll"><img src="https://img.shields.io/badge/Bot_API_method-sendPoll-blue.svg?style=flat-square" alt="sendPoll method" /></a></p>
<p>This is the code to send a poll to a chat.</p>
<pre><code class="language-c#">
var pollMessage = await bot.SendPollAsync(&quot;@channel_name&quot;,
    &quot;Did you ever hear the tragedy of Darth Plagueis The Wise?&quot;,
    new InputPollOption[]
    {
        &quot;Yes for the hundredth time!&quot;,
        &quot;No, who`s that?&quot;
    });
</code></pre>
<p><img src="2/send-msg/../docs/shot-native_poll_msg.jpeg" alt="native poll" /></p>
<p>You can optionally send a keyboard with a poll, both an inline or a regular one.</p>
<p>You'll get the message with <a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/src/Telegram.Bot/Types/Poll.cs"><code>Poll</code></a> object inside it.</p>
<h2 id="stop-a-poll"><a class="header" href="#stop-a-poll">Stop a poll</a></h2>
<p><a href="https://core.telegram.org/bots/api#stoppoll"><img src="https://img.shields.io/badge/Bot_API_method-stopPoll-blue.svg?style=flat-square" alt="stopPoll method" /></a></p>
<p>To close a poll you need to know original chat and message ids of the poll that you got from calling <code>SendPollAsync</code> method.</p>
<p>Let's close the poll that we sent in the previous example:</p>
<pre><code class="language-c#">Poll poll = await bot.StopPollAsync(pollMessage.Chat.Id, pollMessage.MessageId);
</code></pre>
<p><img src="2/send-msg/../docs/shot-native_poll_closed.jpeg" alt="closed native poll" /></p>
<p>You can add an inline keyboard when you close a poll.</p>
<p>As a result of the request you'll get the the final poll state with property <code>Poll.IsClosed</code> set to true.</p>
<p>If you'll try to close a forwarded poll using message and chat ids from the received message even if your bot is the author of the poll you'll get an <code>ApiRequestException</code> with message <code>Bad Request: poll can't be stopped</code>. Polls originated from channels is an exception since forwarded messages originated from channels contain original chat and message ids inside properties <code>Message.ForwardFromChat.Id</code> and <code>Message.ForwardFromMessageId</code>.</p>
<p>Also if you'll try to close an already closed poll you'll get <code>ApiRequestException</code> with message <code>Bad Request: poll has already been closed</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-messages"><a class="header" href="#other-messages">Other Messages</a></h1>
<p>There are other kind of message types which are supported by the client. In the following paragraphs we will look how to send contacts, venues or locations.</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendcontact"><img src="https://img.shields.io/badge/Bot_API_method-sendContact-blue.svg?style=flat-square" alt="send contact method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingContactMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Contact-green.svg?style=flat-square" alt="send contacts tests" /></a></p>
<p>This is the code to send a contact. Mandatory are the parameters <code>chatId</code>, <code>phoneNumber</code> and <code>firstName</code>.</p>
<pre><code class="language-c#">await bot.SendContactAsync(chatId, phoneNumber: &quot;+1234567890&quot;, firstName: &quot;Han&quot;, lastName: &quot;Solo&quot;);
</code></pre>
<p><img src="2/send-msg/../docs/shot-contact.jpg" alt="send contact" /></p>
<p>If you want to send a contact as vCard you can achieve  this by adding a valid vCard <code>string</code> as value for the optional parameter <code>vCard</code> as seen in the given example below.</p>
<pre><code class="language-c#">await bot.SendContactAsync(chatId, phoneNumber: &quot;+1234567890&quot;, firstName: &quot;Han&quot;,
    vcard: &quot;BEGIN:VCARD\n&quot; +
           &quot;VERSION:3.0\n&quot; +
           &quot;N:Solo;Han\n&quot; +
           &quot;ORG:Scruffy-looking nerf herder\n&quot; +
           &quot;TEL;TYPE=voice,work,pref:+1234567890\n&quot; +
           &quot;EMAIL:hansolo@mfalcon.com\n&quot; +
           &quot;END:VCARD&quot;);
</code></pre>
<p><img src="2/send-msg/../docs/shot-contact_vcard.jpg" alt="send vcard" /></p>
<h2 id="venue"><a class="header" href="#venue">Venue</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvenue"><img src="https://img.shields.io/badge/Bot_API_method-sendVenue-blue.svg?style=flat-square" alt="send venue method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingVenueMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Venue-green.svg?style=flat-square" alt="send venue tests" /></a></p>
<p>The code snippet below sends a venue with a title and a address as given parameters:</p>
<pre><code class="language-c#">await bot.SendVenueAsync(chatId, latitude: 50.0840172f, longitude: 14.418288f,
    title: &quot;Man Hanging out&quot;, address: &quot;Husova, 110 00 Star√© Mƒõsto, Czechia&quot;);
</code></pre>
<p><img src="2/send-msg/../docs/shot-venue.jpg" alt="send contact" /></p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendlocation"><img src="https://img.shields.io/badge/Bot_API_method-sendLocation-blue.svg?style=flat-square" alt="send location method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingVenueMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Location-green.svg?style=flat-square" alt="send location tests" /></a></p>
<p>The difference between sending a location and a venue is, that the venue requires a title and address. A location can be any given point as latitude and longitude.</p>
<p>The following snippet shows how to send a location with the mandatory parameters:</p>
<pre><code class="language-c#">await bot.SendLocationAsync(chatId, latitude: 33.747252f, longitude: -112.633853f);
</code></pre>
<p><img src="2/send-msg/../docs/shot-location.jpg" alt="send contact" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reply-markup"><a class="header" href="#reply-markup">Reply Markup</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/ReplyMarkup/ReplyMarkupTests.cs"><img src="https://img.shields.io/badge/Examples-Reply_Markup-green.svg?style=flat-square" alt="reply markup tests" /></a></p>
<p>Telegram provides two types of reply markup: <a href="2/reply-markup.html#custom-keyboards">Custom keyboards</a> and <a href="2/reply-markup.html#inline-keyboards">Inline keyboards</a>.</p>
<h2 id="custom-keyboards"><a class="header" href="#custom-keyboards">Custom keyboards</a></h2>
<p>Whenever your bot sends a message, it can pass along a <a href="https://core.telegram.org/bots#keyboards">special keyboard</a> with predefined reply options. Regular keyboards are represented by <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> object. You can request a contact or location information from the user with <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> or send a poll. Regular button will send predefined text to the chat.</p>
<p>Keyboard is an array of button rows, each represented by an array of <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> objects. <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> supports text and emoji.</p>
<p>By default, custom keyboards are displayed until a new keyboard is sent by a bot.</p>
<h3 id="single-row-keyboard-markup"><a class="header" href="#single-row-keyboard-markup">Single-row keyboard markup</a></h3>
<p>A <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> with two buttons in a single row:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new KeyboardButton[]
{
    &quot;Help me&quot;, &quot;Call me ‚òéÔ∏è&quot;,
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;Choose a response&quot;,
    replyMarkup: new ReplyKeyboardMarkup(buttons) { ResizeKeyboard = true });
</code></pre>
<blockquote>
<p>We specify <code>ResizeKeyboard = true</code> here to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons).</p>
</blockquote>
<h3 id="multi-row-keyboard-markup"><a class="header" href="#multi-row-keyboard-markup">Multi-row keyboard markup</a></h3>
<p>A <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> with two rows of buttons:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new KeyboardButton[][]
{
    new KeyboardButton[] { &quot;Help me&quot; },
    new KeyboardButton[] { &quot;Call me ‚òéÔ∏è&quot;, &quot;Write me ‚úâÔ∏è&quot; },
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;Choose a response&quot;,
    replyMarkup: new ReplyKeyboardMarkup(buttons) { ResizeKeyboard = true });
</code></pre>
<p>You can use <code>new List&lt;List&lt;KeyboardButton&gt;&gt;</code> instead of <code>KeyboardButton[][]</code> if you prefer to build the list dynamically.</p>
<h3 id="request-information"><a class="header" href="#request-information">Request information</a></h3>
<p><a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> containing buttons for contact and location requests using helper methods <code>KeyboardButton.WithRequestLocation</code> and <code>KeyboardButton.WithRequestContact</code>:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new[]
{
    KeyboardButton.WithRequestLocation(&quot;Share Location&quot;),
    KeyboardButton.WithRequestContact(&quot;Share Contact&quot;),
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;Who or Where are you?&quot;,
    replyMarkup: new ReplyKeyboardMarkup(buttons));
</code></pre>
<h3 id="remove-keyboard"><a class="header" href="#remove-keyboard">Remove keyboard</a></h3>
<p>To remove keyboard you have to send an instance of <a href="https://core.telegram.org/bots/api#replykeyboardremove"><code>ReplyKeyboardRemove</code></a> object:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var sent = await bot.SendTextMessageAsync(chatId, &quot;Removing keyboard&quot;,
    replyMarkup: new ReplyKeyboardRemove());
</code></pre>
<h2 id="inline-keyboards"><a class="header" href="#inline-keyboards">Inline keyboards</a></h2>
<p>There are times when you'd prefer to do things without sending any messages to the chat. For example, when your user is changing settings or flipping through search results. In such cases you can use <a href="https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating">Inline Keyboards</a> that are integrated directly into the messages they belong to.</p>
<p>Unlike custom reply keyboards, pressing buttons on inline keyboards doesn't result in messages sent to the chat. Instead, inline keyboards support buttons that work behind the scenes: <a href="2/reply-markup.html#callback-buttons">callback buttons</a>, <a href="2/reply-markup.html#url-buttons">URL buttons</a> and <a href="2/reply-markup.html#switch-to-inline-buttons">switch to inline buttons</a>.</p>
<h3 id="callback-buttons"><a class="header" href="#callback-buttons">Callback buttons</a></h3>
<p>When a user presses a <a href="https://core.telegram.org/bots/2-0-intro#callback-buttons">callback button</a>, no messages are sent to the chat. Instead, your bot simply receives the relevant query. Upon receiving the query, your bot can display some result in a notification at the top of the chat screen or in an alert. In this example we use <code>InlineKeyboardButton.WithCallbackData</code> helper method to create a button with a text and callback data.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new InlineKeyboardButton[][]
{
    new[] // first row
    {
        InlineKeyboardButton.WithCallbackData(&quot;1.1&quot;, &quot;11&quot;),
        InlineKeyboardButton.WithCallbackData(&quot;1.2&quot;, &quot;12&quot;),
    },
    new[] // second row
    {
        InlineKeyboardButton.WithCallbackData(&quot;2.1&quot;, &quot;21&quot;),
        InlineKeyboardButton.WithCallbackData(&quot;2.2&quot;, &quot;22&quot;),
    },
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: new InlineKeyboardMarkup(buttons));
</code></pre>
<p>You can use <code>new List&lt;List&lt;InlineKeyboardButton&gt;&gt;</code> instead of <code>InlineKeyboardButton[][]</code> if you prefer to build the list dynamically.</p>
<h3 id="url-buttons"><a class="header" href="#url-buttons">URL buttons</a></h3>
<p>Buttons of this type have a small arrow icon to help the user understand that tapping on a <a href="https://core.telegram.org/bots/2-0-intro#url-buttons">URL button</a> will open an external link. In this example we use <code>InlineKeyboardButton.WithUrl</code> helper method to create a button with a text and url.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new[]
{
    InlineKeyboardButton.WithUrl(&quot;Repository Link&quot;, &quot;https://github.com/TelegramBots/Telegram.Bot&quot;)
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: new InlineKeyboardMarkup(buttons));
</code></pre>
<h3 id="switch-to-inline-buttons"><a class="header" href="#switch-to-inline-buttons">Switch to Inline buttons</a></h3>
<p>Pressing a <a href="https://core.telegram.org/bots/2-0-intro#switch-to-inline-buttons">switch to inline button</a> prompts the user to select a chat, opens it and inserts the bot's username into the input field. You can also pass a query that will be inserted along with the username ‚Äì this way your users will immediately get some inline results they can share. In this example we use <code>InlineKeyboardButton.WithSwitchInlineQuery</code> and <code>InlineKeyboardButton.WithSwitchInlineQueryCurrentChat</code> helper methods to create buttons which will insert the bot's username in the chat's input field.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

var buttons = new[]
{
    InlineKeyboardButton.WithSwitchInlineQuery(&quot;switch_inline_query&quot;),
    InlineKeyboardButton.WithSwitchInlineQueryCurrentChat(&quot;switch_inline_query_current_chat&quot;),
};

var sent = await bot.SendTextMessageAsync(chatId, &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: new InlineKeyboardMarkup(buttons));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forward-copy-or-delete-messages"><a class="header" href="#forward-copy-or-delete-messages">Forward, Copy or Delete messages</a></h1>
<p>You can forward, copy, or delete a single message, or even a bunch of messages in one go.</p>
<p>You will need to provide the source messageId(s), the source chatId and eventually the target chatId.</p>
<p><em>Note: When you use the plural form of the copy/forward methods, it will keep Media Groups (albums) as such.</em></p>
<h2 id="forward-messages"><a class="header" href="#forward-messages">Forward message(s)</a></h2>
<p>You can <strong>forward</strong> message(s) from a source chat to a target chat <em>(it can be the same chat)</em>.
They will appear with a &quot;Forwarded from&quot; header.</p>
<pre><code class="language-csharp">// Forward a single message
await bot.CopyMessageAsync(targetChatId, sourceChatId, messageId);

// Forward an incoming message (from the update) onto a target ChatId
await bot.ForwardMessageAsync(chatId, update.Message.Chat, update.Message.MessageId);

// Forward a bunch of messages from a source ChatId to a target ChatId, using a list of their message ids
await bot.ForwardMessagesAsync(targetChatId, sourceChatId, new int[] { 123, 124, 125 });
</code></pre>
<h2 id="copy-messages"><a class="header" href="#copy-messages">Copy message(s)</a></h2>
<p>If you don't want the &quot;Forwarded from&quot; header, you can instead <strong>copy</strong> the message(s).</p>
<p>This will make them look like new messages.</p>
<pre><code class="language-csharp">// Copy a single message
await bot.CopyMessageAsync(targetChatId, sourceChatId, messageId);

// Copy an incoming message (from the update) onto a target ChatId
await bot.CopyMessageAsync(targetChatId, update.Message.Chat, update.Message.MessageId);

// Copy a media message and change its caption at the same time
await bot.CopyMessageAsync(targetChatId, update.Message.Chat, update.Message.MessageId,
    caption: &quot;New &lt;b&gt;caption&lt;/b&gt; for this media&quot;, parseMode: ParseMode.Html);

// Copy a bunch of messages from a source ChatId to a target ChatId, using a list of their message ids
await bot.CopyMessagesAsync(targetChatId, sourceChatId, new int[] { 123, 124, 125 });
</code></pre>
<h2 id="delete-messages"><a class="header" href="#delete-messages">Delete message(s)</a></h2>
<p>Finally you can <strong>delete</strong> message(s).</p>
<p>This is particularly useful for cleaning unwanted messages in groups.</p>
<pre><code class="language-csharp">// Delete a single message
await bot.DeleteMessageAsync(chatId, messageId);

// Delete an incoming message (from the update)
await bot.CopyMessageAsync(update.Message.Chat, update.Message.MessageId);

// Delete a bunch of messages, using a list of their message ids
await bot.DeleteMessagesAsync(chatId, new int[] { 123, 124, 125 });
</code></pre>
<h2 id="check-if-a-message-is-a-forward"><a class="header" href="#check-if-a-message-is-a-forward">Check if a message is a forward</a></h2>
<p>When receiving an update about a message, you can check if that message is &quot;Forwarded from&quot; somewhere,
by checking if <code>Message.ForwardOrigin</code> is set:</p>
<pre><code class="language-csharp">Console.WriteLine(update.Message.ForwardOrigin switch
{
    MessageOriginChannel moc     =&gt; $&quot;Forwarded from channel {moc.Chat.Title}&quot;,
    MessageOriginUser mou        =&gt; $&quot;Forwarded from user {mou.SenderUser}&quot;,
    MessageOriginHiddenUser mohu =&gt; $&quot;Forwarded from hidden user {mohu.SenderUserName}&quot;,
    MessageOriginChat moch       =&gt; $&quot;Forwarded on behalf of {moch.SenderChat}&quot;,
    _                            =&gt; &quot;Not forwarded&quot;
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h1>
<ul>
<li><a href="3/updates/">Getting Updates</a>
<ul>
<li><a href="3/updates/polling.html">Long Polling</a></li>
<li><a href="3/updates/webhook.html">Webhooks</a></li>
</ul>
</li>
<li><a href="3/inline.html">Inline Mode</a></li>
<li><a href="3/files/">Files</a>
<ul>
<li><a href="3/files/download.html">Download</a></li>
<li><a href="3/files/upload.html">Upload</a></li>
</ul>
</li>
<li><a href="3/sticker.html">Stickers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-updates"><a class="header" href="#getting-updates">Getting Updates</a></h1>
<p>There are two mutually exclusive ways of receiving updates for your bot ‚Äî the long polling using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method on one hand and Webhooks on the other. Telegram is queueing updates until the bot receives them either way, but they will not be kept longer than 24 hours.</p>
<ul>
<li>
<p>With long polling, the client requests information from the server using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method, but with the expectation the server may not respond immediately. If the server has no new information for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for response information to become available. Once it does have new information, the server immediately sends a response to the client, completing the request. Upon receipt of the server response, the client often immediately issues another server request.</p>
</li>
<li>
<p><a href="3/updates/webhook.html">Setting a webhook</a> means you supplying Telegram with a location in the form of an URL, on which your bot listens for updates. Telegram need to be able to connect and post updates to that URL.
To be able to handle webhook updates you'll need a server that:</p>
<ul>
<li>Supports IPv4, IPv6 is currently not supported for webhooks.</li>
<li>Accepts incoming POSTs from subnets 149.154.160.0/20 and 91.108.4.0/22 on port 443, 80, 88, or 8443.</li>
<li>Is able to handle TLS1.2(+) HTTPS-traffic.</li>
<li>Provides a supported, non-wildcard, verified or self-signed certificate.</li>
<li>Uses a CN or SAN that matches the domain you‚Äôve supplied on setup.</li>
<li>Supplies all intermediate certificates to complete a verification chain.</li>
</ul>
<p>You can find more useful information on setting webhook in <a href="https://core.telegram.org/bots/webhooks">Marvin's Marvellous Guide to All Things Webhook</a></p>
</li>
</ul>
<p>Each user interaction with your bot results in new
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/src/Telegram.Bot/Types/Update.cs">Update</a> object. Its fields will be set depending on update type.</p>
<h2 id="example-projects"><a class="header" href="#example-projects">Example projects</a></h2>
<h3 id="long-polling"><a class="header" href="#long-polling">Long polling</a></h3>
<ul>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Console">Console application</a>. Demonstrates a basic bot with some commands.</li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Console.Advanced">Advanced console application</a>. Demonstrates the use of many advanced programming features.</li>
</ul>
<h3 id="webhook"><a class="header" href="#webhook">Webhook</a></h3>
<ul>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Webhook.MinimalAPIs">ASP.NET Core</a> web application with Minimal APIs</li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Webhook.Controllers">ASP.NET Core</a> web application with Controllers</li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Serverless/AzureFunctions.Webhook">Azure Functions</a></li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Serverless/AwsLambda.Webhook">AWS Lambda</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="long-polling-1"><a class="header" href="#long-polling-1">Long Polling</a></h1>
<p>If you don't want to use our recommended <strong>StartReceiving</strong> helper (<a href="3/updates/../../1/example-bot.html">see first example</a>),
you can just call GetUpdateAsync with a timeout in a loop,
such that the call blocks for <strong>up to</strong> X seconds until there is an incoming update</p>
<p>Here is an example implementation:</p>
<pre><code class="language-csharp">CancellationTokenSource cts = new();
var bot = new TelegramBotClient(&quot;{YOUR BOT TOKEN HERE}&quot;, cancellationToken: cts.Token);

int? offset = null;
while (!cts.IsCancellationRequested)
{
    var updates = await bot.GetUpdatesAsync(offset, timeout: 2);
    foreach (var update in updates)
    {
        offset = update.Id + 1;
        try
        {
            // put your code to handle one Update here.
        }
        catch (Exception ex)
        {
            // log exception and continue
        }
        if (cts.IsCancellationRequested) break;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webhooks"><a class="header" href="#webhooks">Webhooks</a></h1>
<p><a href="https://core.telegram.org/bots/webhooks"><img src="https://img.shields.io/badge/Bot_API-Webhook%20guide-blue.svg?style=flat-square" alt="Webhook guide" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Webhook.MinimalAPIs"><img src="https://img.shields.io/badge/Examples-ASP.NET%20WebApp-green?style=flat-square" alt="Webhook ASP.NET example" /></a></p>
<p>With Webhook, your application gets notified automatically by Telegram when new updates arrive for your bot.</p>
<p>Your application will receive HTTP POST requests with an Update structure in the body, using specific JSON serialization settings as presented in <code>Telegram.Bot.Serialization.JsonSerializerOptionsProvider.Options</code>.</p>
<p>Below, you will find how to configure an <strong>ASP.NET Core Web API</strong> project to make it work with Telegram.Bot, either with Controllers or Minimal APIs</p>
<h2 id="aspnet-core-with-controllers-mvc"><a class="header" href="#aspnet-core-with-controllers-mvc">ASP.NET Core with Controllers (MVC)</a></h2>
<p>First you need to configure your Web App startup code:</p>
<ul>
<li>Locate the line <code>services.AddControllers();</code> <em>(in Program.cs or Startup.cs)</em></li>
<li>If you're using .NET 6.0 or more recent, add the line:
<pre><code class="language-csharp">services.ConfigureTelegramBotMvc();
</code></pre>
</li>
<li>For older .NET versions, add the line:
<pre><code class="language-csharp">services.ConfigureTelegramBot&lt;Microsoft.AspNetCore.Mvc.JsonOptions&gt;(opt =&gt; opt.JsonSerializerOptions);
</code></pre>
</li>
</ul>
<p>Next, in a controller class (like BotController.cs), you need to add an action for the updates. Typically:</p>
<pre><code class="language-csharp">[HttpPost]
public async Task HandleUpdate([FromBody] Update update)
{
    // put your code to handle one Update here.
}
</code></pre>
<p>Good, now skip to <a href="3/updates/webhook.html#setwebhookasync">SetWebHookAsync</a> below</p>
<h2 id="aspnet-core-with-minimal-apis"><a class="header" href="#aspnet-core-with-minimal-apis">ASP.NET Core with Minimal APIs</a></h2>
<p>First you need to configure your Web App startup code:</p>
<ul>
<li>Locate the line <code>builder.Build();</code> <em>(in Program.cs)</em></li>
<li>Above it, insert the line:
<pre><code class="language-csharp">builder.Services.ConfigureTelegramBot&lt;Microsoft.AspNetCore.Http.Json.JsonOptions&gt;(opt =&gt; opt.SerializerOptions);
</code></pre>
</li>
</ul>
<p>Next, you need to map an action for the updates. Typically:</p>
<pre><code class="language-csharp">app.MapPost(&quot;/bot&quot;, (Update update) =&gt; HandleUpdate(update));
...

async Task HandleUpdate(Update update)
{
    // put your code to handle one Update here.
}
</code></pre>
<p>Good, now skip to <a href="3/updates/webhook.html#setwebhookasync">SetWebHookAsync</a> below</p>
<h2 id="old-aspnet-4x-support"><a class="header" href="#old-aspnet-4x-support">Old ASP.NET 4.x support</a></h2>
<p>For older .NET Framework usage, you may use the following code:</p>
<pre><code class="language-csharp">public async Task&lt;IHttpActionResult&gt; Post()
{
    Update update;
    using (var body = await Request.Content.ReadAsStreamAsync())
        update = System.Text.Json.JsonSerializer.Deserialize&lt;Update&gt;(body, JsonSerializerOptionsProvider.Options);
    await HandleUpdate(update);
    return Ok();
}
</code></pre>
<h2 id="setwebhookasync"><a class="header" href="#setwebhookasync">SetWebHookAsync</a></h2>
<p>Your update handler code is ready, now you need to instruct Telegram to send updates to your URL, by running:</p>
<pre><code class="language-csharp">var bot = new TelegramBotClient(&quot;YOUR_BOT_TOKEN&quot;);
await bot.SetWebhookAsync(&quot;https://your.public.host:port/bot&quot;, allowedUpdates: []);
</code></pre>
<p>You can now deploy your app to your webapp host machine.</p>
<h2 id="common-issues"><a class="header" href="#common-issues">Common issues</a></h2>
<ul>
<li>You need a supported certificate
If your host doesn't provide one or you want to develop on your own machine, consider using <a href="https://ngrok.com/">ngrok</a>:
Useful <a href="https://medium.com/@oktaykopcak/81c8c4a9a853">step-by-step guide</a></li>
<li>You must use HTTPS (TLS 1.2+), IPv4, and ports 443, 80, 88, or 8443</li>
<li><a href="https://core.telegram.org/bots/webhooks">Official webhook guide</a></li>
<li>If your update handler throws an exception or takes too much time to return,
Telegram will consider it a temporary failure and will RESEND the same update a bit later.<br />
So you may want to prevent handling the same update.Id twice:
<pre><code class="language-csharp">if (update.Id &lt;= LastUpdateId) return;
LastUpdateId = update.Id;
// put your code to handle the Update here.
</code></pre>
</li>
<li>Most web hostings will recycle your app after some HTTP inactivity (= stop your app and restart it on the next HTTP request)<br />
To prevent issues like this:
<ul>
<li>Search for an Always-On option with your host <em>(usually not free)</em></li>
<li>Make sure your web app can be safely stopped (saved state) and restarted later (reloading state)</li>
<li>Make sure you don't have critical background code that needs to keep running at all time</li>
<li>Have a service like <a href="https://cron-job.org/">cron-job.org</a> ping your webapp every 5 minutes to keep it active.
<em>(host will likely still recycle your app after a few days)</em></li>
<li>Host your app on a VPS machine rather than a webapp host.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-mode"><a class="header" href="#inline-mode">Inline Mode</a></h1>
<p><a href="https://core.telegram.org/bots/api#inline-mode"><img src="https://img.shields.io/badge/Bot_API_Doc-Inline%20Mode-blue.svg?style=flat-square" alt="inline mode bot API" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot.Examples/blob/master/InlineQueries/Program.cs"><img src="https://img.shields.io/badge/Examples-Inline%20Queries-green?style=flat-square" alt="inline queries example" /></a></p>
<p>Telegram bots can be queried directly in the chat or via inline queries.</p>
<p>To use inline queries in your bot, you need to set up inline mode by command:</p>
<p><img src="3/docs/shot-setinline_command.png" alt="/setinline command in BotFather" /></p>
<p>Import <code>Telegram.Bot.Types.InlineQueryResults</code> namespace for inline query types.</p>
<p>There are two types that allow you to work with inline queries - <code>InlineQuery</code> and <code>ChosenInlineResult</code>:</p>
<pre><code class="language-c#">switch (update.Type)
{
    case UpdateType.InlineQuery:
        await OnInlineQueryReceived(bot, update.InlineQuery!);
        break;
    case UpdateType.ChosenInlineResult:
        await OnChosenInlineResultReceived(bot, update.ChosenInlineResult!);
        break;
};
</code></pre>
<h2 id="inlinequery"><a class="header" href="#inlinequery"><code>InlineQuery</code></a></h2>
<p><a href="https://core.telegram.org/bots/api#inlinequeryresult"><img src="https://img.shields.io/badge/Bot_API_Object-InlineQueryResult-blue.svg?style=flat-square" alt="inline query result bot API" /></a></p>
<p>Suppose we have two arrays:</p>
<pre><code class="language-c#">private readonly string[] sites = { &quot;Google&quot;, &quot;Github&quot;, &quot;Telegram&quot;, &quot;Wikipedia&quot; };
private readonly string[] siteDescriptions =
{
    &quot;Google is a search engine&quot;,
    &quot;Github is a git repository hosting&quot;,
    &quot;Telegram is a messenger&quot;,
    &quot;Wikipedia is an open wiki&quot;
};
</code></pre>
<p>So we can handle inline queries this way:</p>
<pre><code class="language-c#">async Task OnInlineQueryReceived(ITelegramBotClient bot, InlineQuery inlineQuery)
{
    var results = new List&lt;InlineQueryResult&gt;();

    var counter = 0;
    foreach (var site in sites)
    {
        results.Add(new InlineQueryResultArticle(
            $&quot;{counter}&quot;, // we use the counter as an id for inline query results
            site, // inline query result title
            new InputTextMessageContent(siteDescriptions[counter])) // content that is submitted when the inline query result title is clicked
        );
        counter++;
    }

    await bot.AnswerInlineQueryAsync(inlineQuery.Id, results); // answer by sending the inline query result list
}
</code></pre>
<p><code>InlineQueryResult</code> is an abstract type used to create a response for inline queries. You can use these result types for inline queries: <code>InlineQueryResultArticle</code> for articles, <code>InlineQueryResultPhoto</code> for photos, etc.</p>
<h2 id="choseninlineresult"><a class="header" href="#choseninlineresult"><code>ChosenInlineResult</code></a></h2>
<p><a href="https://core.telegram.org/bots/api#choseninlineresult"><img src="https://img.shields.io/badge/Bot_API_Object-ChosenInlineResult-blue.svg?style=flat-square" alt="chosen inline result bot API" /></a></p>
<p>This type helps to handle chosen inline result. For example, you may want to know which result users chose:</p>
<pre><code class="language-csharp">Task OnChosenInlineResultReceived(ITelegramBotClient bot, ChosenInlineResult chosenInlineResult)
{
    if (uint.TryParse(chosenInlineResult.ResultId, out var resultId) // check if a result id is parsable and introduce variable
        &amp;&amp; resultId &lt; sites.Length)
    {
        Console.WriteLine($&quot;User {chosenInlineResult.From} has selected site: {sites[resultId]}&quot;);
    }

    return Task.CompletedTask;
}
</code></pre>
<p>To use the feature you need to enable &quot;inline feedback&quot; in BotFather by <code>/setinlinefeedback</code> command:</p>
<p><img src="3/docs/shot-setinlinefeedback_command.png" alt="set inline feedback command" /></p>
<p>Final result:</p>
<p><img src="3/docs/shot-inline_bot_showcase.png" alt="result" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-files"><a class="header" href="#working-with-files">Working with Files</a></h1>
<ul>
<li><a href="3/files/download.html">Download files</a></li>
<li><a href="3/files/upload.html">Upload files</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downloading-files"><a class="header" href="#downloading-files">Downloading files</a></h1>
<p>First, read the <a href="https://core.telegram.org/bots/api#getfile">documentation on <code>getFile</code></a> method.</p>
<p>To download file you have to know its file identifier - <code>FileId</code>.</p>
<h2 id="finding-the-file-identifier"><a class="header" href="#finding-the-file-identifier">Finding the file identifier</a></h2>
<p>Telegram Bot API has several object types, representing file:
<a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a>, <a href="https://core.telegram.org/bots/api#animation"><code>Animation</code></a>, <a href="https://core.telegram.org/bots/api#audio"><code>Audio</code></a>, <a href="https://core.telegram.org/bots/api#document"><code>Document</code></a>, <a href="https://core.telegram.org/bots/api#video"><code>Video</code></a>, <a href="https://core.telegram.org/bots/api#videonote"><code>VideoNote</code></a>, <a href="https://core.telegram.org/bots/api#voice"><code>Voice</code></a>, <a href="https://core.telegram.org/bots/api#sticker"><code>Sticker</code></a>.</p>
<p>The file identifier for each file type can be found in their <code>FileId</code> property (e.g. <code>Message.Audio.FileId</code>).</p>
<p>The exception is photos, which represented as an array of <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize[]</code></a> objects.
For each photo Telegram sends you a set of <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> objects - available resolutions, you can choose from.
Generally, you will want the highest quality - the last <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> object in the array.
With LINQ, this boils down to <code>Message.Photo.Last().FileId</code>.</p>
<h2 id="downloading-a-file"><a class="header" href="#downloading-a-file">Downloading a file</a></h2>
<p>Downloading a file from Telegram is done in two steps:</p>
<ol>
<li>Get file information with <code>getFile</code> method. Resulting <a href="https://core.telegram.org/bots/api#file"><code>File</code></a> object contains <code>FilePath</code> from which we can download the file.</li>
<li>Downloading the file.</li>
</ol>
<pre><code class="language-C#">var fileId = update.Message.Photo.Last().FileId;
var fileInfo = await bot.GetFileAsync(fileId);
var filePath = fileInfo.FilePath;
</code></pre>
<p>The URL from which you can now download the file is <code>https://api.telegram.org/file/bot&lt;token&gt;/&lt;FilePath&gt;</code>.</p>
<p>To download file you can use <code>DownloadFileAsync</code> function:</p>
<pre><code class="language-C#">const string destinationFilePath = &quot;../downloaded.file&quot;;

await using Stream fileStream = System.IO.File.Create(destinationFilePath);
await bot.DownloadFileAsync(filePath, fileStream);
</code></pre>
<p>For your convenience the library provides you a helper function that does both - <code>GetInfoAndDownloadFileAsync</code>:</p>
<pre><code class="language-C#">const string destinationFilePath = &quot;../downloaded.file&quot;;

await using Stream fileStream = System.IO.File.Create(destinationFilePath);
var file = await bot.GetInfoAndDownloadFileAsync(fileId, fileStream);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uploading-files"><a class="header" href="#uploading-files">Uploading files</a></h1>
<p>First, read the <a href="https://core.telegram.org/bots/api#sending-files">documentation on sending files</a>.</p>
<h2 id="upload-local-file"><a class="header" href="#upload-local-file">Upload local file</a></h2>
<p>To upload local file open stream and call one of the file-sending functions:</p>
<pre><code class="language-C#">await using Stream stream = System.IO.File.OpenRead(&quot;../hamlet.pdf&quot;);
var message = await bot.SendDocumentAsync(chatId, document: InputFile.FromStream(stream, &quot;hamlet.pdf&quot;),
    caption: &quot;The Tragedy of Hamlet,\nPrince of Denmark&quot;);
</code></pre>
<p>Be aware of limitation for this method - 10 MB max size for photos, 50 MB for other files.</p>
<h2 id="upload-file-by-file-identifier"><a class="header" href="#upload-file-by-file-identifier">Upload file by file identifier</a></h2>
<p>If the file is already stored somewhere on the Telegram servers, you don't need to reupload it: each file object has a <code>FileId</code> property. Simply pass this <code>FileId</code> as a parameter instead of uploading. There are no limits for files sent this way.</p>
<pre><code class="language-C#">var fileId = update.Message.Photo.Last().FileId;
var message = await bot.SendPhotoAsync(chatId, fileId);
</code></pre>
<h2 id="upload-by-url"><a class="header" href="#upload-by-url">Upload by URL</a></h2>
<p>Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.</p>
<pre><code class="language-csharp">var message = await bot.SendPhotoAsync(chatId, &quot;https://cdn.pixabay.com/photo/2017/04/11/21/34/giraffe-2222908_640.jpg&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stickers"><a class="header" href="#stickers">Stickers</a></h1>
<h2 id="sticker-1"><a class="header" href="#sticker-1">Sticker</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendsticker"><img src="https://img.shields.io/badge/Bot_API_method-sendSticker-blue.svg?style=flat-square" alt="send sticker method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Stickers/StickersTests.cs"><img src="https://img.shields.io/badge/Examples-Sticker_Messages-green.svg?style=flat-square" alt="sticker tests" /></a></p>
<p>Telegram stickers are fun and our bot is about to send its very first sticker.
Sticker files should be in <a href="https://developers.google.com/speed/webp/">WebP</a> format.</p>
<p>This code sends the same sticker twice. First by passing HTTP URL to a <a href="https://developers.google.com/speed/webp/">WebP</a> sticker file and
second by reusing <code>FileId</code> of the same sticker on Telegram servers.</p>
<pre><code class="language-c#">var message1 = await bot.SendStickerAsync(chatId, &quot;https://telegrambots.github.io/book/docs/sticker-fred.webp&quot;);

var message2 = await bot.SendStickerAsync(chatId, message1.Sticker!.FileId);
</code></pre>
<p><img src="3/docs/shot-sticker_msgs.jpg" alt="sticker messages" /></p>
<p>Try inspecting the <code>sticker1.Sticker</code> property. It is of type [<code>Sticker</code>] and its schema looks similar to a photo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<ul>
<li><a href="4/login-widget.html">Login Widget</a></li>
<li><a href="4/passport/">Passport</a>
<ul>
<li><a href="4/passport/quickstart.html">Quickstart</a></li>
<li><a href="4/passport/files-docs.html">Files &amp; Documents</a></li>
<li><a href="4/passport/errors.html">Data Errors</a></li>
<li><a href="4/passport/key.html">RSA Key</a></li>
<li><a href="4/passport/faq.html">Decryption FAQ</a></li>
</ul>
</li>
<li><a href="4/proxy.html">Proxy</a></li>
<li><a href="4/logging.html">Logging</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-behind-a-proxy"><a class="header" href="#working-behind-a-proxy">Working Behind a Proxy</a></h1>
<p><code>TelegramBotClient</code> allows you to use a proxy for Bot API connections. This guide covers using three different proxy solutions.</p>
<ul>
<li><a href="4/proxy.html#http-proxy">HTTP Proxy</a></li>
<li><a href="4/proxy.html#socks5-proxy">SOCKS5 Proxy</a></li>
<li><a href="4/proxy.html#socks5-proxy-over-tor">SOCKS5 Proxy over Tor (Testing Only)</a></li>
</ul>
<p><img src="4/docs/tg-network.gif" alt="Telegram Network" /></p>
<blockquote>
<p>If you are in a country, such as Iran, where HTTP and SOCKS proxy connections to Telegram servers are blocked, consider using a VPN, using Tor Network, or hosting your bot in other jurisdictions.</p>
</blockquote>
<h2 id="http-proxy"><a class="header" href="#http-proxy">HTTP Proxy</a></h2>
<p>You can configure <code>HttpClient</code> with <code>WebProxy</code> and pass it to the Bot client.</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy webProxy = new (Host: &quot;https://example.org&quot;, Port: 8080)
{
    // Credentials if needed:
    Credentials = new NetworkCredential(&quot;USERNAME&quot;, &quot;PASSWORD&quot;)
};
HttpClient httpClient = new (
    new HttpClientHandler { Proxy = webProxy, UseProxy = true, }
);

var bot = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<h2 id="socks5-proxy"><a class="header" href="#socks5-proxy">SOCKS5 Proxy</a></h2>
<p>As of .NET 6, <code>SocketsHttpHandler</code> <a href="https://devblogs.microsoft.com/dotnet/dotnet-6-networking-improvements/#socks-proxy-support">is able to use Socks4, Socks4a and Socks5 proxies</a>!</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy proxy = new (&quot;socks5://127.0.0.1:9050&quot;)
{
    Credentials = new NetworkCredential(&quot;USERNAME&quot;, &quot;PASSWORD&quot;)
};
HttpClient httpClient = new (
    new SocketsHttpHandler { Proxy = proxy, UseProxy = true, }
);

var bot = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<h2 id="socks5-proxy-over-tor"><a class="header" href="#socks5-proxy-over-tor">SOCKS5 Proxy over Tor</a></h2>
<p><strong>Warning: Use for Testing only!</strong></p>
<blockquote>
<p>Do not use this method in a production environment as it has high network latency and poor bandwidth.</p>
</blockquote>
<p>Using Tor, a developer can avoid network restrictions while debugging and testing the code
before a production release.</p>
<ol>
<li>
<p>Install <a href="https://www.torproject.org/">Tor Browser</a></p>
</li>
<li>
<p>Open the <code>torcc</code> file with a text editor (Found in <code>Tor Browser\Browser\TorBrowser\Data\Tor</code>)</p>
</li>
<li>
<p>Add the following lines: (configurations are described below)</p>
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
SocksPort 127.0.0.1:9050
</code></pre>
</li>
<li>
<p>Look at the <a href="4/proxy.html#socks5-proxy">Socks5 proxy</a> example above.</p>
</li>
<li>
<p>Start the Tor Browser</p>
</li>
</ol>
<p>Usage:</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy proxy = new (&quot;socks5://127.0.0.1:9050&quot;);

HttpClient httpClient = new (
    new SocketsHttpHandler { Proxy = proxy, UseProxy = true }
);

var bot = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<blockquote>
<p>Note that Tor has to be active at all times for the bot to work.</p>
</blockquote>
<h3 id="configurations-in-torcc"><a class="header" href="#configurations-in-torcc">Configurations in <code>torcc</code></a></h3>
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
</code></pre>
<p>These three lines make sure you use nodes from the Netherlands as much as possible to reduce latency.</p>
<p><code>SocksPort 127.0.0.1:9050</code></p>
<p>This line tells tor to listen on port 9050 for any socks connections.
You can change the port to anything you want (9050 is just the default), only make sure to use the same port in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport"><a class="header" href="#telegram-passport">Telegram Passport</a></h1>
<p><a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/v/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget package" /></a>
<a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/dt/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget downloads" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/github/stars/TelegramBots/Telegram.Bot.Extensions.Passport.svg?style=social&amp;label=Stars" alt="repository" /></a></p>
<ul>
<li><a href="4/passport/quickstart.html">Quickstart</a></li>
<li><a href="4/passport/files-docs.html">Files &amp; Documents</a></li>
<li><a href="4/passport/errors.html">Data Errors</a></li>
<li><a href="4/passport/key.html">RSA Key</a></li>
<li><a href="4/passport/faq.html">Decryption FAQ</a></li>
</ul>
<p><img src="4/passport/../docs/photo-tg_passport.gif" alt="telegram passport" /></p>
<p><a href="https://telegram.org/blog/passport">Telegram Passport</a> is a unified authorization method for services that require personal identification.
As a bot developer, you can use it to receive confidential user data in an end-to-end encrypted fashion.
There are several Know Your Customer(KYC) solutions that have already added support for Telegram Passport.</p>
<p>This guide is targeted at bot developers and assumes the audience is already familiar with:</p>
<ul>
<li><a href="https://telegram.org/blog/passport">Telegram Passport</a></li>
<li><a href="https://core.telegram.org/passport/example">Telegram Passport Example</a></li>
<li><a href="https://core.telegram.org/passport">Telegram Passport Manual</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport---quickstart"><a class="header" href="#telegram-passport---quickstart">Telegram Passport - Quickstart</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs"><img src="https://img.shields.io/badge/Examples-Passport_Quickstart-green.svg?style=flat-square" alt="passport quickstart example" /></a></p>
<p>This guide teaches the basics of working with Telegram Passport.
See the complete version of the code at <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/tree/master/src/Quickstart">Quickstart project</a>.
Code snippets on this page are in the context of that project.</p>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<p><a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/v/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget package" /></a></p>
<p>You need to add <code>Telegram.Bot.Extensions.Passport</code> extension package to your project
in addition to the core package (<code>Telegram.Bot</code>).</p>
<p>‚≠êÔ∏è Star the <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport">Telegram.Bot.Extensions.Passport project</a> on GitHub üëç</p>
<pre><code class="language-bash">dotnet add package Telegram.Bot.Extensions.Passport
</code></pre>
<h2 id="encryption-keys"><a class="header" href="#encryption-keys">Encryption Keys</a></h2>
<p>You don't really need to generate any RSA key. Use our sample keys for this demo.
Send the public key to <a href="https://t.me/BotFather">@BotFather</a> using <code>/setpublickey</code> command:</p>
<p><img src="4/passport/../docs/shot-passport_botfather.jpg" alt="Setting public key" /></p>
<p>Copy this public key and send it to BotFather.</p>
<pre><code class="language-text">-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0VElWoQA2SK1csG2/sY/
wlssO1bjXRx+t+JlIgS6jLPCefyCAcZBv7ElcSPJQIPEXNwN2XdnTc2wEIjZ8bTg
BlBqXppj471bJeX8Mi2uAxAqOUDuvGuqth+mq7DMqol3MNH5P9FO6li7nZxI1FX3
9u2r/4H4PXRiWx13gsVQRL6Clq2jcXFHc9CvNaCQEJX95jgQFAybal216EwlnnVV
giT/TNsfFjW41XJZsHUny9k+dAfyPzqAk54cgrvjgAHJayDWjapq90Fm/+e/DVQ6
BHGkV0POQMkkBrvvhAIQu222j+03frm9b2yZrhX/qS01lyjW4VaQytGV0wlewV6B
FwIDAQAB
-----END PUBLIC KEY-----
</code></pre>
<p>Now Telegram client app can encrypt the data for your bot using this key.</p>
<h2 id="request-information-1"><a class="header" href="#request-information-1">Request Information</a></h2>
<p>Bot waits for a text message from user. Once it receives a text message, it generates an authorization request link
and sends that to the user.</p>
<h3 id="authorization-request"><a class="header" href="#authorization-request">Authorization Request</a></h3>
<p><a href="https://core.telegram.org/passport#request-parameters"><img src="https://img.shields.io/badge/Passport_API_type-Request_Parameters-blue.svg?style=flat-square" alt="Request Parameters type" /></a></p>
<p>A passport authorization request means that the bot should ask the user to open a <code>tg://resolve</code> URI in the browser
with specific parameters in its query string.
You can alternatively have a button in an HTML page on your website for that.</p>
<p>Type <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Request/AuthorizationRequestParameters.cs">AuthorizationRequestParameters</a>  helps you in creating such an URI.</p>
<pre><code class="language-c#">AuthorizationRequestParameters authReq = new AuthorizationRequestParameters(
    botId: 123456, // bot user ID
    publicKey: &quot;...&quot;, // public key in PEM format. same as the key above.
    nonce: &quot;unique nonce for this request&quot;,
    scope: new PassportScope(new[] { // a PassportScope object
        new PassportScopeElementOne(&quot;address&quot;),
        new PassportScopeElementOne(&quot;phone_number&quot;)
    })
);
</code></pre>
<p>In <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs">SendAuthorizationRequestAsync</a> method, we ask for <code>address</code> and <code>phone_number</code> scopes.
Then, we generate the query string and ask user to open the link.</p>
<p>You might be wondering what is the magic in here?</p>
<p><a href="https://telegrambots.github.io/Telegram.Bot.Extensions.Passport/redirect.html">https://telegrambots.github.io/Telegram.Bot.Extensions.Passport/redirect.html</a></p>
<p>This web page redirects user to <code>tg://resolve</code> URI, appending whatever query string was passed to it.</p>
<blockquote>
<p>If a user is using an Android device, the URI will start with <code>tg:</code> instead of the default <code>tg://</code>.</p>
</blockquote>
<p><img src="4/passport/../docs/shot-passport_link1.jpg" alt="Passport link 1" />
<img src="4/passport/../docs/shot-passport_link2.jpg" alt="Passport link 2" /></p>
<h3 id="passport-data"><a class="header" href="#passport-data">Passport Data</a></h3>
<p>You, the user, should now be redirected to the Telegram Passport screen in your Telegram client app.
Enter your password and log in.</p>
<blockquote>
<p>Note that the app will ask you to register if this is the first time you are using Telegram Passport.</p>
</blockquote>
<p><img src="4/passport/../docs/shot-passport_login.jpg" alt="Passport login" /></p>
<p>Fill in the <em>address</em> and <em>phone number</em> data. Click on the <em>Authorize</em> button at the end.</p>
<p><img src="4/passport/../docs/shot-passport_adress_phone1.jpg" alt="Passport info 1" />
<img src="4/passport/../docs/shot-passport_adress.jpg" alt="address info" />
<img src="4/passport/../docs/shot-passport_phone.jpg" alt="phone info" />
<img src="4/passport/../docs/shot-passport_adress_phone2.jpg" alt="Passport info 2" /></p>
<p>At this point, your Telegram client app encrypts the actual Telegram Passport data (e.g. address) using the
AES algorithm, and then encrypts the info required for decryption using your bot's public RSA key.
Finally, it sends the result of both encryptions to Telegram servers.</p>
<h3 id="data-decryption"><a class="header" href="#data-decryption">Data Decryption</a></h3>
<p><a href="https://core.telegram.org/bots/api#passportdata"><img src="https://img.shields.io/badge/Bot_API_type-Passport_Data-blue.svg?style=flat-square" alt="Passport Data type" /></a></p>
<p>Your bot now receives a new message update with the encrypted Passport data. The user is also notified in the chat:</p>
<p><img src="4/passport/../docs/shot-passport_update.jpg" alt="Passport update" /></p>
<p>Let's decrypt that gibberish to get the information. That's what <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs">DecryptPassportDataAsync</a> method does.</p>
<h4 id="step-1-credentials"><a class="header" href="#step-1-credentials">Step 1: Credentials</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedcredentials"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedCredentials-blue.svg?style=flat-square" alt="EncryptedCredentials type" /></a>
<a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a></p>
<p>You can't just access the encrypted data in the <code>message.passport_data.data</code> array.
Required parameters for their decryption are in the <code>message.passport_data.credentials</code> object.
But that credentials object is encrypted using bot's public key!</p>
<p>We first take the bot's <em>private key</em> this time and decrypt the credentials.</p>
<blockquote>
<p>There are more details about importing a key in PEM format on the <a href="4/passport/key.html">RSA Key page</a>.</p>
</blockquote>
<pre><code class="language-c#">IDecrypter decrypter = new Decrypter();
Credentials credentials = decrypter.DecryptCredentials(
    message.PassportData.Credentials, // EncryptedCredentials object
    GetRsaPrivateKey() // private key as an RSA object
);
</code></pre>
<h4 id="step-2-nonce"><a class="header" href="#step-2-nonce">Step 2: Nonce</a></h4>
<p><a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a>
<a href="https://core.telegram.org/passport#request-parameters"><img src="https://img.shields.io/badge/Passport_API_type-Request_Parameters-blue.svg?style=flat-square" alt="Request Parameters type" /></a></p>
<p>There is a <code>nonce</code> property on the credentials (now decrypted) object.
In order to prevent certain attacks, ensure its value is exactly the same as the nonce you set in the authorization request.
Read more about <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce on Wikipedia</a>.</p>
<h4 id="step-3-residential-address"><a class="header" href="#step-3-residential-address">Step 3: Residential Address</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedpassportelement"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedPassportElement-blue.svg?style=flat-square" alt="EncryptedPassportElement type" /></a>
<a href="https://core.telegram.org/passport#residentialaddress"><img src="https://img.shields.io/badge/Passport_API_type-ResidentialAddress-blue.svg?style=flat-square" alt="ResidentialAddress type" /></a></p>
<p><a href="https://core.telegram.org/passport#securedata"><img src="https://img.shields.io/badge/Passport_API_type-SecureData-blue.svg?style=flat-square" alt="SecureData type" /></a>
<a href="https://core.telegram.org/passport#securevalue"><img src="https://img.shields.io/badge/Passport_API_type-SecureValue-blue.svg?style=flat-square" alt="SecureValue type" /></a>
<a href="https://core.telegram.org/passport#datacredentials"><img src="https://img.shields.io/badge/Passport_API_type-DataCredentials-blue.svg?style=flat-square" alt="DataCredentials type" /></a></p>
<p>It's finally time to see the user's address.
We are looking for an encrypted element with type of <em>address</em> in <code>message.passport_data.data</code> array.
Also, decryption parameters for that are in <code>credentials.secure_data.address.data</code>.
Here is how the decryption magic happens:</p>
<pre><code class="language-c#">EncryptedPassportElement addressElement = message.PassportData.Data.Single(
    el =&gt; el.Type == PassportEnums.Scope.Address
);
ResidentialAddress address = decrypter.DecryptData&lt;ResidentialAddress&gt;(
    encryptedData: addressElement.Data,
    dataCredentials: credentials.SecureData.Address.Data
);
</code></pre>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">DecryptData</a> method does 3 tasks here:</p>
<ol>
<li>Decrypts the data into a JSON-serialized string</li>
<li>Verifies that the data hashes match</li>
<li>Converts from JSON to a .NET object</li>
</ol>
<h4 id="step-4-phone-number"><a class="header" href="#step-4-phone-number">Step 4: Phone Number</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedpassportelement"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedPassportElement-blue.svg?style=flat-square" alt="EncryptedPassportElement type" /></a></p>
<p>Values for phone number and email address are not end-to-end encrypted in Telegram Passport and
Telegram stores these values after being verified.</p>
<p>There is no need for decryption at this point.
Just find the element with the type of <em>phone_number</em> in the <code>message.passport_data.data</code> array.</p>
<h3 id="information-demo"><a class="header" href="#information-demo">Information Demo</a></h3>
<p>At the end, bot sends some of the information received to the user for demo purposes.</p>
<p><img src="4/passport/../docs/shot-passport_quickstart.jpg" alt="info demo" /></p>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="passport-files-and-documents"><a class="header" href="#passport-files-and-documents">Passport Files and Documents</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Examples-Driver_License_Scope-green.svg?style=flat-square" alt="driver's license scope tests" /></a></p>
<p>We use the driver's license scope here to show decryption of <em>ID document data</em> and <em>passport files</em> for
front side scan, reverse side scan, selfie photo, and translation scan.
That should cover most of the <a href="https://core.telegram.org/passport#fields">field types in Telegram Passport</a>.</p>
<p>Sections below are referring to the test methods in <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs">Driver's License Scope Tests</a> collection.
Here are the steps:</p>
<ol>
<li><a href="4/passport/files-docs.html#authorization-request">Authorization Request</a></li>
<li><a href="4/passport/files-docs.html#drivers-license-info">Driver's License Info</a></li>
<li><a href="4/passport/files-docs.html#passport-message">Passport Message</a></li>
<li><a href="4/passport/files-docs.html#credentials">Credentials</a></li>
<li><a href="4/passport/files-docs.html#id-document-data">ID Document Data</a></li>
<li><a href="4/passport/files-docs.html#passport-file">Passport File</a>
<ul>
<li><a href="4/passport/files-docs.html#front-side-file">Front Side File</a></li>
<li><a href="4/passport/files-docs.html#reverse-side-file">Reverse Side File</a></li>
<li><a href="4/passport/files-docs.html#selfie-file">Selfie File</a></li>
<li><a href="4/passport/files-docs.html#translation-file">Translation File</a></li>
</ul>
</li>
</ol>
<h2 id="authorization-request-1"><a class="header" href="#authorization-request-1">Authorization Request</a></h2>
<p><a href="https://core.telegram.org/passport#passportscope"><img src="https://img.shields.io/badge/Passport_API_type-PassportScope-blue.svg?style=flat-square" alt="PassportScope type" /></a>
<a href="https://core.telegram.org/passport#passportscopeelementone"><img src="https://img.shields.io/badge/Passport_API_type-PassportScopeElementOne-blue.svg?style=flat-square" alt="PassportScopeElementOne type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Generate_Auth_Link-green.svg?style=flat-square" alt="method Should_Generate_Auth_Link" /></a></p>
<p>We start by generating an authorization URI.
Since a driver's license is considered as a proof of identity, we ask for optional data <em>selfie with document</em> and
<em>translation document scan</em> as well.</p>
<p><img src="4/passport/../docs/shot-passport_driver_license_link.jpg" alt="driver's license passport link" /></p>
<h2 id="drivers-license-info"><a class="header" href="#drivers-license-info">Driver's License Info</a></h2>
<p>As a user, provide information for the required fields: front side, reverse side, and document number.
Also, test methods here expect a selfie photo and a file for translation scan.</p>
<p><img src="4/passport/../docs/shot-passport_driver_license1.jpg" alt="driver's license passport 1" />
<img src="4/passport/../docs/shot-passport_driver_license2.jpg" alt="driver's license passport 2" />
<img src="4/passport/../docs/shot-passport_driver_license3.jpg" alt="driver's license passport 3" /></p>
<p>Click the <em>Authorize</em> button at the end.</p>
<h2 id="passport-message"><a class="header" href="#passport-message">Passport Message</a></h2>
<p><a href="https://core.telegram.org/bots/api#passportdata"><img src="https://img.shields.io/badge/Bot_API_type-Passport_Data-blue.svg?style=flat-square" alt="Passport Data type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Validate_Passport_Update-green.svg?style=flat-square" alt="method Should_validate_passport_update" /></a></p>
<p>This test method checks for a Passport message with a driver's license element on it.</p>
<h2 id="credentials"><a class="header" href="#credentials">Credentials</a></h2>
<p><a href="https://core.telegram.org/bots/api#encryptedcredentials"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedCredentials-blue.svg?style=flat-square" alt="EncryptedCredentials type" /></a>
<a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Decrypt_Credentials-green.svg?style=flat-square" alt="method Should_decrypt_credentials" /></a></p>
<p>We decrypt credentials using the RSA private key and verify that the same nonce is used.</p>
<pre><code class="language-c#">RSA key = EncryptionKey.ReadAsRsa();
IDecrypter decrypter = new Decrypter();
Credentials credentials = decrypter.DecryptCredentials(
    passportData.Credentials,
    key
);
bool isSameNonce = credentials.Nonce == &quot;Test nonce for driver's license&quot;;
</code></pre>
<h2 id="id-document-data"><a class="header" href="#id-document-data">ID Document Data</a></h2>
<p><a href="https://core.telegram.org/passport#iddocumentdata"><img src="https://img.shields.io/badge/Passport_API_type-IdDocumentData-blue.svg?style=flat-square" alt="IdDocumentData type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Document_Data-green.svg?style=flat-square" alt="method Should_decrypt_document_data" /></a></p>
<p>In our test case, there is only 1 item in the <code>message.passport_data.data</code> array and that's the encrypted element for
the driver's license scope.
We can get information such as document number and expiry date for the license from that element:</p>
<pre><code class="language-c#">IdDocumentData licenseDoc = decrypter.DecryptData&lt;IdDocumentData&gt;(
    encryptedData: element.Data,
    dataCredentials: credentials.SecureData.DriverLicense.Data
);
</code></pre>
<h2 id="passport-file"><a class="header" href="#passport-file">Passport File</a></h2>
<p><a href="https://core.telegram.org/bots/api#passportfile"><img src="https://img.shields.io/badge/Bot_API_type-PassportFile-blue.svg?style=flat-square" alt="PassportFile type" /></a>
<a href="https://core.telegram.org/passport#filecredentials"><img src="https://img.shields.io/badge/Passport_API_type-FileCredentials-blue.svg?style=flat-square" alt="FileCredentials type" /></a></p>
<p>Passport file is an encrypted JPEG file on Telegram servers.
You need to download the passport file and decrypt it using its accompanying <em>file credentials</em> to see
the actual JPEG file content.
In this section we try to demonstrate different use cases that you might have for such files.</p>
<p>No matter the method used, the underlying decryption logic is the same.
It really comes down to your decision on working with <em>streams</em> vs. <em>byte arrays</em>.
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">IDecrypter</a> gives you both options.</p>
<h3 id="front-side-file"><a class="header" href="#front-side-file">Front Side File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Front_Side_File-green.svg?style=flat-square" alt="method Should_decrypt_front_side_file" /></a></p>
<p>A pretty handy extension method is used here to stream writing the front side file to disk.
Method <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/TelegramBotClientPassportExtensions.cs">DownloadAndDecryptPassportFileAsync</a> does a few things:</p>
<ol>
<li>Makes an HTTP request to fetch the encrypted file's info using its <em>passport file_id</em></li>
<li>Makes an HTTP request to download the encrypted file using its <em>file_path</em></li>
<li>Decrypts the encrypted file</li>
<li>Writes the actual content to the destination stream</li>
</ol>
<pre><code class="language-c#">File encryptedFileInfo;
using (System.IO.Stream stream = System.IO.File.OpenWrite(&quot;/path/to/front-side.jpg&quot;))
{
    encryptedFileInfo = await bot.DownloadAndDecryptPassportFileAsync(
        element.FrontSide, // PassportFile object for front side
        credentials.SecureData.DriverLicense.FrontSide, // front side FileCredentials
        stream // destination stream for writing the JPEG content to
    );
}
</code></pre>
<blockquote>
<p><strong>Warning</strong>: This method is convenient to use but gives you the least amount of control over the operations.</p>
</blockquote>
<h3 id="reverse-side-file"><a class="header" href="#reverse-side-file">Reverse Side File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Reverse_Side_File-green.svg?style=flat-square" alt="method Should_decrypt_reverse_side_file" /></a></p>
<p>Previous method call is divided into two operations here for reverse side of the license.
Streams are used here as well.</p>
<pre><code class="language-c#">File encryptedFileInfo;
using (System.IO.Stream
    encryptedContent = new System.IO.MemoryStream(element.ReverseSide.FileSize),
    decryptedFile = System.IO.File.OpenWrite(&quot;/path/to/reverse-side.jpg&quot;)
) {
    // fetch the encrypted file info and download it to memory
    encryptedFileInfo = await bot.GetInfoAndDownloadFileAsync(
        element.ReverseSide.FileId, // file_id of passport file for reverse side
        encryptedContent // stream to copy the encrypted file into
    );
    // ensure memory stream is at the beginning before reading from it
    encryptedContent.Position = 0;

    // decrypt the file and write it to disk
    await decrypter.DecryptFileAsync(
        encryptedContent,
        credentials.SecureData.DriverLicense.ReverseSide, // reverse side FileCredentials
        decryptedFile // destination stream for writing the JPEG content to
    );
}
</code></pre>
<h3 id="selfie-file"><a class="header" href="#selfie-file">Selfie File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Selfie_File-green.svg?style=flat-square" alt="method Should_decrypt_selfie_file" /></a></p>
<p>We deal with selfie photo as a byte array.
This is essentially the same operation as done above via streams.
We also post the selfie photo to a chat.</p>
<pre><code class="language-c#">// fetch the info of the passport file(selfie) residing on Telegram servers
File encryptedFileInfo = await bot.GetFileAsync(element.Selfie.FileId);

// download the encrypted file and get its bytes
byte[] encryptedContent;
using (System.IO.MemoryStream
    stream = new System.IO.MemoryStream(encryptedFileInfo.FileSize)
)
{
    await bot.DownloadFileAsync(encryptedFileInfo.FilePath, stream);
    encryptedContent = stream.ToArray();
}

// decrypt the content and get bytes of the actual selfie photo
byte[] selfieContent = decrypter.DecryptFile(
    encryptedContent,
    credentials.SecureData.DriverLicense.Selfie
);

// send the photo to a chat
using (System.IO.Stream stream = new System.IO.MemoryStream(selfieContent)) {
    await bot.SendPhotoAsync(
        123456,
        stream,
        &quot;selfie with driver's license&quot;
    );
}
</code></pre>
<h3 id="translation-file"><a class="header" href="#translation-file">Translation File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Translation_File-green.svg?style=flat-square" alt="method Should_decrypt_translation_file" /></a></p>
<p>A bot can request certified English translations of a document.
Translations are also encrypted passport files so their decryption is no different from others passport files.</p>
<p>Assuming that the user sends one translation scan only for the license, we receive the translation passport file object in
<code>message.passport_data.data[0].translation[0]</code> and its accompanying file credentials object in
<code>credentials.secure_data.driver_license.translation[0]</code>.</p>
<p>File gets written to disk as a byte array.</p>
<pre><code class="language-c#">PassportFile passportFile = element.Translation[0];
FileCredentials fileCreds = credentials.SecureData.DriverLicense.Translation[0];

// fetch passport file info
File encryptedFileInfo = await bot.GetFileAsync(passportFile.FileId);

// download encrypted file and get its bytes
byte[] encryptedContent;
using (System.IO.MemoryStream
    stream = new System.IO.MemoryStream(encryptedFileInfo.FileSize)
)
{
    await bot.DownloadFileAsync(encryptedFileInfo.FilePath, stream);
    encryptedContent = stream.ToArray();
}

// decrypt the content and get bytes of the actual selfie photo
byte[] content = decrypter.DecryptFile(
    encryptedContent,
    fileCreds
);

// write the file to disk
await System.IO.File.WriteAllBytesAsync(&quot;/path/to/translation.jpg&quot;, content);
</code></pre>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="passport-data-errors"><a class="header" href="#passport-data-errors">Passport Data Errors</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-rsa-key"><a class="header" href="#import-rsa-key">Import RSA Key</a></h1>
<p>In order to decrypt the credentials you need to provide the private RSA key to <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">DecryptCredentials</a> method.
If you have the RSA key in <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM format</a>, you cannot simply instantiate an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa?redirectedfrom=MSDN&amp;view=netstandard-2.0">RSA .NET object</a> from it.
Here we discuss two ways of importing your PEM private key.</p>
<h2 id="from-pem-format"><a class="header" href="#from-pem-format">From PEM Format</a></h2>
<p>This is the easier option and recommended <strong>for development time only</strong>.
We can generate an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa?redirectedfrom=MSDN&amp;view=netstandard-2.0">RSA .NET object</a> from an RSA Key in PEM format using the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a>.</p>
<pre><code class="language-bash">dotnet add package BouncyCastle
</code></pre>
<p><a href="http://www.bouncycastle.org/csharp/index.html"><img src="4/passport/../docs/photo-bouncy_castle.gif" alt="bouncy castle c# logo" /></a></p>
<p>Code snippet here shows the conversion from a PEM file to the needed RSA object.</p>
<pre><code class="language-c#">// using System.IO;
// using System.Security.Cryptography;
// using Org.BouncyCastle.Crypto;
// using Org.BouncyCastle.Crypto.Parameters;
// using Org.BouncyCastle.OpenSsl;
// using Org.BouncyCastle.Security;

static RSA GetPrivateKey() {
    string privateKeyPem = File.ReadAllText(&quot;/path/to/private-key.pem&quot;);
    PemReader pemReader = new PemReader(new StringReader(privateKeyPem));
    AsymmetricCipherKeyPair keyPair = (AsymmetricCipherKeyPair) pemReader.ReadObject();
    RSAParameters rsaParameters = DotNetUtilities
        .ToRSAParameters(keyPair.Private as RsaPrivateCrtKeyParameters);
    RSA rsa = RSA.Create(rsaParameters);
    return rsa;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: You don't necessarily need to have a dependency on the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a> in your bot project.
The section below offers a better alternative.</p>
</blockquote>
<h2 id="from-rsa-parameters"><a class="header" href="#from-rsa-parameters">From RSA Parameters</a></h2>
<p>We recommend to JSON-serialize <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> of your key and create an RSA object using its values without any
dependency on the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a> in production deployment.</p>
<p>Copy <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyUtility.cs">EncryptionKeyUtility</a> and <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> files from our Quickstart project.
Those help with serialization.</p>
<p>You still need to <strong>use BouncyCastle only once</strong> to read the RSA key in PEM format and serialize its parameters:</p>
<pre><code class="language-c#">// ONLY ONCE: read the RSA private key and serialize its parameters to JSON
static void WriteRsaParametersToJson() {
    string privateKeyPem = System.IO.File.ReadAllText(&quot;/path/to/private-key.pem&quot;);
    string json = EncryptionKeyUtility.SerializeRsaParameters(privateKeyPem);
    System.IO.File.WriteAllText(&quot;/path/to/private-key-params.json&quot;, json);
}

// Now, read the JSON file and create an RSA instance
static RSA GetRsaKey() {
    string json = System.IO.File.ReadAllText(&quot;/path/to/private-key-params.json&quot;);
    return EncryptionKeyUtility.GetRsaKeyFromJson(json);
}
</code></pre>
<p>Content of <code>private-key-params.json</code> will look similar to this:</p>
<pre><code class="language-json">{
  &quot;E&quot;: &quot;AQAB&quot;,
  &quot;M&quot;: &quot;0VElW...Fw==&quot;,
  &quot;P&quot;: &quot;56Mdiw...i7FSwDaM=&quot;,
  &quot;Q&quot;: &quot;51UN2sd...J44NTf0=&quot;,
  &quot;D&quot;: &quot;nrXEeOl2Ky...JIQ==&quot;,
  &quot;DP&quot;: &quot;KZYZWbsy.../lk60=&quot;,
  &quot;DQ&quot;: &quot;Y25KgzPj...AdBd0=&quot;,
  &quot;IQ&quot;: &quot;0153...N6Y=&quot;
}
</code></pre>
<p>It's worth mentioning that <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> is just a copy of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> struct.
There are inconsistencies in serialization of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> type on different .NET platforms
and that's why we use our own <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> type for serialization.</p>
<blockquote>
<p>For instance, compare <code>RSAParameters</code> implementations on <a href="https://referencesource.microsoft.com/#mscorlib/system/security/cryptography/rsa.cs,21">.NET Framework</a> and <a href="https://github.com/dotnet/corefx/blob/master/src/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RSAParameters.cs">.NET Core</a>.</p>
</blockquote>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport-data-decryption---faq"><a class="header" href="#telegram-passport-data-decryption---faq">Telegram Passport Data Decryption - FAQ</a></h1>
<h2 id="what-is-passportdatadecryptionexception"><a class="header" href="#what-is-passportdatadecryptionexception">What is <code>PassportDataDecryptionException</code></a></h2>
<p>Methods on <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs"><code>IDecrypter</code></a> might throw <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/PassportDataDecryptionException.cs"><code>PassportDataDecryptionException</code></a> exception
if an error happens during decryption.
The exception message tells you what went wrong but there is not much you can do to resolve it.
Maybe let your user know the issue and ask for Passport data again.</p>
<p>It is important to pass each piece of encrypted data, e.g. Id Document, Passport File, etc., with the right
accompanying credentials to decryption methods.</p>
<p>Spot the <em>problem in this code</em> decrypting driver's license files:</p>
<pre><code class="language-c#">byte[] selfieContent = decrypter.DecryptFile(
    encSelfieContent, // byte array of encrypted selfie file
    credentials.SecureData.DriverLicense.FrontSide // WRONG! use selfie file credentials
);
// throws PassportDataDecryptionException: &quot;Data hash mismatch at position 123.&quot;
</code></pre>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-login-widget"><a class="header" href="#telegram-login-widget">Telegram Login Widget</a></h1>
<p>Everything related to the <a href="https://core.telegram.org/widgets/login">Telegram Login Widget</a> has been moved to a separate repository:
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.LoginWidget"><code>Telegram.Bot.Extensions.LoginWidget</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems-integration-tests"><a class="header" href="#systems-integration-tests">Systems Integration Tests</a></h1>
<p>Integration tests are meant to test the project with real data from Telegram. They are semi-automated tests and tester(s) need to interact with bot for some cases during the test execution. Tests could be used as a playground for exploring Bot API methods.</p>
<h2 id="sample-test-diagnostics-output"><a class="header" href="#sample-test-diagnostics-output">Sample Test Diagnostics Output</a></h2>
<p>All the test output goes into the supergroup/private chats specified in configurations or interactively during test execution. You can see some samples of test output below.</p>
<p>Admin bots can change chat photo.</p>
<p><img src="4/docs/testcase-chatphoto.jpg" alt="Test Case: Set Chat Photo" /></p>
<p>Invoices could be paid in private chats.</p>
<p><img src="4/docs/testcase-payment.jpg" alt="Test Case: Set Chat Photo" /></p>
<h2 id="how-tests-works"><a class="header" href="#how-tests-works">How Tests Works</a></h2>
<p>These integration tests are written just like regular unit tests with xUnit framework so they seem to be unit tests. When you run test(s), bot makes a request to Bot API and you should see results(message or service notification) in the chat with bot.</p>
<p>When you build the solution, you will see them in Test Explorer window. Tests could be run through .NET Core's CLI as well and that's how this project's CI is set up.</p>
<p>A bot, of course, is needed to test Bot API. This document refers to its user name as <em>MyTestBot</em>.</p>
<p><em>Tester</em> refers to user name of person testing the bot. Multiple testers could interact with bot during
test execution. If super group chat has other members that are not listed as testers, bot ignores their
messages during test execution. Testers must have user names assigned and their user names should be set
in test configurations before hand.</p>
<p>All the tests happen in two chats. A Super Group chat and a Private chat with one of the testers.</p>
<p>Test cases that need tester's interaction to continue, have a limit of usually 2 minutes to wait for receiving an expected update from API.</p>
<p>Tests could be run individually, in collections, or all at once. All the test collection and test cases within them are ordered and tests will not run in parallel.</p>
<h2 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h2>
<p>Create a Super Group and add bot to it. Promote bot to admin and make sure it has all the permissions. This group needs to have another regular(non-admin) member to be used in tests for chat administration methods(such as Kick, Restrict, Unban). A super group with 2 testers in it, one admin and the other non-admin member, is enough.</p>
<p>Bot should have some features enabled, usually through BotFather, in order to pass tests. These features are listed below:</p>
<ul>
<li>Inline Queries</li>
<li>Payment Provider</li>
</ul>
<p>For making testing process more convenient, set the following commands for MyTestBot as well. The purpose for these commands is explained in the sections below.</p>
<pre><code class="language-text">test - Start test execution
  me - Select me for testing admin methods
</code></pre>
<h2 id="test-configurations"><a class="header" href="#test-configurations">Test Configurations</a></h2>
<p>You can see a list of configuration keys in <code>appsettings.json</code> file. Make a copy of this file and store your configurations there. In addition to <code>appsettings.json</code> and <code>appsettings.Development.json</code>, environment variables prefixed by <code>TelegramBot_</code> are also read into program.</p>
<pre><code class="language-bash">cp appsettings.json appsettings.Development.json
</code></pre>
<h3 id="required-settings"><a class="header" href="#required-settings">Required Settings</a></h3>
<p>Only 2 values must be provided before test execution.</p>
<h4 id="api-token"><a class="header" href="#api-token">API Token</a></h4>
<p>This is required for executing any test case.</p>
<pre><code class="language-json">{
  &quot;ApiToken&quot;: &quot;MyTestBot-API-TOKEN&quot;
  /* ... */
}
</code></pre>
<h4 id="allowed-users"><a class="header" href="#allowed-users">Allowed Users</a></h4>
<p>A comma separated list indicating user name(s) of tester(s). Any update coming from users other than the ones listed here are discarded during test execution.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;AllowedUserNames&quot;: &quot;tester1, Tester2, TESTER3&quot;
  /* ... */
}
</code></pre>
<h3 id="optional-settings"><a class="header" href="#optional-settings">Optional Settings</a></h3>
<p>The following settings are not required for two reasons. Either bot can ask for them during test execution or it is not a required setting for all test cases.</p>
<p>Bot will ask testers in supergroup/private chat for the necessary information. It would be faster to set all the optional settings as well because it makes testing process faster and less manual.</p>
<blockquote>
<p>For obtaining values of necessary settings, you can set breakpoints in some test methods and extract values such as chat id or user id.</p>
</blockquote>
<h4 id="supergroup-chat-id"><a class="header" href="#supergroup-chat-id">Supergroup Chat Id</a></h4>
<p>Bot send  messages to this chat in almost all test cases except cases like sending payments that must be to a private chat.</p>
<p>If not set, before starting any test method, bot waits for a tester to send it a <code>/test</code> command in a super group chat (that bot is also a member of).</p>
<pre><code class="language-json">{
  /* ... */
  &quot;SuperGroupChatId&quot;: -1234567890
  /* ... */
}
</code></pre>
<h4 id="payment-settings"><a class="header" href="#payment-settings">Payment Settings</a></h4>
<h5 id="required-payment-provider-token"><a class="header" href="#required-payment-provider-token">[Required] Payment Provider Token</a></h5>
<p>This token is <strong>required</strong> for any test case regarding payments and must be provided before starting tests.</p>
<p>Consult Telegram API documentations and talk to BotFather to get a test token from a payment provider.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;PaymentProviderToken&quot;: &quot;MY-PAYMENT-PROVIDER-TOKEN&quot;
  /* ... */
}
</code></pre>
<h5 id="testerprivatechatid"><a class="header" href="#testerprivatechatid">TesterPrivateChatId</a></h5>
<p>Invoices could only be sent to private chats. If not set, bot will wait for a tester to send it <code>/test</code> command in a private chat.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;TesterPrivateChatId&quot;: 1234567890
  /* ... */
}
</code></pre>
<h4 id="chat-administration"><a class="header" href="#chat-administration">Chat Administration</a></h4>
<p>For this type of tests, bot should be a privileged admin of that super group. Methods such as kick or unban will be performed on a regular (non-admin) tester in that chat.</p>
<p>If the following 3 settings are not set, bot will ask a tester to send it <code>/me</code> command in a private chat with bot.</p>
<ul>
<li>Regular Member's User Id</li>
<li>Regular Member's User Name</li>
<li>Regular Member's Private Chat Id</li>
</ul>
<pre><code class="language-json">{
  /* ... */
  &quot;RegularMemberUserId&quot;: 1234567890,
  &quot;RegularMemberUserName&quot;: &quot;tester3&quot;,
  &quot;RegularMemberPrivateChatId&quot;: 1234567890
  /* ... */
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-14x"><a class="header" href="#migration-guide-for-version-14x">Migration guide for version 14.x</a></h1>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and Time</a></h2>
<p>All <code>DateTime</code> values are now in UTC format. Here are some examples of usage:</p>
<pre><code class="language-csharp">// Use UTC time when making a request
await bot.KickChatMemberAsync(
    chatId: -9876,
    userId: 1234,
    untilDate: DateTime.UtcNow.AddDays(2)
);
</code></pre>
<pre><code class="language-csharp">// Convert to local time (not recommended though)
DateTime localTime = update.Message.Date.ToLocalTime();
</code></pre>
<h2 id="keyboard-buttons"><a class="header" href="#keyboard-buttons">Keyboard Buttons</a></h2>
<p>Many keyboard button types are removed from project. It is more convenient to use factory methods on <code>KeyboardButton</code> and <code>InlineKeyboardButton</code> classes.</p>
<p>Here are some examples:</p>
<pre><code class="language-csharp">// Message having an inline keyboard button with URL that redirects to a page
await bot.SendTextMessageAsync(
    chatId: -9876,
    text: &quot;Check out the source code&quot;,
    replyMarkup: new InlineKeyboardMarkup(
        InlineKeyboardButton.WithUrl(&quot;Repository&quot;, &quot;https://github.com/TelegramBots/Telegram.Bot&quot;)
    )
);
</code></pre>
<pre><code class="language-csharp">// Message to a private chat having a 2-row reply keyboard
await bot.SendTextMessageAsync(
    chatId: 1234,
    text: &quot;Share your contact &amp; location&quot;,
    replyMarkup: new ReplyKeyboardMarkup(
        new [] { KeyboardButton.WithRequestContact(&quot;Share Contact&quot;) },
        new [] { KeyboardButton.WithRequestLocation(&quot;Share Location&quot;) },
    )
);
</code></pre>
<h2 id="getfileasync"><a class="header" href="#getfileasync"><code>GetFileAsync()</code></a></h2>
<p>Downloading a file from Telegram Bot API has 2 steps (<a href="https://core.telegram.org/bots/api#getfile">see docs here</a>):</p>
<ol>
<li>Get file info by calling <code>getFile</code></li>
<li>Download file from <code>https://api.telegram.org/file/bot&lt;token&gt;/&lt;file_path&gt;</code></li>
</ol>
<p><code>GetFileAsync()</code> is replaced by 3 methods. Method <code>GetInfoAndDownloadFileAsync()</code> looks very similar to old <code>GetFileAsync()</code>:</p>
<pre><code class="language-csharp">// Gets file info and saves it to &quot;path/to/file.pdf&quot;
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;))
{
    File fileInfo = await bot.GetInfoAndDownloadFileAsync(
        fileId: &quot;BsdfgLg4Khdlsn-bldBD&quot;,
        destination: fileStream
    );
}
</code></pre>
<blockquote>
<p>Note that calling the method <code>GetInfoAndDownloadFileAsync()</code> results in 2 HTTP requests (steps 1 and 2 above) being sent to the Bot API.</p>
</blockquote>
<p>There are two more methods that assist you with downloading files:</p>
<pre><code class="language-csharp">// New version of GetFileAsync() only gets the file info (step 1)
File fileInfo = await bot.GetFileAsync(&quot;BsdfgLg4Khdlsn-bldBD&quot;);

// Download file from server (step 2)
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;)) {
    await bot.DownloadFileAsync(
        filePath: fileInfo.FilePath,
        destination: fileStream
    );
}
</code></pre>
<h2 id="getupdatesasync-setwebhookasync"><a class="header" href="#getupdatesasync-setwebhookasync"><code>GetUpdatesAsync()</code>, <code>SetWebhookAsync()</code></a></h2>
<p>Value <code>All</code> is removed from enum <code>Telegram.Bot.Types.Enums.UpdateType</code>. In order to get all kind of updates, pass an empty list such as <code>Array.Empty&lt;UpdateType&gt;()</code> for <code>allowedUpdates</code> argument.</p>
<h2 id="setwebhookasync-1"><a class="header" href="#setwebhookasync-1"><code>SetWebhookAsync()</code></a></h2>
<p>Parameter <code>url</code> is required. If you intend to remove the webhook, it is recommended to use <code>DeleteWebhookAsync()</code> instead. However, you could achieve the same result by passing <code>string.Empty</code> value to <code>url</code> argument.</p>
<h2 id="answerinlinequeryasync-and-inlinequeryresult"><a class="header" href="#answerinlinequeryasync-and-inlinequeryresult"><code>AnswerInlineQueryAsync()</code> and <code>InlineQueryResult</code></a></h2>
<p>Classes <code>InlineQueryResultNew</code> and <code>InlineQueryResultCache</code> are removed. <code>InlineQueryResult</code> has become the only shared base type for all inline query result classes.</p>
<p>Many shared and redundant properties are removed. This might require significant changes to your <code>.cs</code> files if your bot is in <em>inline mode</em>. Fortunately, all input query results now have constructors with only the required properties as their parameters. This is the preferred way to instantiate input query result instances e.g.:</p>
<p>Instead of:</p>
<pre><code class="language-csharp">// bad way. easy to get exceptions
var documentResult = new InlineQueryResultDocument
{
    Id = &quot;some-id&quot;,
    Url = &quot;https://example.com/document.pdf&quot;,
    Title = &quot;Some title&quot;,
    MimeType = &quot;application/pdf&quot;
};
</code></pre>
<p>You should use:</p>
<pre><code class="language-csharp">// good way
var documentResult = new InlineQueryResultDocument(
    id: &quot;some-id&quot;,
    documentUrl: &quot;https://example.com/document.pdf&quot;,
    title: &quot;Some title&quot;,
    mimeType: &quot;application/pdf&quot;
);
</code></pre>
<h2 id="sendmediagroupasync"><a class="header" href="#sendmediagroupasync"><code>SendMediaGroupAsync()</code></a></h2>
<p><code>InputMediaType</code> is renamed to <code>InputMedia</code>.</p>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<h2 id="inline-message-overloads"><a class="header" href="#inline-message-overloads">Inline Message Overloads</a></h2>
<p>Many inline message methods have been replaced with their overloads.</p>
<ul>
<li><code>EditInlineMessageTextAsync</code>--&gt; <code>EditMessageTextAsync</code></li>
</ul>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<h2 id="filetosend"><a class="header" href="#filetosend"><code>FileToSend</code></a></h2>
<p>New classes have replaced <code>FileToSend</code> struct.</p>
<ul>
<li><code>InputFileStream</code>:</li>
<li><code>InputTelegramFile</code>:</li>
<li><code>InputOnlineFile</code>:</li>
</ul>
<p>In many cases, you can use implicit casting to pass parameters.</p>
<pre><code class="language-csharp">Stream stream = System.IO.File.OpenRead(&quot;photo.png&quot;);
var message = await bot.SendPhotoAsync(&quot;chat id&quot;, stream);

string fileId = &quot;file_id on Telegram servers&quot;;
var message = await bot.SendPhotoAsync(&quot;chat id&quot;, fileId);
</code></pre>
<blockquote>
<p><em>ToDo</em>. implicit casts</p>
</blockquote>
<h2 id="updatetype-and-messagetype"><a class="header" href="#updatetype-and-messagetype"><code>UpdateType</code> and <code>MessageType</code></a></h2>
<p>Values in these two enums are renamed e.g. <code>UpdateType.MessageUpdate</code> is now <code>UpdateType.Message</code>.</p>
<p><code>MessageType.Service</code> is removed. Now each type of message has its own <code>MessageType</code> value e.g. when a chat member leaves a group, corresponding update contains a message type of <code>MessageType.ChatMemberLeft</code> value.</p>
<h2 id="videonote"><a class="header" href="#videonote"><code>VideoNote</code></a></h2>
<p>Properties <code>Width</code> and <code>Height</code> are removed. Vide notes are squared and <code>Length</code> property represents both width and height.</p>
<h2 id="constructor-parameters-instead-of-public-setters"><a class="header" href="#constructor-parameters-instead-of-public-setters">Constructor Parameters Instead of Public Setters</a></h2>
<p>Many types now have the required parameters in their constructors. To avoid running into problems or getting exceptions, we recommend providing all required values in the constructor e.g.:</p>
<pre><code class="language-c#">//bad way:
var markup = new InlineKeyboardMarkup
    {
        Keyboard = buttonsArray,
        ResizeKeyboard = true
    };

// better:
var markup = new InlineKeyboardMarkup(buttonsArray)
    {
        ResizeKeyboard = true
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-170"><a class="header" href="#migration-guide-for-version-170">Migration guide for version 17.0</a></h1>
<p>There are several breaking changes in v17:</p>
<ul>
<li>New exceptions handling logic</li>
<li>Removal of update and message events</li>
<li>Removal of API methods from <code>ITelegramBotClient</code> interface and moving them into extension methods in the same namespace (that shouldn't break anyone's sources as long as they don't employ reflection or make their own interface implementations)</li>
<li>Working with default enum values</li>
</ul>
<p>These are the most user facing breaking changes you should be aware of during migration.</p>
<p>Let's dive deep on the migrations.</p>
<h2 id="new-exceptions-handling-logic"><a class="header" href="#new-exceptions-handling-logic">New exceptions handling logic</a></h2>
<p>v17 brings a new base type for exceptions: <code>RequestException</code>. <code>ApiRequestException</code>  inherits from <code>RequestException</code> and is thrown only when an actual error response with the correct body is received from the Bot API. In other situations <code>RequestException</code> will be thrown instead containing actual exception as <code>InnerException</code> if there is one, e.g. serialization or connection-related exceptions.</p>
<p>If you used <code>ApiRequestException</code> and <code>HttpRequestException</code> to handle most exception now you have to replace <code>HttpRequestException</code> with <code>RequestException</code> and look for the inner exception. All valid errors with JSON body from Telegram are now thrown as <code>ApiRequestException</code> including <code>429: Too Many Requests</code>.</p>
<p>Since <code>5XX</code> responses don't usually include correct JSON body they are thrown as <code>RequestException</code> with <code>HttpRequestException</code> inside.</p>
<p>Look at the following example on how to handle different kinds of exceptions. You might not need to implement everything as you see, it's there only for demonstration purposes.</p>
<pre><code class="language-csharp">try
{
    await bot.SendTextMessageAsync(chatId, &quot;Hello&quot;);
}
catch (ApiRequestException exception)
{
    switch (exception.StatusCode)
    {
        case 400:
            // Handle incorrect requests exceptions
            break;
        case 401:
            // Handle incorrect bot token exception (revoked tokens)
            break;
        case 403:
            // Handle authorization exceptions (blocked users, unaccessible chats, etc)
            break;
        case 429:
            // Handle rate limiting exception
            break;
        default:
            // Handle other errors with valid json body: it includes status code and description of the error
            break;
    }
}
catch (RequestException exception)
{
    if (exception.InnerException is HttpRequestException httpRequestException)
    {
        // Handle connection exceptions or 5XX exceptions from the Bot API
    }
    else if (exception.InnerException is JsonSerializationException serializationException)
    {
        // Handle serialization exception when a request or a response can't be serialized for some reason
    }
    else
    {
        // Handle all other exceptions
    }
}
catch (OperationCancelledException exception)
{
    // Handle cancellation exception, e.g. when CancellationToken is cancelled
}
</code></pre>
<h2 id="removal-of-events"><a class="header" href="#removal-of-events">Removal of events</a></h2>
<p>In v17 we removed events and introduced a new way of getting updates with <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Polling">Telegram.Bot.Extensions.Polling</a> package. You can find an example in <a href="./1/example-bot.html">First Chat Bot</a> article.</p>
<h2 id="removal-of-api-methods-from-itelegrambotclient-interface"><a class="header" href="#removal-of-api-methods-from-itelegrambotclient-interface">Removal of API methods from <code>ITelegramBotClient</code> interface</a></h2>
<p>This change shouldn't affect most users, the methods are still there, but instead of being implementations of the interface they are now extension methods. It makes the interface leaner and easier to implement for custom clients and for decorators (e.g. rate limiters implemented as decorators). There isn't really a migration path for those who used these for some reason.</p>
<h2 id="working-with-default-enum-values"><a class="header" href="#working-with-default-enum-values">Working with default enum values</a></h2>
<p>We changed how we work with enums. The most notable change is the default value: there is none, all our enums are now start with 1 (exception <code>UpdateType</code> and <code>MessageType</code> since they are not a part of the Bot API and we fully control these). <code>0</code> value is left unassigned for a purpose: if we encounter an unknown value in the response from the Bot API we assign <code>0</code> as its value.</p>
<p>Let's imagine that Telegram adds new <code>MessageEntity</code> value. From now on all unknown values can be handled in the <code>default</code> case of <code>switch</code> statement.</p>
<pre><code class="language-csharp">MessageEntity entity = message.Entities.First();

switch (entity.Type)
{
    case MessageEntityType.Username:
        // ...
        break;
    case MessageEntityType.Command:
        // ...
        break;
    default:
        // All unknown values will go there
        break;
}
</code></pre>
<p>Also some default enums values were removed, e.g. <code>ParseMode.Default</code> since we started using nullable types for every optional value and <code>ParseMode.Default</code> lost it's use. If a message doesn't have any markup you'll receive <code>null</code> in places where <code>ParseMode</code> type was used or if you want to explicitly indicate an absence of markup pass <code>null</code> instead.</p>
<h2 id="other-breaking-changes"><a class="header" href="#other-breaking-changes">Other breaking changes</a></h2>
<h3 id="constructor-accepting-iwebproxy"><a class="header" href="#constructor-accepting-iwebproxy">Constructor accepting IWebProxy</a></h3>
<p>We removed constructor accepting <code>IWebProxy</code>. Now you have to configure HttpClient yourself to use proxy. You can find examples in <a href="./4/proxy.html#http-proxy">Working Behind a Proxy</a> article.</p>
<h3 id="inputmediatype"><a class="header" href="#inputmediatype">InputMediaType</a></h3>
<p>Property <code>Type</code> in <code>IInputMedia</code> was changed to an enum <code>InputMediaType</code> for easier discoverability. So if you relied string values like <code>photo</code>, <code>video</code>, <code>animation</code> and so on now you need to switch to using enums. As a result you'll get autocomplete in IDEs and more predictability of what types of input media there are.</p>
<h3 id="encryptedpassportelementtype"><a class="header" href="#encryptedpassportelementtype">EncryptedPassportElementType</a></h3>
<p>Property <code>Type</code> of <code>EncryptedPassportElement</code> was replace with an enum for the same reason with <code>EncryptedPassportElementType</code> enum.</p>
<h3 id="chatmember"><a class="header" href="#chatmember">ChatMember</a></h3>
<p>As part of Bot API 5.3 implementation <code>ChatMember</code> type was split into a hierarchy of types with a discriminator field <code>Status</code>. If you need to access some data from the derived class you should use pattern matching or type casting like this:</p>
<pre><code class="language-csharp">ChatMember member = ... //;

if (chatMember is ChatMemberKicked kickedMember)
{
    // now you can access properties of a kicked chat member
    if (kickedMember.Until is not null)
    {
        // do something with the value of Until
    }
}
</code></pre>
<h3 id="chatid"><a class="header" href="#chatid">ChatId</a></h3>
<p>Fields <code>Identifier</code> and <code>Username</code> are now get-only properties. It shouldn't break most people's code as it's not a source breaking change. If you used reflection to find these fields you should to look for properties now.</p>
<h3 id="inlinequeryresultbase"><a class="header" href="#inlinequeryresultbase">InlineQueryResultBase</a></h3>
<p>Type <code>InlineQueryResultBase</code> is renamed to <code>InlineQueryResult</code> to match Bot API type hierarchy.</p>
<h3 id="nullability"><a class="header" href="#nullability">Nullability</a></h3>
<p>From now on all properties that are optional will use nullable types, e.g. <code>int?</code>, <code>string?</code>, because default values of such properties might be an actual values and isn't distinguishable from a lack of value. From now if a property is <code>null</code> you can be sure that it's value was not present in a response from the Bot API.</p>
<h3 id="replykeyboardmarkup"><a class="header" href="#replykeyboardmarkup">ReplyKeyboardMarkup</a></h3>
<p>Since <code>ResizeKeyboard</code> and <code>OneTimeKeyboard</code> are optional, we removed them from <code>ReplyKeyboardMarkup</code> constructor. You have to use <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer">object initialization syntax</a> to configure these properties:</p>
<pre><code class="language-csharp">var replyKeyboardMarkup = new ReplyKeyboardMarkup(
    new KeyboardButton[][]
    {
        new KeyboardButton[] { &quot;1.1&quot;, &quot;1.2&quot; },
        new KeyboardButton[] { &quot;2.1&quot;, &quot;2.2&quot; },
    })
    {
        ResizeKeyboard = true
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-180"><a class="header" href="#migration-guide-for-version-180">Migration guide for version 18.0</a></h1>
<p>Most breaking changes in v18 come from new Bot API changes, such as:</p>
<ol>
<li>In <a href="https://core.telegram.org/bots/api#april-16-2022">Bot API 6.0</a> <code>voice_chat*</code> related message properties were
deprecated in favour of <code>video_chat*</code> with the same semantics and shape.</li>
<li>With introduction of video stickers in <a href="https://core.telegram.org/bots/api#january-31-2022">Bot API 5.7</a> we needed a way
to separate methods for different sticker types. So static .WEBP <code>*StickerSet*</code> methods and requests were given a <code>Static</code> prefix.</li>
<li>Removed <code>untilDate</code> parameter from <code>TelegramBotClientExtensions.BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class.</li>
<li>As of the next update some users will be able to upload up to 4GB files, so we changed <code>FileBase.FileSize</code> type to <code>long?</code>.</li>
<li>A new way of configuring the client.</li>
<li><code>ApiRequestEventArgs</code> contains full request data.</li>
</ol>
<p>Complete list of changes is available in <a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/CHANGELOG.md">CHANGELOG</a></p>
<h2 id="1-removal-of-voicechat-properties-in-message-object"><a class="header" href="#1-removal-of-voicechat-properties-in-message-object">1. Removal of <code>VoiceChat*</code> properties in <code>Message</code> object</a></h2>
<p>Telegram renamed <code>voice_chat_*</code> properties in the <code>Message</code> class and with <code>video_chat_*</code> onces so we replaced
corresponding <code>MessageType</code> enum members with the new ones.</p>
<p>Following properties in <code>Message</code> class and corresponding enum members in <code>MessageType</code> enum were changed:</p>
<pre><code class="language-diff">-VoiceChatScheduled
-VoiceChatStarted
-VoiceChatEnded
-VoiceChatParticipantsInvited
+VideoChatScheduled
+VideoChatStarted
+VideoChatEnded
+VideoChatParticipantsInvited
</code></pre>
<p>Also property <code>CanManageVoiceChats</code> in <code>ChatMemberAdministrator</code> and <code>PromoteChatMemberRequest</code> classes was renamed to
<code>CanManageVideoChats</code>.</p>
<h2 id="2-renaming-static-sticker-methods-and-classes"><a class="header" href="#2-renaming-static-sticker-methods-and-classes">2. Renaming static sticker methods and classes</a></h2>
<p>With introduction of video stickers in <a href="https://core.telegram.org/bots/api#january-31-2022">Bot API 5.7</a> we needed a way
to separate methods for different sticker types. We already used <code>Animated</code> and <code>Video</code> suffix for methods related to animated
and video stickers so we decided to do the same for the static stickers:</p>
<ul>
<li>Classes <code>CreateNewStickerSetRequest</code> and <code>AddStickerToSetRequest</code> were renamed to <code>CreateNewStaticStickerSetRequest</code>
and <code>AddStaticStickerToSetRequest</code>.</li>
<li>Methods <code>CreateNewStickerSetAsync</code> and <code>AddStickerToSetAsync</code> where renamed to
<code>CreateStaticNewStickerSetAsync</code> and <code>AddStaticStickerToSetAsync</code>.</li>
</ul>
<h2 id="3-removal-of-untildate-parameter-from-banchatsenderchatasync-method-and-untildate-property-from-banchatsenderchatrequest-class"><a class="header" href="#3-removal-of-untildate-parameter-from-banchatsenderchatasync-method-and-untildate-property-from-banchatsenderchatrequest-class">3. Removal of <code>untilDate</code> parameter from <code>BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class</a></h2>
<p>The <code>untilDate</code> parameter from <code>TelegramBotClientExtensions.BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class were removed from the Bot API.</p>
<h2 id="4-lifting-of-the-filesize-limit"><a class="header" href="#4-lifting-of-the-filesize-limit">4. Lifting of the FileSize limit</a></h2>
<p>As of the next update some users will be able to upload up to 4GB files, so we changed <code>FileBase.FileSize</code> type to <code>long?</code> to accommodate this change.</p>
<h2 id="5-a-new-way-of-client-configuration"><a class="header" href="#5-a-new-way-of-client-configuration">5. A new way of client configuration</a></h2>
<p>Starting with this release client configuration parameters should be passed through <code>TelegramBotClientOptions</code> class.
You need to create an instance of <code>TelegramBotClientOptions</code> and pass it to the client:</p>
<pre><code class="language-csharp">using Telegram.Bot;

var options = new TelegramBotClientOptions(
    token: &quot;&lt;token&gt;&quot;

    // pass an optional baseUrl if you want to use a custom bot server
    baseUrl: &quot;https://custombotserverdomain.com&quot;,

    // pass an optional flag `true` if you want to use test environment
    useTestEnvironment = true
);

var client = new TelegramBotClient(options);
</code></pre>
<p>If you don't know about test environment you can read more about it in the official
<a href="https://core.telegram.org/bots/webapps#using-bots-in-the-test-environment">documentation</a>.</p>
<p>If you don't need extra configuration options you can still use the constructor that accepts a token and an instance of <code>HttpClient</code>:</p>
<pre><code class="language-csharp">var client = new TelegramBotClient(&quot;&lt;token&gt;&quot;);
</code></pre>
<h2 id="6-polling-functionality-in-the-core-library"><a class="header" href="#6-polling-functionality-in-the-core-library">6. Polling functionality in the core library</a></h2>
<p>The latest biggest change which is not a breaking one, but nevertheless worth a note: deprecation of
<code>Telegram.Bot.Extensions.Polling</code> package.</p>
<p>All the functionality from the package was merged into the core library under namespace <code>Telegram.Bot.Polling</code>.</p>
<p>Name of the method <code>HandleErrorAsync</code> in <code>IUpdateHandler</code> interface was quite confusing from the beginning since a lot
of people assumed they can handle all errors in it, but in reality it's used only for handling errors during polling.
We decided to give it a more appropriate name: <code>HandlePollingErrorAsync</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-190"><a class="header" href="#migration-guide-for-version-190">Migration guide for version 19.0</a></h1>
<h2 id="topics-in-groups"><a class="header" href="#topics-in-groups">Topics in Groups</a></h2>
<p>New topics functionality allow bots interact with users in topic specified by <code>messageThreadId</code> parameter.</p>
<p>We try to keep our Bot API implementation as close to <a href="https://core.telegram.org/bots/api#forumtopicclosed">Telegram Bot API</a> as possible. This means, that the new <code>messageThreadId</code> now the first optional parameter for a variety of methods.</p>
<p>Consider to use named parameters to avoid confusion with changed parameter order.</p>
<pre><code class="language-diff">-Message message = await bot.SendTextMessageAsync(
-    _fixture.SupergroupChat.Id,
-    &quot;Please click on *Notify* button.&quot;,
-    cancellationToken);
+Message message = await bot.SendTextMessageAsync(
+    chatId: _fixture.SupergroupChat.Id,
+    text: &quot;Please click on *Notify* button.&quot;,
+    messageThreadId: threadId,
+    cancellationToken: cancellationToken);
</code></pre>
<h2 id="new-inputfile-hierarchy"><a class="header" href="#new-inputfile-hierarchy">New InputFile Hierarchy</a></h2>
<p>Old <code>InputMedia*</code> class hierarchy poorly reflected actual file-related APIs.</p>
<p>We removed old hierarchy of <code>InputFile</code> related classes such as <code>InputOnlineFile</code>, <code>InputTelegramFile</code>, <code>InputFileStream</code>, etc., and also removed all implicit casts to them. From now on you should explicitly specify one of file types: <code>InputFileStream</code> for <code>Stream</code> content, <code>InputFileUrl</code> for URL and <code>InputFileId</code> if you want to use existing <code>file_id</code>. For convenience the base <code>InputType</code> class has factory methods to create the correct types:</p>
<ul>
<li><code>InputFile.FromStream(Stream stream, string? fileName = default)</code> for streams</li>
<li><code>InputFile.FromString(string urlOrFileId)</code> for URLs or file ids</li>
<li><code>InputFile.FromUri(Uri url)</code> - for URLs as strings</li>
<li><code>InputFile.FromUri(string url)</code> - for URLs as <code>URI</code>s</li>
<li><code>InputFile.FromFileId(string fileId)</code> - for file ids</li>
</ul>
<p>The migration scheme looks like that:</p>
<div class="table-wrapper"><table><thead><tr><th>Previous method</th><th>New method</th></tr></thead><tbody>
<tr><td><code>new InputTelegramType(string)</code></td><td><code>InputFile.FromId(string)</code>, <code>InputFile.FromString(string)</code></td></tr>
<tr><td><code>new InputTelegramType(Stream, string?)</code></td><td><code>InputFile.FromStream(Stream, string?)</code></td></tr>
<tr><td><code>new InputFileStream(Stream)</code></td><td><code>InputFile.FromStream(Stream)</code></td></tr>
<tr><td><code>new InputOnlineFile(string)</code></td><td><code>InputFile.FromId(string)</code>, <code>InputFile.FromString(string)</code>, <code>InputFile.FromString(string)</code>, <code>InputFile.FromUrl(string)</code>, <code>InputFile.FromUrl(Uri)</code></td></tr>
<tr><td><code>new InputOnlineFile(Stream, string?)</code></td><td><code>InputFile.FromStream(Stream, string?)</code></td></tr>
<tr><td>raw <code>Stream</code></td><td><code>InputFile.FromStream(Stream)</code></td></tr>
<tr><td>raw <code>string</code></td><td><code>InputFile.FromString(string)</code></td></tr>
<tr><td>raw <code>URI</code></td><td><code>InputFile.FromUrl(URI)</code></td></tr>
</tbody></table>
</div>
<h2 id="chatid-implicit-conversion"><a class="header" href="#chatid-implicit-conversion">ChatId implicit conversion</a></h2>
<p>Implicit conversion from <code>ChatId</code> to <code>string</code> was removed due to complaints and problems it caused. The migration path is to explicitly call <code>ChatId.ToString()</code> method.</p>
<h2 id="stickers-1"><a class="header" href="#stickers-1">Stickers</a></h2>
<ul>
<li>All methods and types with animated, static and video sticker distinction were removed and replaced with a single set of sticker related methods per new Bot API updates: <code>AddAnimatedStickerToSetAsync</code>, <code>AddStaticStickerToSetAsync</code>, <code>AddVideoStickerToSetAsync</code>, etc. Remove the words <code>Static</code>, <code>Animated</code> and <code>Video</code> from sticker related methods in your code</li>
<li>Associated emojies and masks were moved to a separate type <code>InputSticker</code>, use them there instead, consult the official Bot API docs for a more detailed information</li>
</ul>
<h2 id="net-core-31-removed-as-a-separate-target-framework"><a class="header" href="#net-core-31-removed-as-a-separate-target-framework">.NET Core 3.1 removed as a separate target framework</a></h2>
<p>Since .NET Core 3.1 LTS status is not officialy supported anymore we changed the target to <code>netstandard2.0</code> and <code>net6.0</code> instead. If you're using .NET Core 3.1 or .NET 5 runtimes you need to use the build for <code>netstandard2.0</code> instead. If you relied on <code>IAsyncEnumerable</code> implementation of poller you need to move to .NET 6 instead.</p>
<h2 id="other-changes"><a class="header" href="#other-changes">Other changes</a></h2>
<ul>
<li><code>Message.Type</code> returns <code>MessageType.Animation</code> when the message contains an <code>Animation</code>, use <code>MessageType.Animation</code> instead of <code>MessageType.Document</code> to check if the message contains an animation</li>
<li>Property <code>CanSendMediaMessages</code> was removed from the types <code>ChatMemberRestricted</code> and <code>ChatPermissions</code> and replaced with more granular permissions, use them instead</li>
<li>Removed method <code>GetChatMembersCountAsync</code>, use <code>GetChatMemberCountAsync</code></li>
<li>Removed method <code>KickChatMemberAsync</code>, use <code>BanChatMemberAsync</code></li>
<li>Properties and types <code>VoiceChatEnded</code>, <code>VoiceChatParticipantsInvited</code>,
<code>VoiceChatScheduled</code>, <code>VoiceChatStarted</code> removed, use methods and types which start with <code>Video*</code> instead</li>
<li>All propties with the word <code>Thumb</code> in them were renamed to contain the word <code>Thumbnail</code> per new Bot API updates</li>
<li>A new type <code>InlineQueryResultsButton</code> is used instead of <code>SwitchPmText</code> and <code>SwitchPmParameter</code> properties, consult the official Bot API docs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-21x"><a class="header" href="#migration-guide-for-version-21x">Migration guide for version 21.x</a></h1>
<p>Important notes:</p>
<ul>
<li>Don't bother about version 20, migrate directly to version 21.*</li>
<li>You won't find this version on Nuget: <a href="https://telegrambots.github.io/book/index.html#-installation">See this guide to install it in your programs</a>.</li>
<li>Version 21.1 supports <a href="https://core.telegram.org/bots/api-changelog#june-18-2024">Bot API 7.5</a> <em>(including <a href="Migration-Guide-to-Version-21.x.html#payments-with-telegram-stars">Telegram Stars payments</a>)</em></li>
<li>Library is now based on System.Text.Json and doesn't depend on NewtonsoftJson anymore. <em>(<a href="Migration-Guide-to-Version-21.x.html#webhooks-with-systemtextjson">See below</a>)</em></li>
</ul>
<h2 id="renamed-parameter-replytomessageid--replyparameters"><a class="header" href="#renamed-parameter-replytomessageid--replyparameters">Renamed parameter <em>replyToMessageId:</em> ‚Üí <em>replyParameters:</em></a></h2>
<p>That parameter was renamed and you can still pass a <strong>messageId</strong> for simple replies.</p>
<p>Or you can pass a <a href="https://core.telegram.org/bots/api#replyparameters">ReplyParameters</a> structure for more advanced reply configuration.</p>
<h2 id="renamed-parameter-disablewebpagepreview--linkpreviewoptions"><a class="header" href="#renamed-parameter-disablewebpagepreview--linkpreviewoptions">Renamed parameter <em>disableWebPagePreview:</em> ‚Üí <em>linkPreviewOptions:</em></a></h2>
<p>That parameter was renamed and you can still pass <code>true</code> to disable web preview.</p>
<p>Or you can pass a <a href="https://core.telegram.org/bots/api#linkpreviewoptions">LinkPreviewOptions</a> structure for more precise preview configuration.</p>
<h2 id="changed-bool--bool"><a class="header" href="#changed-bool--bool">Changed <code>bool?</code> ‚Üí <code>bool</code></a></h2>
<p>Many boolean parameters or fields are now simply of type <code>bool</code>.</p>
<p>In most cases, it shouldn't impact your existing code, or rather simplify it. Previously <code>null</code> values are now just <code>false</code>.</p>
<h2 id="changed-parsemode--parsemode"><a class="header" href="#changed-parsemode--parsemode">Changed <code>ParseMode?</code> ‚Üí <code>ParseMode</code></a></h2>
<p>When you don't need to specify a ParseMode, just pass <code>default</code> or <code>ParseMode.None</code>.</p>
<h2 id="better-backward-compatibility-and-simplification-of-code"><a class="header" href="#better-backward-compatibility-and-simplification-of-code">Better backward-compatibility and simplification of code</a></h2>
<p>We added/restored features &amp; implicit conversions that make your code simpler:</p>
<ul>
<li><code>InputFile</code>: just pass a <code>string</code>/<code>Stream</code> for file_id/url/stream content <em>(as was possible in previous versions of Telegram.Bot)</em></li>
<li><code>InputMedia*</code>: just pass an <code>InputFile</code> when you don't need to associate caption or such</li>
<li><code>MessageId</code>: auto-converts to/from <code>int</code> (and also from <code>Message</code>)</li>
<li><code>ReactionType</code>: just pass a <code>string</code> when you want to send an emoji</li>
<li><code>ReactionType</code>: just pass a <code>long</code> when you want to send a custom emoji (id)</li>
<li>Some other obvious implicit conversion operators for structures containing a single property</li>
<li>No more enforcing <code>init;</code> properties, so you can adjust the content of fields as you wish or modify a structure returned by the API <em>(before passing it back to the API if you want)</em></li>
<li>No more JSON &quot;required properties&quot; during deserialization, so your old saved JSON files won't break if a field is added/renamed.</li>
<li>Restored some <code>MessageType</code> enum values that were removed (renamed) recently (easier compatibility)</li>
</ul>
<h2 id="maybeinaccessiblemessage"><a class="header" href="#maybeinaccessiblemessage">MaybeInaccessibleMessage</a></h2>
<p>This class hierarchy was introduced in Bot API 7.0 and broke existing code and added unnecessary complexity.</p>
<p>This was removed in our library v21 and you will just receive directly a Message <em>(as before)</em>.</p>
<p>To identify an &quot;inaccessible message&quot;, you can just check <code>message.Type == MessageType.Unknown</code> or <code>message.Date == default</code>.</p>
<h2 id="chat-and-chatfullinfo"><a class="header" href="#chat-and-chatfullinfo">Chat and ChatFullInfo</a></h2>
<p>In previous versions, the big <code>Chat</code> structure contained many fields that were filled only after a call to GetChatAsync.</p>
<p>This structure is now split into <code>Chat</code> and <code>ChatFullInfo</code> structures.</p>
<p>The new <code>Chat</code> structure contains only common fields that are always filled.
The new <code>ChatFullInfo</code> structure inherits from <code>Chat</code> and is returned only by GetChatAsync method, with all the extra fields.</p>
<h2 id="request-structures"><a class="header" href="#request-structures">Request structures</a></h2>
<p>Request structures <em>(types ending with <code>Request</code>)</em> are NOT the recommended way to use the library in your projects.</p>
<p>They are to be considered as low-level raw access to Bot API structures for advanced programmers, and might change/break at any time in the future.</p>
<p>If you have existing code using them, you can use the <code>MakeRequestAsync</code> method to send those requests.
(Other methods based on those requests will be removed soon)</p>
<h2 id="payments-with-telegram-stars"><a class="header" href="#payments-with-telegram-stars">Payments with Telegram Stars</a></h2>
<p>To make a payment in <a href="https://t.me/BotNews/90">Telegram Stars</a> with SendInvoiceAsync, set the following parameters:</p>
<ul>
<li><code>providerToken:</code> <code>null</code> or <code>&quot;&quot;</code></li>
<li><code>currency:</code> <code>&quot;XTR&quot;</code></li>
<li><code>prices:</code> with a single price</li>
<li>no tip amounts</li>
</ul>
<h2 id="webhooks-with-systemtextjson"><a class="header" href="#webhooks-with-systemtextjson">Webhooks with System.Text.Json</a></h2>
<p>The library now uses <code>System.Text.Json</code> instead of <code>NewtonsoftJson</code>.</p>
<p>To make it work in your ASP.NET projects, you should now:</p>
<ul>
<li>Remove package <strong>Microsoft.AspNetCore.Mvc.NewtonsoftJson</strong> from your project dependencies</li>
<li>Follow our <a href="3/updates/webhook.html">Webhook page</a> to configure your web app correctly</li>
</ul>
<h2 id="inputpolloption-in-sendpollasync"><a class="header" href="#inputpolloption-in-sendpollasync">InputPollOption in SendPollAsync</a></h2>
<p>SendPollAsync now expect an array of InputPollOption instead of string.</p>
<p>But we added an implicit conversion from string to InputPollOption, so the change is minimal:</p>
<pre><code class="language-csharp">// before:
await bot.SendPollAsync(chatId, &quot;question&quot;, new[] { &quot;answer1&quot;, &quot;answer2&quot; });
// after:
await bot.SendPollAsync(chatId, &quot;question&quot;, new InputPollOption[] { &quot;answer1&quot;, &quot;answer2&quot; });
</code></pre>
<h2 id="global-cancellation-token-v212"><a class="header" href="#global-cancellation-token-v212">Global cancellation token (v21.2)</a></h2>
<p>You can now specify a global <code>CancellationToken</code> directly in TelegramBotClient constructor.</p>
<p>This way, you won't need to pass a cancellationToken to every method call after that
(if you just need one single cancellation token for stopping your bot)</p>
<h2 id="polling-system-now-catch-exceptions-in-your-handleupdate-code-v213"><a class="header" href="#polling-system-now-catch-exceptions-in-your-handleupdate-code-v213">Polling system now catch exceptions in your HandleUpdate code (v21.3)</a></h2>
<blockquote>
<p>‚ö†Ô∏è That's a change of behaviour, but most of you will probably welcome this change</p>
</blockquote>
<p>If you forgot to wrap your HandleUpdateAsync code in a big <code>try..catch</code>, and your code happen to throw an exception,
this would previously stop the polling completely.</p>
<p>Now the Polling system will catch your exceptions, pass them to your HandleErrorAsync method
<strong>and continue the polling</strong>.</p>
<blockquote>
<p>In previous versions of the library:</p>
<ul>
<li>ReceiveAsync would throw out the exception (therefore stopping the polling)</li>
<li>StartReceiving would pass the exception to HandlePollingErrorAsync and silently stop the polling</li>
</ul>
<p>If you still want the previous behaviour, have your HandleErrorAsync start like this:</p>
<pre><code class="language-csharp">Task HandleErrorAsync(ITelegramBotClient bot, Exception ex, HandleErrorSource source, CancellationToken ct)
{
   if (source is HandleErrorSource.HandleUpdateError) throw ex;
   ...
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>I recommend you read all of these as you will learn many interesting things. Or you can use Ctrl-F to search for a specific topic.</p>
<h3 id="1-can-you-give-me-documentationexamples-links"><a class="header" href="#1-can-you-give-me-documentationexamples-links"><em>1. Can you give me documentation/examples links?</em></a></h3>
<ul>
<li>Follow <a href="README.html#-installation">this installation guide</a> to install the latest versions of the library.</li>
<li>You are on the <a href="https://telegrambots.github.io/book/">main documentation website</a>.</li>
<li>Here are <a href="https://github.com/TelegramBots/Telegram.Bot.Examples">some bot examples</a></li>
<li>Search the <a href="https://core.telegram.org/bots/api">official API documentation</a> and <a href="https://core.telegram.org/bots/faq">official FAQ</a>.</li>
<li>check tooltips in your IDE, or navigate with F12 on API methods and read/expand comments.
&gt;If you're C# beginner, you should learn about <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/">async programming</a>.</li>
</ul>
<h3 id="2-my-update-handler-fails-or-stops-executing-at-some-point"><a class="header" href="#2-my-update-handler-fails-or-stops-executing-at-some-point"><em>2. My update handler fails or stops executing at some point</em></a></h3>
<p>You likely have an exception somewhere. You should place a <code>try..catch</code> around your whole update handler.<br />
Also, you should learn to <ins>use a debugger</ins> and go step-by-step through your code to understand where and why an exception is raised. See next question.</p>
<h3 id="3-apparently-my-update-handler-gets-a-nullreferenceexception"><a class="header" href="#3-apparently-my-update-handler-gets-a-nullreferenceexception"><em>3. Apparently my update handler gets a</em> <code>NullReferenceException</code></a></h3>
<p>Not all updates are about an incoming Message, so <code>update.Message</code> could be null. (see also <code>update.Type</code>)<br />
Not all messages are text messages, <code>message.Text</code> could be null (see also <code>message.Type</code>). etc...<br />
So please <ins>use a debugger</ins> to check the content of your variables or structure fields and make sure your code can handle all cases.</p>
<h3 id="4-how-to-add-buttons-under-a-message"><a class="header" href="#4-how-to-add-buttons-under-a-message"><em>4. How to add buttons under a message?</em></a></h3>
<p>Pass an <a href="https://telegrambots.github.io/book/2/reply-markup.html#inline-keyboards">InlineKeyboardMarkup</a> into the <code>replyMarkup</code> parameter when sending the message. You will likely need to create a <code>List&lt;List&lt;InlineKeyboardButton&gt;&gt;</code> for rows&amp;columns<br />
<em>See also next question.</em></p>
<h3 id="5-how-to-handle-a-click-on-such-inline-buttons"><a class="header" href="#5-how-to-handle-a-click-on-such-inline-buttons"><em>5. How to handle a click on such inline buttons?</em></a></h3>
<p>For buttons with callback data, your update handler should handle <code>update.CallbackQuery</code>.
<em>(Remember that not all updates are about <code>update.Message</code>. See question #3)</em></p>
<p>Your code should answer to the query within 10 seconds, using <code>AnswerCallbackQueryAsync</code> <em>(or else the button gets momentarily disabled)</em></p>
<h3 id="6-how-to-show-a-popup-text-to-the-user"><a class="header" href="#6-how-to-show-a-popup-text-to-the-user"><em>6. How to show a popup text to the user?</em></a></h3>
<p>It is only possible with inline callback button <em>(see above questions)</em>.<br />
In <code>AnswerCallbackQueryAsync</code>, pass parameter <code>showAlert: true</code> to display as a popup.</p>
<h3 id="7-how-to-fill-the-input-textbox-of-the-user-with-some-text"><a class="header" href="#7-how-to-fill-the-input-textbox-of-the-user-with-some-text"><em>7. How to fill the input textbox of the user with some text?</em></a></h3>
<p>You can't. The closest you can do is setup a <code>ReplyKeyboardMarkup</code> for buttons with pre-made texts under the textbox</p>
<h3 id="8-how-to-fetch-previous-messages"><a class="header" href="#8-how-to-fetch-previous-messages"><em>8. How to fetch previous messages?</em></a></h3>
<p>You can't with Bot API but it's possible with <a href="https://www.nuget.org/packages/WTelegramBot">WTelegramBot</a>.<br />
Normally, bots only get messages at the moment they are posted. You could archive them all in a database for later retrieval.</p>
<h3 id="9-how-to-fetch-a-list-of-all-users-in-chat"><a class="header" href="#9-how-to-fetch-a-list-of-all-users-in-chat"><em>9. How to fetch a list of all users in chat?</em></a></h3>
<p>You can't with Bot API but it's possible with <a href="https://www.nuget.org/packages/WTelegramBot">WTelegramBot</a>.<br />
Normally, bots can only get the list of administrators (<code>GetChatAdministratorsAsync</code>) or detail about one specific member (<code>GetChatMemberAsync</code>)
Alternatively, you can keep track of users by observing new messages in a chat and saving user info into a database.</p>
<h3 id="10-how-to-send-a-private-message-to-some-random-user"><a class="header" href="#10-how-to-send-a-private-message-to-some-random-user"><em>10. How to send a private message to some random user?</em></a></h3>
<p>You can't. Bots can only send private messages to users that have already initiated a private chat with your bot.</p>
<h3 id="11-how-to-detect-if-a-user-blocked-my-bot"><a class="header" href="#11-how-to-detect-if-a-user-blocked-my-bot"><em>11. How to detect if a user blocked my bot?</em></a></h3>
<p>You would have received an <code>update.MyChatMember</code> with <code>NewChatMember.Status == ChatMemberStatus.Kicked</code>
If you didn't record that info, you can try to <code>SendChatActionAsync</code> and see if it raise an exception.</p>
<h3 id="12-how-to-set-a-caption-to-a-media-group-album"><a class="header" href="#12-how-to-set-a-caption-to-a-media-group-album"><em>12. How to set a caption to a media group (album)?</em></a></h3>
<p>Set the <code>media.Caption</code> (and <code>media.ParseMode</code>) on the first media</p>
<h3 id="13-how-to-write-a-bot-that-make-questionsanswers-with-users"><a class="header" href="#13-how-to-write-a-bot-that-make-questionsanswers-with-users"><em>13. How to write a bot that make questions/answers with users?</em></a></h3>
<p>Either you can code a complex state machine workflow, saving where each user is currently in the discussion.<br />
Or you can just use <a href="https://github.com/wiz0u/YourEasyBot">YourEasyBot</a> which makes sequential bots very simple to write... <em>(or one of the <a href="https://github.com/TelegramBots/Telegram.Bot/issues/1072">other frameworks</a> available for Telegram.Bot)</em></p>
<h3 id="14-how-to-make-font-effects-in-message"><a class="header" href="#14-how-to-make-font-effects-in-message"><em>14. How to make font effects in message?</em></a></h3>
<p>Pass a <code>ParseMode.Html</code> <em>(or <code>ParseMode.MarkDownV2</code>)</em> to argument <code>parseMode</code>. See <a href="https://core.telegram.org/bots/api#formatting-options">formatting options</a>.<br />
‚ö†Ô∏è I <ins><strong>highly recommend</strong></ins> you choose HTML formatting because MarkDownV2 has A LOT of annoyingly reserved characters and you will regret it later.</p>
<h3 id="15-where-can-i-host-my-bot-online-for-cheapfree"><a class="header" href="#15-where-can-i-host-my-bot-online-for-cheapfree"><em>15. Where can I host my bot online for cheap/free?</em></a></h3>
<p>I would recommend you make an ASP.NET webhook bot and host it on some WebApp hosting service.<br />
For example, <a href="https://azure.microsoft.com/products/app-service/web">Azure WebApp Service</a> has a <a href="https://azure.microsoft.com/pricing/details/app-service/windows/">F1 Free plan</a> including 1 GB disk, 1 GB ram, 60 minutes of daily cumulated active CPU usage <em>(more than enough for most bots without heavy use)</em>. And publishing to Azure is very easy from VS.<br />
A credit-card is necessary but you shouldn't get charged if you stay within quotas.<br />
Other cloud providers might also offer similar services.</p>
<h3 id="16-is-there-some-limitationmaximum-about-feature-x"><a class="header" href="#16-is-there-some-limitationmaximum-about-feature-x"><em>16. Is there some limitation/maximum about feature X?</em></a></h3>
<p>See https://limits.tginfo.me for a list of limitations.</p>
<h3 id="17-how-to-populate-the-bot-menu-button--commands-list"><a class="header" href="#17-how-to-populate-the-bot-menu-button--commands-list"><em>17. How to populate the bot Menu button / commands list?</em></a></h3>
<p>You can either do this via <a href="https://t.me/BotFather">@BotFather</a> <em>(static entries)</em>, or you can use <code>SetMyCommandsAsync</code> for more advanced settings<br />
‚ö†Ô∏è This can only be filled with bot commands, starting with a <code>/</code> and containing only latin characters <code>a-z_0-9</code></p>
<h3 id="18-how-to-receive-chatmember-updates"><a class="header" href="#18-how-to-receive-chatmember-updates"><em>18. How to receive <code>ChatMember</code> updates?</em></a></h3>
<p>You should specify all update types including ChatMember in <code>AllowedUpdates</code> array on <code>StartReceiving</code>:<code>ReceiverOptions</code> or <code>SetWebhookAsync</code></p>
<h3 id="19-how-to-get-rid-of-past-updates-when-i-restart-my-bot"><a class="header" href="#19-how-to-get-rid-of-past-updates-when-i-restart-my-bot"><em>19. How to get rid of past updates when I restart my bot?</em></a></h3>
<p>Pass true into <code>StartReceiving</code>:<code>ReceiverOptions</code>:<code>DropPendingUpdates</code> or <code>SetWebhookAsync</code>:<code>dropPendingUpdates</code></p>
<h3 id="20-difficulties-to-upload--send-a-filemedia"><a class="header" href="#20-difficulties-to-upload--send-a-filemedia"><em>20. Difficulties to upload &amp; send a file/media?</em></a></h3>
<ul>
<li>Make sure you <code>await</code> until the end of the send method before closing the file (a &quot;<code>using</code>&quot; clause would close the file on leaving the current { scope }</li>
<li>If you just filled a <code>MemoryStream</code>, make sure to rewind it to the beginning with <code>ms.Position = 0;</code> before sending</li>
<li>If you send a media group, make sure you specify different filenames on <code>InputFile.FromStream</code></li>
</ul>
<h3 id="21-how-to-fetch-all-medias-from-an-albummedia-group-"><a class="header" href="#21-how-to-fetch-all-medias-from-an-albummedia-group-"><em>21. How to fetch all medias from an album/media group ?</em></a></h3>
<p>Medias in a media group are received as separate consecutive messages having the same <code>MediaGroupId</code> property. You should collect them progressively as you receive those messages.<br />
There is no way to know how many medias are in the album, so:</p>
<ul>
<li>look for consecutive messages in that chat with same <code>MediaGroupId</code> and stop when it's not the same</li>
<li>stop after 10 media in the group (maximum)</li>
<li>use a timeout of a few seconds not receiving new messages in that chat to determine the end</li>
</ul>
<h3 id="22-how-to-send-a-custom-emoji"><a class="header" href="#22-how-to-send-a-custom-emoji"><em>22. How to send a custom emoji‚ùì</em></a></h3>
<p>‚ö†Ô∏è It costs about ~$5,000 !! üò±</p>
<ul>
<li>First you need to buy a reserved username on <a href="https://fragment.com/">Fragment</a>.</li>
<li>Then you need to pay an <a href="https://fragment.com/about#assigning-collectible-usernames-to-telegram">additional upgrade fee</a> of 1K TON to apply that username to your bot.</li>
<li>Finally, your bot can now post custom emojis using specific <a href="https://core.telegram.org/bots/api#html-style">HTML</a> or <a href="https://core.telegram.org/bots/api#markdownv2-style">Markdown</a> syntax (or entity).</li>
</ul>
<p>To post to a specific group, there is an alternative solution:</p>
<ul>
<li>Have premium members boost your group to Level 4.</li>
<li>Then you can assign a custom emoji pack to your group that your members AND bots can use freely in group messages.</li>
</ul>
<h3 id="23-how-to-upgrade-my-existing-code-you-keep-breaking-compatibility"><a class="header" href="#23-how-to-upgrade-my-existing-code-you-keep-breaking-compatibility"><em>23. How to upgrade my existing code? You keep breaking compatibility!</em></a></h3>
<p>A new lead developer (Wizou) is now in charge of the library and commits to reduce code-breaking changes in the future.<br />
Version 21.x of the library have been much improved to facilitate <a href="Migration-Guide-to-Version-21.x.html">migration from previous versions</a> of the library, and include a lot of helpers/implicit operators to simplify your code.</p>
<h3 id="24-can-i-use-several-appsinstance-to-manage-my-bot"><a class="header" href="#24-can-i-use-several-appsinstance-to-manage-my-bot"><em>24. Can I use several apps/instance to manage my bot?</em></a></h3>
<p>You can call API methods (like sending messages) from several instances in parallel<br />
<strong>BUT</strong> only one instance can call method GetUpdates (or else you will receive <em>Telegram API Error 409: Conflict: terminated by other getUpdates request</em>)</p>
<h3 id="25-how-do-i-get-the-user-id-from-a-username"><a class="header" href="#25-how-do-i-get-the-user-id-from-a-username"><em>25. How do I get the user id from a username?</em></a></h3>
<p>You can't with Bot API but it's possible with <a href="https://www.nuget.org/packages/WTelegramBot">WTelegramBot</a>.<br />
Alternatively, you could store in database the mapping of <code>UserId</code>&lt;-&gt;<code>Username</code>.<br />
Remember that not every user has a username.</p>
<h3 id="26-how-to-receive-messages-from-channels"><a class="header" href="#26-how-to-receive-messages-from-channels"><em>26. How to receive messages from channels?</em></a></h3>
<p>Your bot has to be added as administrator of the channel.
You will then receive the messages as <code>update.ChannelPost</code> or <code>update.EditedChannelPost</code>.</p>
<h3 id="this-faq-doesnt-have-my-question-on-it"><a class="header" href="#this-faq-doesnt-have-my-question-on-it">This FAQ doesn't have my question on it</a></h3>
<p>Feel free to <a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA">join our Telegram group</a> and ask your question there</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
