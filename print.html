<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A guide to Telegram.Bot library</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
                <!-- Google tag (gtag.js) -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-B8JVQVCBTX"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());
        
                  gtag('config', 'G-B8JVQVCBTX');
                </script>
                <!--  -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="1/example-bot.html"><strong aria-hidden="true">1.2.</strong> Example - First Chat Bot</a></li></ol></li><li class="chapter-item expanded "><a href="2/index.html"><strong aria-hidden="true">2.</strong> Beginner</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2/send-msg/index.html"><strong aria-hidden="true">2.1.</strong> Sending Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2/send-msg/text-msg.html"><strong aria-hidden="true">2.1.1.</strong> Text</a></li><li class="chapter-item expanded "><a href="2/send-msg/photo-sticker-msg.html"><strong aria-hidden="true">2.1.2.</strong> Photo & Sticker</a></li><li class="chapter-item expanded "><a href="2/send-msg/audio-voice-msg.html"><strong aria-hidden="true">2.1.3.</strong> Audio & Voice</a></li><li class="chapter-item expanded "><a href="2/send-msg/video-video_note-msg.html"><strong aria-hidden="true">2.1.4.</strong> Video & Video Note</a></li><li class="chapter-item expanded "><a href="2/send-msg/album-msg.html"><strong aria-hidden="true">2.1.5.</strong> Album (Media Group)</a></li><li class="chapter-item expanded "><a href="2/send-msg/document-animation-msg.html"><strong aria-hidden="true">2.1.6.</strong> Document & Animation</a></li><li class="chapter-item expanded "><a href="2/send-msg/native-polls-msg.html"><strong aria-hidden="true">2.1.7.</strong> Native Polls</a></li><li class="chapter-item expanded "><a href="2/send-msg/other-msg.html"><strong aria-hidden="true">2.1.8.</strong> Other Messages</a></li></ol></li><li class="chapter-item expanded "><a href="2/reply-markup.html"><strong aria-hidden="true">2.2.</strong> Reply Markup</a></li></ol></li><li class="chapter-item expanded "><a href="3/index.html"><strong aria-hidden="true">3.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/updates/index.html"><strong aria-hidden="true">3.1.</strong> Getting Updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/updates/polling.html"><strong aria-hidden="true">3.1.1.</strong> Long Polling</a></li><li class="chapter-item expanded "><a href="3/updates/webhook.html"><strong aria-hidden="true">3.1.2.</strong> Webhooks</a></li></ol></li><li class="chapter-item expanded "><a href="3/inline.html"><strong aria-hidden="true">3.2.</strong> Inline Mode</a></li><li class="chapter-item expanded "><a href="3/files/index.html"><strong aria-hidden="true">3.3.</strong> Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/files/download.html"><strong aria-hidden="true">3.3.1.</strong> Download</a></li><li class="chapter-item expanded "><a href="3/files/upload.html"><strong aria-hidden="true">3.3.2.</strong> Upload</a></li></ol></li><li class="chapter-item expanded "><a href="3/sticker.html"><strong aria-hidden="true">3.4.</strong> Stickers</a></li></ol></li><li class="chapter-item expanded "><a href="4/index.html"><strong aria-hidden="true">4.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4/proxy.html"><strong aria-hidden="true">4.1.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="4/passport/index.html"><strong aria-hidden="true">4.2.</strong> Passport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4/passport/quickstart.html"><strong aria-hidden="true">4.2.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="4/passport/files-docs.html"><strong aria-hidden="true">4.2.2.</strong> Files & Documents</a></li><li class="chapter-item expanded "><a href="4/passport/errors.html"><strong aria-hidden="true">4.2.3.</strong> Data Errors</a></li><li class="chapter-item expanded "><a href="4/passport/key.html"><strong aria-hidden="true">4.2.4.</strong> RSA Key</a></li><li class="chapter-item expanded "><a href="4/passport/faq.html"><strong aria-hidden="true">4.2.5.</strong> Decryption FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="4/login-widget.html"><strong aria-hidden="true">4.3.</strong> Login Widget</a></li><li class="chapter-item expanded "><a href="4/tests.html"><strong aria-hidden="true">4.4.</strong> Systems Integration Tests</a></li><li class="chapter-item expanded "><a href="4/logging.html"><strong aria-hidden="true">4.5.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-14.x.html"><strong aria-hidden="true">5.</strong> Migration guide =&gt; v14</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-17.x.html"><strong aria-hidden="true">6.</strong> Migration guide =&gt; v17</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-18.x.html"><strong aria-hidden="true">7.</strong> Migration guide =&gt; v18</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-19.x.html"><strong aria-hidden="true">8.</strong> Migration guide =&gt; v19</a></li><li class="chapter-item expanded "><a href="Migration-Guide-to-Version-21.x.html"><strong aria-hidden="true">9.</strong> Migration guide =&gt; v21</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">10.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A guide to Telegram.Bot library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TelegramBots/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="telegram-bots-book"><a class="header" href="#telegram-bots-book">Telegram Bots Book</a></h1>
<p><a href="https://nuget.voids.site/packages/Telegram.Bot"><img src="https://img.shields.io/nuget/dt/Telegram.Bot.svg?style=flat-square" alt="NuGet" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot"><img src="https://img.shields.io/github/stars/TelegramBots/Telegram.Bot.svg?style=social&amp;label=Stars" alt="Repository" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot"><strong>Telegram.Bot</strong></a> is the most popular .NET Client for <a href="https://core.telegram.org/bots/api">Telegram Bot API</a>.</p>
<p>The Bot API is an HTTP-based interface created for developers keen on building bots for <a href="https://www.telegram.org/">Telegram</a>.
Check <a href="https://core.telegram.org/bots"><em>Bots: An introduction for developers</em></a> to understand what a Telegram bot is and what it can do.</p>
<p>We, the <a href="https://github.com/orgs/TelegramBots/people">Telegram Bots team</a>, mainly focus on developing multiple <a href="https://www.nuget.org/profiles/TelegramBots">NuGet packages</a> for creating chatbots.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Packages</th><th style="text-align: center">Team</th><th style="text-align: center">News Channel</th><th style="text-align: center">Group Chat</th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="https://nuget.voids.site/packages/Telegram.Bot"><img src="1/docs/logo-nuget.png" alt="Packages" /></a></td><td style="text-align: center"><a href="https://github.com/orgs/TelegramBots/people"><img src="1/docs/logo-gh.png" alt="Team" /></a></td><td style="text-align: center"><a href="https://t.me/s/tgbots_dotnet"><img src="1/docs/logo-channel.jpg" alt="News Channel" /></a></td><td style="text-align: center"><a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA"><img src="1/docs/logo-chat.jpg" alt="Group Chat" /></a></td></tr>
<tr><td style="text-align: center">Our nuget package feed</td><td style="text-align: center">The team contributing to this work</td><td style="text-align: center">Subscribe to <a href="https://t.me/tgbots_dotnet"><code>@tgbots_dotnet</code></a> channel to get our latest news</td><td style="text-align: center"><a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA">Join our chat</a> to talk about bots and ask questions</td></tr>
</tbody></table>
</div>
<h2 id="ℹ-what-is-this-book-for"><a class="header" href="#ℹ-what-is-this-book-for">ℹ️ What Is This Book For</a></h2>
<p>All Bot API methods are already documented by Telegram<sup class="footnote-reference"><a href="#1">1</a></sup> but this book covers all you need to know to create a
chatbot in .NET. There are also many concrete examples written in C#.
The guides here can even be useful to bot developers using other languages/platforms as it shows best practices
in developing Telegram chatbots with examples.</p>
<h2 id="-obtain-latest-versions"><a class="header" href="#-obtain-latest-versions">⚠️ Obtain latest versions</a></h2>
<p>Latest versions of the library are not yet available on Nuget․org due to false-positive malware detection. We are working with Nuget/ESET teams to resolve this issue.</p>
<p>In the mean time, it's available on our <a href="https://nuget.voids.site/packages/Telegram.Bot">special nuget feed</a>: <code>https://nuget.voids.site/v3/index.json</code></p>
<p>Follow the pictures below to configure the Package source in Visual Studio:
<img src="1/docs/NugetPackageManager.jpg" alt="In Visual Studio" />
or alternatively in a <code>nuget.config</code> file:
<img src="1/docs/nuget_config.jpg" alt="In nuget.config file" /></p>
<h2 id="-get-started"><a class="header" href="#-get-started">🔨 Get Started</a></h2>
<p><strong>Begin your bot development journey with the <a href="1/quickstart.html"><em>Quickstart</em></a> guide.</strong></p>
<h2 id="-examples"><a class="header" href="#-examples">🪄 Examples</a></h2>
<p>Check out our <a href="https://github.com/TelegramBots/Telegram.Bot.Examples">examples</a> repository for more.</p>
<h2 id="-correctness--testing"><a class="header" href="#-correctness--testing">✅ Correctness &amp; Testing</a></h2>
<p>This project is fully tested using Unit tests and Systems Integration tests before each release.
In fact, our test cases are self-documenting and serve as examples for Bot API methods.
Once you learn the basics of Telegram chatbots, you will be able to easily understand the code in examples and
use it in your own bot projects.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://core.telegram.org/bots/api">Telegram Bot API</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="bot-father"><a class="header" href="#bot-father">Bot Father</a></h2>
<p>Before you start, you need to talk to <a href="https://t.me/botfather"><code>@BotFather</code></a> on Telegram. <a href="https://core.telegram.org/bots#6-botfather">Create a new
bot</a>, acquire the bot token and get back here.</p>
<p><a href="https://t.me/botfather"><img src="1/docs/logo-bot-father.jpg" alt="Bot Father" /></a></p>
<p>Bot token is a key that required to authorize the bot and send requests to the Bot API. Keep your token secure and store it safely, it can be used to control your bot. It should look like this:</p>
<pre><code class="language-text">1234567:4TT8bAc8GHUspu3ERYn-KGcvsvGB9u_n4ddy
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Now that you have a bot, it's time to bring it to life! Create a new console project for your bot.
It could be a legacy project targeting .NET Framework 4.6.1-4.8 or a modern .NET Core 3.1-.NET 5+.</p>
<blockquote>
<p>Examples in this guide target .NET 6, but earlier targets should work as well (including .NET Framework).</p>
</blockquote>
<pre><code class="language-bash">dotnet new console
</code></pre>
<p>Add a reference to <a href="https://www.nuget.org/packages/Telegram.Bot"><code>Telegram.Bot</code></a> package:</p>
<pre><code class="language-bash">dotnet add package Telegram.Bot
</code></pre>
<p>This code fetches Bot information based on its access token by calling the Bot API <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method. Open <code>Program.cs</code> and use the following content:</p>
<blockquote>
<p>⚠️ Replace <code>{YOUR_ACCESS_TOKEN_HERE}</code> with your access token from the <a href="https://t.me/botfather"><code>@BotFather</code></a>.</p>
</blockquote>
<pre><code class="language-c#">using Telegram.Bot;

var botClient = new TelegramBotClient(&quot;{YOUR_ACCESS_TOKEN_HERE}&quot;);

var me = await botClient.GetMeAsync();
Console.WriteLine($&quot;Hello, World! I am user {me.Id} and my name is {me.FirstName}.&quot;);
</code></pre>
<p>Running the program gives you the following output:</p>
<pre><code class="language-bash">dotnet run
</code></pre>
<pre><code class="language-text">Hello, World! I am user 1234567 and my name is Awesome Bot.
</code></pre>
<p>Great! This bot is self-aware. To make the bot interact with a user, head to the <a href="1/example-bot.html">next page</a>.</p>
<!-- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="example---first-chat-bot"><a class="header" href="#example---first-chat-bot">Example - First Chat Bot</a></h1>
<p>On the <a href="1/quickstart.html">previous page</a> we got an access token and used the <a href="https://core.telegram.org/bots/api#getme"><code>getMe</code></a> method to check our setup.
Now, it is time to make an <em>interactive</em> bot that gets users' messages and replies to them like in this screenshot:</p>
<p><img src="1/docs/shot-example_bot.jpg" alt="Example Image" /></p>
<p>Copy the following code to <code>Program.cs</code>.</p>
<blockquote>
<p>⚠️ Replace <code>{YOUR_ACCESS_TOKEN_HERE}</code> with the access token from the [<code>@BotFather</code>].</p>
</blockquote>
<pre><code class="language-c#">using Telegram.Bot;
using Telegram.Bot.Exceptions;
using Telegram.Bot.Polling;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;

var botClient = new TelegramBotClient(&quot;{YOUR_ACCESS_TOKEN_HERE}&quot;);

using CancellationTokenSource cts = new ();

// StartReceiving does not block the caller thread. Receiving is done on the ThreadPool.
 ReceiverOptions receiverOptions = new ()
{
    AllowedUpdates = Array.Empty&lt;UpdateType&gt;() // receive all update types except ChatMember related updates
};

botClient.StartReceiving(
    updateHandler: HandleUpdateAsync,
    pollingErrorHandler: HandlePollingErrorAsync,
    receiverOptions: receiverOptions,
    cancellationToken: cts.Token
);

var me = await botClient.GetMeAsync();

Console.WriteLine($&quot;Start listening for @{me.Username}&quot;);
Console.ReadLine();

// Send cancellation request to stop bot
cts.Cancel();

async Task HandleUpdateAsync(ITelegramBotClient botClient, Update update, CancellationToken cancellationToken)
{
    // Only process Message updates: https://core.telegram.org/bots/api#message
    if (update.Message is not { } message)
        return;
    // Only process text messages
    if (message.Text is not { } messageText)
        return;

    var chatId = message.Chat.Id;

    Console.WriteLine($&quot;Received a '{messageText}' message in chat {chatId}.&quot;);

    // Echo received message text
    Message sentMessage = await botClient.SendTextMessageAsync(
        chatId: chatId,
        text: &quot;You said:\n&quot; + messageText,
        cancellationToken: cancellationToken);
}

Task HandlePollingErrorAsync(ITelegramBotClient botClient, Exception exception, CancellationToken cancellationToken)
{
    var ErrorMessage = exception switch
    {
        ApiRequestException apiRequestException
            =&gt; $&quot;Telegram API Error:\n[{apiRequestException.ErrorCode}]\n{apiRequestException.Message}&quot;,
        _ =&gt; exception.ToString()
    };

    Console.WriteLine(ErrorMessage);
    return Task.CompletedTask;
}
</code></pre>
<p>Run the program:</p>
<pre><code class="language-bash">dotnet run
</code></pre>
<p>It runs waiting for text messages unless forcefully stopped by pressing Enter. Open a private chat with your bot in
Telegram and send a text message to it. Bot should reply in no time.</p>
<p>By invoking <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Polling/blob/master/src/Telegram.Bot.Extensions.Polling/Extensions/TelegramBotClientPollingExtensions.cs"><code>StartReceiving(...)</code></a> bot client starts fetching updates using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method for the bot
from Telegram servers. This operation does not block the caller thread, because it is done on the ThreadPool. We use <code>Console.ReadLine()</code> to keep the app running.</p>
<p>When user sends a message, the <code>HandleUpdateAsync(...)</code> method gets invoked with the <code>Update</code> object passed as an argument.
We check <code>Message.Type</code> and skip the rest if it is not a text message.
Finally, we send a text message back to the same chat we got the message from.</p>
<p>The <code>HandlePollingErrorAsync(...)</code> method is invoked in case of an error that occurred while fetching updates.</p>
<p>If you take a look at the console, the program outputs the <code>chatId</code> value. <strong>Copy the chat id number</strong> to make testing easier
for yourself on the next pages.</p>
<pre><code class="language-text">Received a 'text' message in chat 123456789.
</code></pre>
<!-- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="beginner"><a class="header" href="#beginner">Beginner</a></h1>
<ul>
<li><a href="2/send-msg/">Sending Messages</a>
<ul>
<li><a href="2/send-msg/text-msg.html">Text</a></li>
<li><a href="2/send-msg/photo-sticker-msg.html">Photo &amp; Sticker</a></li>
<li><a href="2/send-msg/audio-voice-msg.html">Audio &amp; Voice</a></li>
<li><a href="2/send-msg/video-video_note-msg.html">Video &amp; Video Note</a></li>
<li><a href="2/send-msg/album-msg.html">Album (Media Group)</a></li>
<li><a href="2/send-msg/document-animation-msg.html">Document &amp; Animation</a></li>
<li><a href="2/send-msg/other-msg.html">Other Messages</a></li>
</ul>
</li>
<li><a href="2/reply-markup.html">Reply Markup</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-messages"><a class="header" href="#sending-messages">Sending Messages</a></h1>
<p>There are many different types of message that a bot can send.
Fortunately, methods for sending such messages are similar. Take a look at these examples:</p>
<h2 id="sending-text-message"><a class="header" href="#sending-text-message">Sending text message</a></h2>
<p><img src="2/send-msg/../docs/shot-text_msg.jpg" alt="text message screenshot" /></p>
<pre><code class="language-c#">Message message = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Hello, World!&quot;,
    cancellationToken: cancellationToken);
</code></pre>
<h2 id="sending-sticker-message"><a class="header" href="#sending-sticker-message">Sending sticker message</a></h2>
<p><img src="2/send-msg/../docs/shot-sticker.jpg" alt="sticker message screenshot" /></p>
<pre><code class="language-c#">Message message = await botClient.SendStickerAsync(
    chatId: chatId,
    sticker: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/sticker-dali.webp&quot;),
    cancellationToken: cancellationToken);
</code></pre>
<h2 id="sending-video-message"><a class="header" href="#sending-video-message">Sending video message</a></h2>
<p><img src="2/send-msg/../docs/shot-video.jpg" alt="video message screenshot" /></p>
<pre><code class="language-c#">Message message = await botClient.SendVideoAsync(
    chatId: chatId,
    video: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/video-bulb.mp4&quot;),
    cancellationToken: cancellationToken);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-messages-and-more"><a class="header" href="#text-messages-and-more">Text Messages and More</a></h1>
<p><a href="https://core.telegram.org/bots/api#sendmessage"><img src="https://img.shields.io/badge/Bot_API_method-sendMessage-blue.svg?style=flat-square" alt="send message method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/TextMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Text_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Text is a powerful interface for your bot and <a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> probably is the most used method of the Telegram Bot API.
Text messages are easy to send and fast to display on devices with slower networking.
<em>Don't send boring plain text to users all the time</em>. Telegram allows you to format the text using Markdown or HTML.</p>
<h2 id="send-text-message"><a class="header" href="#send-text-message">Send Text Message</a></h2>
<p>The code snippet below sends a message with multiple parameters that looks like this:</p>
<p><img src="2/send-msg/../docs/shot-text_msg2.jpg" alt="text message screenshot" /></p>
<blockquote>
<p>You can use this code snippet in the event handler from Example Bot page and use <code>chatId</code>
or put the <code>chatId</code> value if you know it.</p>
</blockquote>
<pre><code class="language-c#">Message message = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Trying *all the parameters* of `sendMessage` method&quot;,
    parseMode: ParseMode.MarkdownV2,
    disableNotification: true,
    replyToMessageId: update.Message.MessageId,
    replyMarkup: new InlineKeyboardMarkup(
        InlineKeyboardButton.WithUrl(
            text: &quot;Check sendMessage method&quot;,
            url: &quot;https://core.telegram.org/bots/api#sendmessage&quot;)),
    cancellationToken: cancellationToken);
</code></pre>
<p>The method <code>SendTextMessageAsync</code> of .NET Bot Client maps to <a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> on Telegram's Bot API. This method sends a
text message and returns the message object sent.</p>
<p><code>text</code> is written in <a href="https://core.telegram.org/bots/api#markdown-style">MarkDown format</a> and <code>parseMode</code> indicates that. You can also write in HTML or plain text.</p>
<p>By passing <code>disableNotification</code> we tell Telegram client on user's device not to show/sound a notification.</p>
<p>It's a good idea to make it clear to a user the reason why the bot is sending this message and that's why we pass the user's
message id for <code>replyToMessageId</code>.</p>
<p>You have the option of specifying a <code>replyMarkup</code> when sending messages.
Reply markups are explained in details later in this book.
Here we used an <em>Inline Keyboard Markup</em> with a button that attaches to the message itself. Clicking that opens
<a href="https://core.telegram.org/bots/api#sendmessage"><code>sendMessage</code></a> method documentation in the browser.</p>
<h2 id="the-sent-message"><a class="header" href="#the-sent-message">The Sent Message</a></h2>
<p>Almost all of the methods for sending messages return you the message you just sent. Let's have a look at this object. Add this statement after the previous code.</p>
<pre><code class="language-c#">Console.WriteLine(
    $&quot;{message.From.FirstName} sent message {message.MessageId} &quot; +
    $&quot;to chat {message.Chat.Id} at {message.Date}. &quot; +
    $&quot;It is a reply to message {message.ReplyToMessage.MessageId} &quot; +
    $&quot;and has {message.Entities.Length} message entities.&quot;);
</code></pre>
<p>Output should look similar to this:</p>
<pre><code class="language-text">Awesome bot sent message 123 to chat 123456789 at 8/21/18 11:25:09 AM. It is a reply to message 122 and has 2 message entities.
</code></pre>
<p>There are a few things to note.</p>
<p>Date and time is in <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC format</a> and not your local timezone.
Convert it to local time by calling <code>message.Date.ToLocalTime()</code> method.</p>
<p><a href="https://core.telegram.org/bots/api#messageentity">Message Entity</a> refers to those formatted parts of the text: <em>all the parameters</em> in bold and
<em>sendMessage</em> in mono-width font.
Property <code>message.Entities</code> holds the formatting information and <code>message.EntityValues</code> gives you the actual value.
For example, in the message we just sent:</p>
<pre><code class="language-c#">message.Entities.First().Type == MessageEntityType.Bold
message.EntityValues.First()  == &quot;all the parameters&quot;
</code></pre>
<p>Currently, message object doesn't contain information about its reply markup.</p>
<p>Try putting a breakpoint in the code to examine all the properties on a message objects you get.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="photo-and-sticker-messages"><a class="header" href="#photo-and-sticker-messages">Photo and Sticker Messages</a></h1>
<p>You can provide the source file for almost all multimedia messages (e.g. photo, video) in 3 ways:</p>
<ul>
<li>Uploading a file with the HTTP request</li>
<li>HTTP URL for Telegram to get a file from the internet</li>
<li><code>file_id</code> of an existing file on Telegram servers (<em>recommended</em>)</li>
</ul>
<p>Examples in this section show all three.
You will learn more about them later on when we discuss file <a href="2/send-msg/../../3/files/upload.html">upload</a> and <a href="2/send-msg/../../3/files/download.html">download</a>.</p>
<h2 id="photo"><a class="header" href="#photo">Photo</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendphoto"><img src="https://img.shields.io/badge/Bot_API_method-sendPhoto-blue.svg?style=flat-square" alt="send photo method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingPhotoMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Photo_Messages-green.svg?style=flat-square" alt="photo tests" /></a></p>
<p>Sending a photo is simple. Here is an example:</p>
<pre><code class="language-c#">Message message = await botClient.SendPhotoAsync(
    chatId: chatId,
    photo: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/photo-ara.jpg&quot;),
    caption: &quot;&lt;b&gt;Ara bird&lt;/b&gt;. &lt;i&gt;Source&lt;/i&gt;: &lt;a href=\&quot;https://pixabay.com\&quot;&gt;Pixabay&lt;/a&gt;&quot;,
    parseMode: ParseMode.Html,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-photo_msg.jpg" alt="photo message" /></p>
<h3 id="caption"><a class="header" href="#caption">Caption</a></h3>
<p>Multimedia messages can <em>optionally</em> have a caption attached to them. Here we sent a caption in HTML format.
A user can click on <em>Pixabay</em> in the caption to open its URL in the browser.</p>
<p>Similar to message entities discussed before, caption entities on <a href="https://core.telegram.org/bots/api#message"><code>Message</code></a> object are the result of
parsing formatted(Markdown or HTML) caption text.
Try inspecting these properties in debug mode:</p>
<ul>
<li><code>message.Caption</code>: caption in plain text without formatting</li>
<li><code>message.CaptionEntities</code>: info about special entities in the caption</li>
<li><code>message.CaptionEntityValues</code>: text values of mentioned entities</li>
</ul>
<h3 id="photo-message"><a class="header" href="#photo-message">Photo Message</a></h3>
<p>The <code>message</code> returned from this method represents a <em>photo message</em> because <code>message.Photo</code> has a value.
Its value is a <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> array with each element representing the same photo in different dimensions.
If your bot needs to send this photo again at some point, it is recommended to store this array
so you can reuse the <code>file_id</code> value.</p>
<p>Here is how <code>message.Photo</code> array looks like in JSON:</p>
<pre><code class="language-json">[
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABCQawlb-dBXqBZUEAAEC&quot;,
    &quot;file_size&quot;: 1254,
    &quot;width&quot;: 90,
    &quot;height&quot;: 60
  },
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABAKByRnc22RmBpUEAAEC&quot;,
    &quot;file_size&quot;: 16419,
    &quot;width&quot;: 320,
    &quot;height&quot;: 213
  },
  {
    &quot;file_id&quot;: &quot;AgADBAADDqgxG-QDDVCm5JVvld7MN0z6kBkABHezqGiNOz9yB5UEAAEC&quot;,
    &quot;file_size&quot;: 57865,
    &quot;width&quot;: 640,
    &quot;height&quot;: 426
  }
]
</code></pre>
<h2 id="sticker"><a class="header" href="#sticker">Sticker</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendsticker"><img src="https://img.shields.io/badge/Bot_API_method-sendSticker-blue.svg?style=flat-square" alt="send sticker method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Stickers/StickersTests.cs"><img src="https://img.shields.io/badge/Examples-Sticker_Messages-green.svg?style=flat-square" alt="sticker tests" /></a></p>
<p>Telegram stickers are fun and our bot is about to send its very first sticker.
Sticker files should be in <a href="https://developers.google.com/speed/webp/">WebP</a> format.</p>
<p>This code sends the same sticker twice. First by passing HTTP URL to a <a href="https://developers.google.com/speed/webp/">WebP</a> sticker file and
second by reusing <code>FileId</code> of the same sticker on Telegram servers.</p>
<pre><code class="language-c#">Message message1 = await botClient.SendStickerAsync(
    chatId: chatId,
    sticker: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/sticker-fred.webp&quot;),
    cancellationToken: cancellationToken);

Message message2 = await botClient.SendStickerAsync(
    chatId: chatId,
    sticker: InputFile.FromFileId(message1.Sticker!.FileId),
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-sticker_msgs.jpg" alt="sticker messages" /></p>
<p>Try inspecting the <code>sticker1.Sticker</code> property. It is of type <a href="https://core.telegram.org/bots/api#sticker"><code>Sticker</code></a> and its schema looks similar to a photo.</p>
<blockquote>
<p>There is more to stickers and we will talk about them in greater details later.</p>
</blockquote>
<!-- -------------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-and-voice-messages"><a class="header" href="#audio-and-voice-messages">Audio and Voice Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AudioMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Audio_Messages-green.svg?style=flat-square" alt="audio tests" /></a></p>
<p>These two types of messages are pretty similar. Audio is MP3-encoded file that can be played in music player.
A voice file has OGG format and is not shown in music player.</p>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendaudio"><img src="https://img.shields.io/badge/Bot_API_method-sendAudio-blue.svg?style=flat-square" alt="send audio method" /></a></p>
<p>This is the code to send an MP3 soundtrack. You might be wondering why some parameters are commented out?
That's because this MP3 file has metadata on it and Telegram does a good job at reading it.</p>
<pre><code class="language-c#">Message message = await botClient.SendAudioAsync(
    chatId: chatId,
    audio: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/audio-guitar.mp3&quot;),
    /*
    performer: &quot;Joel Thomas Hunger&quot;,
    title: &quot;Fun Guitar and Ukulele&quot;,
    duration: 91, // in seconds
    */
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-audio_msg.jpg" alt="audio message" /></p>
<p>And a user can see the audio in Music Player:</p>
<p><img src="2/send-msg/../docs/shot-music_player.jpg" alt="music player" /></p>
<p>Method returns an audio message. Let's take a look at the value of <code>message.Audio</code> property in JSON format:</p>
<pre><code class="language-json">{
  &quot;duration&quot;: 91,
  &quot;mime_type&quot;: &quot;audio/mpeg&quot;,
  &quot;title&quot;: &quot;Fun Guitar and Ukulele&quot;,
  &quot;performer&quot;: &quot;Joel Thomas Hunger&quot;,
  &quot;file_id&quot;: &quot;CQADBAADKQADA3oUUKalqDOOcqesAg&quot;,
  &quot;file_size&quot;: 1102154
}
</code></pre>
<h2 id="voice"><a class="header" href="#voice">Voice</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvoice"><img src="https://img.shields.io/badge/Bot_API_method-sendVoice-blue.svg?style=flat-square" alt="send voice method" /></a></p>
<p>A voice message is an OGG audio file.
Let's send it differently this time by uploading the file from disk alongside with an HTTP request.</p>
<p>To run this example, download the <a href="https://raw.githubusercontent.com/TelegramBots/book/master/src/docs/voice-nfl_commentary.ogg">NFL Commentary voice file</a> to your disk.</p>
<p>A value is passed for <code>duration</code> because Telegram can't figure that out from a file's metadata.</p>
<blockquote>
<p>⚠️ Replace <code>/path/to/voice-nfl_commentary.ogg</code> with an actual file path.</p>
</blockquote>
<pre><code class="language-c#">await using Stream stream = System.IO.File.OpenRead(&quot;/path/to/voice-nfl_commentary.ogg&quot;);
Message message = await botClient.SendVoiceAsync(
    chatId: chatId,
    voice: InputFile.FromStream(stream),
    duration: 36,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-voice_msg.jpg" alt="voice message" /></p>
<p>A voice message is returned from the method. Inspect the <code>message.Voice</code> property to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="video-and-video-note-messages"><a class="header" href="#video-and-video-note-messages">Video and Video Note Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/VideoMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Video_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>You can send MP4 files as a regular video or a <em>video note</em>.
Other video formats may be sent as documents.</p>
<h2 id="video"><a class="header" href="#video">Video</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvideo"><img src="https://img.shields.io/badge/Bot_API_method-sendVideo-blue.svg?style=flat-square" alt="method sendVideo" /></a></p>
<p>Videos, like other multimedia messages, can have caption, reply, reply markup, and etc.
You can optionally specify the duration and resolution of the video.</p>
<p>In the example below, we send a video of a 10 minute countdown
and expect the Telegram clients to stream that long video instead of downloading it completely.
We also set a thumbnail image for our video.</p>
<pre><code class="language-c#">Message message = await botClient.SendVideoAsync(
    chatId: chatId,
    video: InputFile.FromUri(&quot;https://raw.githubusercontent.com/TelegramBots/book/master/src/docs/video-countdown.mp4&quot;),
    thumbnail: InputFile.FromUri(&quot;https://raw.githubusercontent.com/TelegramBots/book/master/src/2/docs/thumb-clock.jpg&quot;),
    supportsStreaming: true,
    cancellationToken: cancellationToken);
</code></pre>
<blockquote>
<p>Check the Bot API docs for <code>sendVideo</code> method to learn more about video size limits and the thumbnail images.</p>
</blockquote>
<p><img src="2/send-msg/../docs/shot-video_thumb1.jpg" alt="vide screenshot 1" /></p>
<p>User should be able to seek through the video without the video being downloaded completely.</p>
<p><img src="2/send-msg/../docs/shot-video_thumb2.jpg" alt="vide screenshot 2" /></p>
<h2 id="video-note"><a class="header" href="#video-note">Video Note</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvideonote"><img src="https://img.shields.io/badge/Bot_API_method-sendVideoNote-blue.svg?style=flat-square" alt="method sendVideoNote" /></a></p>
<p>Video notes, shown in circles to the user, are usually short (1 minute or less) with the same width and height.</p>
<p>You can send a video note only by uploading the video file or reusing the <code>file_id</code> of another video note.
Sending video note by its HTTP URL is not supported currently.</p>
<p>Download the <a href="https://raw.githubusercontent.com/TelegramBots/book/master/src/docs/video-waves.mp4">Sea Waves video</a> to your disk for this example.</p>
<pre><code class="language-c#">await using Stream stream = System.IO.File.OpenRead(&quot;/path/to/video-waves.mp4&quot;);

Message message = await botClient.SendVideoNoteAsync(
    chatId: chatId,
    videoNote: InputFile.FromStream(stream),
    duration: 47,
    length: 360, // value of width/height
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-video_note.jpg" alt="vide note screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="album-messages"><a class="header" href="#album-messages">Album Messages</a></h1>
<p><a href="https://core.telegram.org/bots/api#sendmediagroup"><img src="https://img.shields.io/badge/Bot_API_method-sendMediaGroup-blue.svg?style=flat-square" alt="send media group method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AlbumMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Album_Messages-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Using <a href="https://core.telegram.org/bots/api#sendmediagroup"><code>sendMediaGroup</code></a> method you can send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type.</p>
<pre><code class="language-c#">Message[] messages = await botClient.SendMediaGroupAsync(
    chatId: chatId,
    media: new IAlbumInputMedia[]
    {
        new InputMediaPhoto(
            InputFile.FromUri(&quot;https://cdn.pixabay.com/photo/2017/06/20/19/22/fuchs-2424369_640.jpg&quot;)),
        new InputMediaPhoto(
            InputFile.FromUri(&quot;https://cdn.pixabay.com/photo/2017/04/11/21/34/giraffe-2222908_640.jpg&quot;)),
    },
    cancellationToken: cancellationToken);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document-and-animation-messages"><a class="header" href="#document-and-animation-messages">Document and Animation Messages</a></h1>
<h2 id="send-documents"><a class="header" href="#send-documents">Send documents</a></h2>
<p><a href="https://core.telegram.org/bots/api#senddocument"><img src="https://img.shields.io/badge/Bot_API_method-sendDocument-blue.svg?style=flat-square" alt="sendDocument method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/DocumentMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Document_Message-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Use <a href="https://core.telegram.org/bots/api#senddocument"><code>sendDocument</code></a> method to send general files.</p>
<pre><code class="language-c#">Message message = await botClient.SendDocumentAsync(
    chatId: chatId,
    document: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/photo-ara.jpg&quot;),
    caption: &quot;&lt;b&gt;Ara bird&lt;/b&gt;. &lt;i&gt;Source&lt;/i&gt;: &lt;a href=\&quot;https://pixabay.com\&quot;&gt;Pixabay&lt;/a&gt;&quot;,
    parseMode: ParseMode.Html,
    cancellationToken: cancellationToken);
</code></pre>
<h2 id="send-animations"><a class="header" href="#send-animations">Send animations</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendanimation"><img src="https://img.shields.io/badge/Bot_API_method-sendAnimation-blue.svg?style=flat-square" alt="sendAnimation method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/AnimationMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Animation_Message-green.svg?style=flat-square" alt="tests" /></a></p>
<p>Use <a href="https://core.telegram.org/bots/api#sendanimation"><code>sendAnimation</code></a> method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).</p>
<pre><code class="language-c#">Message message = await botClient.SendAnimationAsync(
    chatId: chatId,
    animation: InputFile.FromUri(&quot;https://raw.githubusercontent.com/TelegramBots/book/master/src/docs/video-waves.mp4&quot;),
    caption: &quot;Waves&quot;,
    cancellationToken: cancellationToken);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-poll-messages"><a class="header" href="#native-poll-messages">Native Poll Messages</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Polls/AnonymousPollTests.cs"><img src="https://img.shields.io/badge/Examples-Native_Polls-green.svg?style=flat-square" alt="native poll tests" /></a></p>
<p>Just as regular users bots can only send native polls to groups and channels, but not to private chats.</p>
<h2 id="send-a-poll"><a class="header" href="#send-a-poll">Send a poll</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendpoll"><img src="https://img.shields.io/badge/Bot_API_method-sendPoll-blue.svg?style=flat-square" alt="sendPoll method" /></a></p>
<p>This is the code to send a poll to a chat.</p>
<pre><code class="language-c#">Message pollMessage = await botClient.SendPollAsync(
    chatId: &quot;@channel_name&quot;,
    question: &quot;Did you ever hear the tragedy of Darth Plagueis The Wise?&quot;,
    options: new[]
    {
        &quot;Yes for the hundredth time!&quot;,
        &quot;No, who`s that?&quot;
    },
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-native_poll_msg.jpeg" alt="native poll" /></p>
<p>You can optionally send a keyboard with a poll, both an inline or a regular one.</p>
<p>You'll get the message with <a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/src/Telegram.Bot/Types/Poll.cs"><code>Poll</code></a> object inside it.</p>
<h2 id="stop-a-poll"><a class="header" href="#stop-a-poll">Stop a poll</a></h2>
<p><a href="https://core.telegram.org/bots/api#stoppoll"><img src="https://img.shields.io/badge/Bot_API_method-stopPoll-blue.svg?style=flat-square" alt="stopPoll method" /></a></p>
<p>To close a poll you need to know original chat and message ids of the poll that you got from calling <code>SendPollAsync</code> method.</p>
<p>Let's close the poll that we sent in the previous example:</p>
<pre><code class="language-c#">Poll poll = await botClient.StopPollAsync(
    chatId: pollMessage.Chat.Id,
    messageId: pollMessage.MessageId,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-native_poll_closed.jpeg" alt="closed native poll" /></p>
<p>You can add an inline keyboard when you close a poll.</p>
<p>As a result of the request you'll get the the final poll state with property <code>Poll.IsClosed</code> set to true.</p>
<p>If you'll try to close a forwarded poll using message and chat ids from the received message even if your bot is the author of the poll you'll get an <code>ApiRequestException</code> with message <code>Bad Request: poll can't be stopped</code>. Polls originated from channels is an exception since forwarded messages originated from channels contain original chat and message ids inside properties <code>Message.ForwardFromChat.Id</code> and <code>Message.ForwardFromMessageId</code>.</p>
<p>Also if you'll try to close an already closed poll you'll get <code>ApiRequestException</code> with message <code>Bad Request: poll has already been closed</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-messages"><a class="header" href="#other-messages">Other Messages</a></h1>
<p>There are other kind of message types which are supported by the client. In the following paragraphs we will look how to send contacts, venues or locations.</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendcontact"><img src="https://img.shields.io/badge/Bot_API_method-sendContact-blue.svg?style=flat-square" alt="send contact method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingContactMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Contact-green.svg?style=flat-square" alt="send contacts tests" /></a></p>
<p>This is the code to send a contact. Mandatory are the parameters <code>chatId</code>, <code>phoneNumber</code> and <code>firstName</code>.</p>
<pre><code class="language-c#">Message message = await botClient.SendContactAsync(
    chatId: chatId,
    phoneNumber: &quot;+1234567890&quot;,
    firstName: &quot;Han&quot;,
    lastName: &quot;Solo&quot;,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-contact.jpg" alt="send contact" /></p>
<p>If you want to send a contact as vCard you can achieve  this by adding a valid vCard <code>string</code> as value for the optional parameter <code>vCard</code> as seen in the given example below.</p>
<pre><code class="language-c#">Message message = await botClient.SendContactAsync(
    chatId: chatId,
    phoneNumber: &quot;+1234567890&quot;,
    firstName: &quot;Han&quot;,
    vCard: &quot;BEGIN:VCARD\n&quot; +
           &quot;VERSION:3.0\n&quot; +
           &quot;N:Solo;Han\n&quot; +
           &quot;ORG:Scruffy-looking nerf herder\n&quot; +
           &quot;TEL;TYPE=voice,work,pref:+1234567890\n&quot; +
           &quot;EMAIL:hansolo@mfalcon.com\n&quot; +
           &quot;END:VCARD&quot;,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-contact_vcard.jpg" alt="send vcard" /></p>
<h2 id="venue"><a class="header" href="#venue">Venue</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendvenue"><img src="https://img.shields.io/badge/Bot_API_method-sendVenue-blue.svg?style=flat-square" alt="send venue method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingVenueMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Venue-green.svg?style=flat-square" alt="send venue tests" /></a></p>
<p>The code snippet below sends a venue with a title and a address as given parameters:</p>
<pre><code class="language-c#">Message message = await botClient.SendVenueAsync(
    chatId: chatId,
    latitude: 50.0840172f,
    longitude: 14.418288f,
    title: &quot;Man Hanging out&quot;,
    address: &quot;Husova, 110 00 Staré Město, Czechia&quot;,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-venue.jpg" alt="send contact" /></p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendlocation"><img src="https://img.shields.io/badge/Bot_API_method-sendLocation-blue.svg?style=flat-square" alt="send location method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Sending%20Messages/SendingVenueMessageTests.cs"><img src="https://img.shields.io/badge/Examples-Location-green.svg?style=flat-square" alt="send location tests" /></a></p>
<p>The difference between sending a location and a venue is, that the venue requires a title and address. A location can be any given point as latitude and longitude.</p>
<p>The following snippet shows how to send a location with the mandatory parameters:</p>
<pre><code class="language-c#">Message message = await botClient.SendLocationAsync(
    chatId: chatId,
    latitude: 33.747252f,
    longitude: -112.633853f,
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="2/send-msg/../docs/shot-location.jpg" alt="send contact" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reply-markup"><a class="header" href="#reply-markup">Reply Markup</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/ReplyMarkup/ReplyMarkupTests.cs"><img src="https://img.shields.io/badge/Examples-Reply_Markup-green.svg?style=flat-square" alt="reply markup tests" /></a></p>
<p>Telegram provides two types of reply markup: <a href="2/reply-markup.html#custom-keyboards">Custom keyboards</a> and <a href="2/reply-markup.html#inline-keyboards">Inline keyboards</a>.</p>
<h2 id="custom-keyboards"><a class="header" href="#custom-keyboards">Custom keyboards</a></h2>
<p>Whenever your bot sends a message, it can pass along a <a href="https://core.telegram.org/bots#keyboards">special keyboard</a> with predefined reply options. Regular keyboards are represented by <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> object. You can request a contact or location information from the user with <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> or send a poll. Regular button will send predefined text to the chat.</p>
<p>Keyboard is an array of button rows, each represented by an array of <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> objects. <a href="https://core.telegram.org/bots/api/#keyboardbutton"><code>KeyboardButton</code></a> supports text and emoji.</p>
<p>By default, custom keyboards are displayed until a new keyboard is sent by a bot.</p>
<h3 id="single-row-keyboard-markup"><a class="header" href="#single-row-keyboard-markup">Single-row keyboard markup</a></h3>
<p>A <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> with two buttons in a single row:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

ReplyKeyboardMarkup replyKeyboardMarkup = new(new[]
{
    new KeyboardButton[] { &quot;Help me&quot;, &quot;Call me ☎️&quot; },
})
{
    ResizeKeyboard = true
};

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Choose a response&quot;,
    replyMarkup: replyKeyboardMarkup,
    cancellationToken: cancellationToken);
</code></pre>
<blockquote>
<p>We specify <code>ResizeKeyboard = true</code> here to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons).</p>
</blockquote>
<h3 id="multi-row-keyboard-markup"><a class="header" href="#multi-row-keyboard-markup">Multi-row keyboard markup</a></h3>
<p>A <a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> with two rows of buttons:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

ReplyKeyboardMarkup replyKeyboardMarkup = new(new[]
{
    new KeyboardButton[] { &quot;Help me&quot; },
    new KeyboardButton[] { &quot;Call me ☎️&quot; },
})
{
    ResizeKeyboard = true
};

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Choose a response&quot;,
    replyMarkup: replyKeyboardMarkup,
    cancellationToken: cancellationToken);
</code></pre>
<h3 id="request-information"><a class="header" href="#request-information">Request information</a></h3>
<p><a href="https://core.telegram.org/bots/api/#replykeyboardmarkup"><code>ReplyKeyboardMarkup</code></a> containing buttons for contact and location requests using helper methods <code>KeyboardButton.WithRequestLocation</code> and <code>KeyboardButton.WithRequestContact</code>:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

ReplyKeyboardMarkup replyKeyboardMarkup = new(new[]
{
    KeyboardButton.WithRequestLocation(&quot;Share Location&quot;),
    KeyboardButton.WithRequestContact(&quot;Share Contact&quot;),
});

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Who or Where are you?&quot;,
    replyMarkup: replyKeyboardMarkup,
    cancellationToken: cancellationToken);
</code></pre>
<h3 id="remove-keyboard"><a class="header" href="#remove-keyboard">Remove keyboard</a></h3>
<p>To remove keyboard you have to send an instance of <a href="https://core.telegram.org/bots/api#replykeyboardremove"><code>ReplyKeyboardRemove</code></a> object:</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;Removing keyboard&quot;,
    replyMarkup: new ReplyKeyboardRemove(),
    cancellationToken: cancellationToken);
</code></pre>
<h2 id="inline-keyboards"><a class="header" href="#inline-keyboards">Inline keyboards</a></h2>
<p>There are times when you'd prefer to do things without sending any messages to the chat. For example, when your user is changing settings or flipping through search results. In such cases you can use <a href="https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating">Inline Keyboards</a> that are integrated directly into the messages they belong to.</p>
<p>Unlike custom reply keyboards, pressing buttons on inline keyboards doesn't result in messages sent to the chat. Instead, inline keyboards support buttons that work behind the scenes: <a href="2/reply-markup.html#callback-buttons">callback buttons</a>, <a href="2/reply-markup.html#url-buttons">URL buttons</a> and <a href="2/reply-markup.html#switch-to-inline-buttons">switch to inline buttons</a>.</p>
<h3 id="callback-buttons"><a class="header" href="#callback-buttons">Callback buttons</a></h3>
<p>When a user presses a <a href="https://core.telegram.org/bots/2-0-intro#callback-buttons">callback button</a>, no messages are sent to the chat. Instead, your bot simply receives the relevant query. Upon receiving the query, your bot can display some result in a notification at the top of the chat screen or in an alert. In this example we use <code>InlineKeyboardButton.WithCallbackData</code> helper method to create a button with a text and callback data.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

InlineKeyboardMarkup inlineKeyboard = new(new[]
{
    // first row
    new []
    {
        InlineKeyboardButton.WithCallbackData(text: &quot;1.1&quot;, callbackData: &quot;11&quot;),
        InlineKeyboardButton.WithCallbackData(text: &quot;1.2&quot;, callbackData: &quot;12&quot;),
    },
    // second row
    new []
    {
        InlineKeyboardButton.WithCallbackData(text: &quot;2.1&quot;, callbackData: &quot;21&quot;),
        InlineKeyboardButton.WithCallbackData(text: &quot;2.2&quot;, callbackData: &quot;22&quot;),
    },
});

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: inlineKeyboard,
    cancellationToken: cancellationToken);
</code></pre>
<h3 id="url-buttons"><a class="header" href="#url-buttons">URL buttons</a></h3>
<p>Buttons of this type have a small arrow icon to help the user understand that tapping on a <a href="https://core.telegram.org/bots/2-0-intro#url-buttons">URL button</a> will open an external link. In this example we use <code>InlineKeyboardButton.WithUrl</code> helper method to create a button with a text and url.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

InlineKeyboardMarkup inlineKeyboard = new(new[]
{
    InlineKeyboardButton.WithUrl(
        text: &quot;Link to the Repository&quot;,
        url: &quot;https://github.com/TelegramBots/Telegram.Bot&quot;)
});

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: inlineKeyboard,
    cancellationToken: cancellationToken);
</code></pre>
<h3 id="switch-to-inline-buttons"><a class="header" href="#switch-to-inline-buttons">Switch to Inline buttons</a></h3>
<p>Pressing a <a href="https://core.telegram.org/bots/2-0-intro#switch-to-inline-buttons">switch to inline button</a> prompts the user to select a chat, opens it and inserts the bot's username into the input field. You can also pass a query that will be inserted along with the username – this way your users will immediately get some inline results they can share. In this example we use <code>InlineKeyboardButton.WithSwitchInlineQuery</code> and <code>InlineKeyboardButton.WithSwitchInlineQueryCurrentChat</code> helper methods to create buttons which will insert the bot's username in the chat's input field.</p>
<pre><code class="language-c#">// using Telegram.Bot.Types.ReplyMarkups;

InlineKeyboardMarkup inlineKeyboard = new(new[]
{
    InlineKeyboardButton.WithSwitchInlineQuery(
        text: &quot;switch_inline_query&quot;),
    InlineKeyboardButton.WithSwitchInlineQueryCurrentChat(
        text: &quot;switch_inline_query_current_chat&quot;),
});

Message sentMessage = await botClient.SendTextMessageAsync(
    chatId: chatId,
    text: &quot;A message with an inline keyboard markup&quot;,
    replyMarkup: inlineKeyboard,
    cancellationToken: cancellationToken);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h1>
<ul>
<li><a href="3/updates/">Getting Updates</a>
<ul>
<li><a href="3/updates/polling.html">Long Polling</a></li>
<li><a href="3/updates/webhook.html">Webhooks</a></li>
</ul>
</li>
<li><a href="3/inline.html">Inline Mode</a></li>
<li><a href="3/files/">Files</a>
<ul>
<li><a href="3/files/download.html">Download</a></li>
<li><a href="3/files/upload.html">Upload</a></li>
</ul>
</li>
<li><a href="3/sticker.html">Stickers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-updates"><a class="header" href="#getting-updates">Getting Updates</a></h1>
<p>There are two mutually exclusive ways of receiving updates for your bot — the long polling using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method on one hand and Webhooks on the other. Telegram is queueing updates until the bot receives them either way, but they will not be kept longer than 24 hours.</p>
<ul>
<li>
<p>With long polling, the client requests information from the server using <a href="https://core.telegram.org/bots/api#getupdates"><code>getUpdates</code></a> method, but with the expectation the server may not respond immediately. If the server has no new information for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for response information to become available. Once it does have new information, the server immediately sends a response to the client, completing the request. Upon receipt of the server response, the client often immediately issues another server request.</p>
</li>
<li>
<p><a href="https://core.telegram.org/bots/api#setwebhook">Setting a webhook</a> means you supplying Telegram with a location in the form of an URL, on which your bot listens for updates. Telegram need to be able to connect and post updates to that URL.
To be able to handle webhook updates you'll need a server that:</p>
<ul>
<li>Supports IPv4, IPv6 is currently not supported for webhooks.</li>
<li>Accepts incoming POSTs from subnets 149.154.160.0/20 and 91.108.4.0/22 on port 443, 80, 88, or 8443.</li>
<li>Is able to handle TLS1.2(+) HTTPS-traffic.</li>
<li>Provides a supported, non-wildcard, verified or self-signed certificate.</li>
<li>Uses a CN or SAN that matches the domain you’ve supplied on setup.</li>
<li>Supplies all intermediate certificates to complete a verification chain.</li>
</ul>
<p>You can find more useful information on setting webhook in <a href="https://core.telegram.org/bots/webhooks">Marvin's Marvellous Guide to All Things Webhook</a></p>
</li>
</ul>
<p>Each user interaction with your bot results in new
<a href="https://github.com/Fedorus/Telegram.Bot/blob/master/src/Telegram.Bot/Types/Update.cs">Update</a> object. Its fields will be set depending on update type.</p>
<h2 id="example-projects"><a class="header" href="#example-projects">Example projects</a></h2>
<h3 id="long-polling"><a class="header" href="#long-polling">Long polling</a></h3>
<ul>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Telegram.Bot.Examples.Polling">Simple console application</a>. Demonstrates the use of the <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Polling">Telegram.Bot.Extensions.Polling</a> package.</li>
</ul>
<h3 id="webhook"><a class="header" href="#webhook">Webhook</a></h3>
<ul>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Telegram.Bot.Examples.WebHook">ASP.NET Core</a> application</li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Serverless/Telegram.Bot.Examples.AzureFunctions.WebHook">Azure Functions</a></li>
<li><a href="https://github.com/TelegramBots/Telegram.Bot.Examples/tree/master/Serverless/Telegram.Bot.Examples.AwsLambda.WebHook">AWS Lambda</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="long-polling-1"><a class="header" href="#long-polling-1">Long Polling</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webhooks"><a class="header" href="#webhooks">Webhooks</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-mode"><a class="header" href="#inline-mode">Inline Mode</a></h1>
<p><a href="https://core.telegram.org/bots/api#inline-mode"><img src="https://img.shields.io/badge/Bot_API_Object-Inline%20Mode-blue.svg?style=flat-square" alt="inline mode bot API" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot.Examples/blob/master/Telegram.Bot.Examples.InlineQueries/Program.cs"><img src="https://img.shields.io/badge/Examples-Inline%20Queries-green?style=flat-square" alt="inline queries example" /></a></p>
<p>Telegram bots can be queried directly in the chat or via inline queries.</p>
<p>To use inline queries in your bot, you need to set up inline mode by command:</p>
<p><img src="3/docs/shot-setinline_command.png" alt="/setinline command in BotFather" /></p>
<p>Import <code>Telegram.Bot.Types.InlineQueryResults</code> namespace for inline query types.</p>
<p>There are two types that allow you to work with inline queries - <code>InlineQuery</code> and <code>ChosenInlineResult</code>:</p>
<pre><code class="language-c#">await (update.Type switch
{
    UpdateType.InlineQuery        =&gt; BotOnInlineQueryReceived(bot, update.InlineQuery!),
    UpdateType.ChosenInlineResult =&gt; BotOnChosenInlineResultReceived(bot, update.ChosenInlineResult!),
});
</code></pre>
<h2 id="inlinequery"><a class="header" href="#inlinequery"><code>InlineQuery</code></a></h2>
<p><a href="https://core.telegram.org/bots/api#inlinequeryresult"><img src="https://img.shields.io/badge/Bot_API_Object-InlineQueryResult-blue.svg?style=flat-square" alt="inline query result bot API" /></a></p>
<p>Suppose we have two arrays:</p>
<pre><code class="language-c#">private readonly string[] sites = { &quot;Google&quot;, &quot;Github&quot;, &quot;Telegram&quot;, &quot;Wikipedia&quot; };
private readonly string[] siteDescriptions =
{
    &quot;Google is a search engine&quot;,
    &quot;Github is a git repository hosting&quot;,
    &quot;Telegram is a messenger&quot;,
    &quot;Wikipedia is an open wiki&quot;
};
</code></pre>
<p>So we can handle inline queries this way:</p>
<pre><code class="language-c#">async Task BotOnInlineQueryReceived(ITelegramBotClient bot, InlineQuery inlineQuery)
{
    var results = new List&lt;InlineQueryResult&gt;();

    var counter = 0;
    foreach (var site in sites)
    {
        results.Add(new InlineQueryResultArticle(
            $&quot;{counter}&quot;, // we use the counter as an id for inline query results
            site, // inline query result title
            new InputTextMessageContent(siteDescriptions[counter])) // content that is submitted when the inline query result title is clicked
        );
        counter++;
    }

    await bot.AnswerInlineQueryAsync(inlineQuery.Id, results); // answer by sending the inline query result list
}
</code></pre>
<p><code>InlineQueryResult</code> is an abstract type used to create a response for inline queries. You can use these result types for inline queries: <code>InlineQueryResultArticle</code> for articles, <code>InlineQueryResultPhoto</code> for photos, etc.</p>
<h2 id="choseninlineresult"><a class="header" href="#choseninlineresult"><code>ChosenInlineResult</code></a></h2>
<p><a href="https://core.telegram.org/bots/api#choseninlineresult"><img src="https://img.shields.io/badge/Bot_API_Object-ChosenInlineResult-blue.svg?style=flat-square" alt="chosen inline result bot API" /></a></p>
<p>This type helps to handle chosen inline result. For example, you may want to know which result users chose:</p>
<pre><code class="language-csharp">Task BotOnChosenInlineResultReceived(ITelegramBotClient bot, ChosenInlineResult chosenInlineResult)
{
    if (uint.TryParse(chosenInlineResult.ResultId, out var resultId) // check if a result id is parsable and introduce variable
        &amp;&amp; resultId &lt; sites.Length)
    {
        Console.WriteLine($&quot;User {chosenInlineResult.From} has selected site: {sites[resultId]}&quot;);
    }

    return Task.CompletedTask;
}
</code></pre>
<p>To use the feature you need to enable &quot;inline feedback&quot; in BotFather by <code>/setinlinefeedback</code> command:</p>
<p><img src="3/docs/shot-setinlinefeedback_command.png" alt="set inline feedback command" /></p>
<p>Final result:</p>
<p><img src="3/docs/shot-inline_bot_showcase.png" alt="result" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-files"><a class="header" href="#working-with-files">Working with Files</a></h1>
<ul>
<li><a href="3/files/download.html">Download files</a></li>
<li><a href="3/files/upload.html">Upload files</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downloading-files"><a class="header" href="#downloading-files">Downloading files</a></h1>
<p>First, read the <a href="https://core.telegram.org/bots/api#getfile">documentation on <code>getFile</code></a> method.</p>
<p>To download file you have to know its file identifier - <code>FileId</code>.</p>
<h2 id="finding-the-file-identifier"><a class="header" href="#finding-the-file-identifier">Finding the file identifier</a></h2>
<p>Telegram Bot API has several object types, representing file:
<a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a>, <a href="https://core.telegram.org/bots/api#animation"><code>Animation</code></a>, <a href="https://core.telegram.org/bots/api#audio"><code>Audio</code></a>, <a href="https://core.telegram.org/bots/api#document"><code>Document</code></a>, <a href="https://core.telegram.org/bots/api#video"><code>Video</code></a>, <a href="https://core.telegram.org/bots/api#videonote"><code>VideoNote</code></a>, <a href="https://core.telegram.org/bots/api#voice"><code>Voice</code></a>, <a href="https://core.telegram.org/bots/api#sticker"><code>Sticker</code></a>.</p>
<p>The file identifier for each file type can be found in their <code>FileId</code> property (e.g. <code>Message.Audio.FileId</code>).</p>
<p>The exception is photos, which represented as an array of <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize[]</code></a> objects.
For each photo Telegram sends you a set of <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> objects - available resolutions, you can choose from.
Generally, you will want the highest quality - the last <a href="https://core.telegram.org/bots/api#photosize"><code>PhotoSize</code></a> object in the array.
With LINQ, this boils down to <code>Message.Photo.Last().FileId</code>.</p>
<h2 id="downloading-a-file"><a class="header" href="#downloading-a-file">Downloading a file</a></h2>
<p>Downloading a file from Telegram is done in two steps:</p>
<ol>
<li>Get file information with <code>getFile</code> method. Resulting <a href="https://core.telegram.org/bots/api#file"><code>File</code></a> object contains <code>FilePath</code> from which we can download the file.</li>
<li>Downloading the file.</li>
</ol>
<pre><code class="language-C#">var fileId = update.Message.Photo.Last().FileId;
var fileInfo = await botClient.GetFileAsync(fileId);
var filePath = fileInfo.FilePath;
</code></pre>
<p>The URL from which you can now download the file is <code>https://api.telegram.org/file/bot&lt;token&gt;/&lt;FilePath&gt;</code>.</p>
<p>To download file you can use <code>DownloadFileAsync</code> function:</p>
<pre><code class="language-C#">const string destinationFilePath = &quot;../downloaded.file&quot;;

await using Stream fileStream = System.IO.File.Create(destinationFilePath);
await botClient.DownloadFileAsync(
    filePath: filePath,
    destination: fileStream,
    cancellationToken: cancellationToken);
</code></pre>
<p>For your convenience the library provides you a helper function that does both - <code>GetInfoAndDownloadFileAsync</code>:</p>
<pre><code class="language-C#">const string destinationFilePath = &quot;../downloaded.file&quot;;

await using Stream fileStream = System.IO.File.Create(destinationFilePath);
var file = await botClient.GetInfoAndDownloadFileAsync(
    fileId: fileId,
    destination: fileStream,
    cancellationToken: cancellationToken);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uploading-files"><a class="header" href="#uploading-files">Uploading files</a></h1>
<p>First, read the <a href="https://core.telegram.org/bots/api#sending-files">documentation on sending files</a>.</p>
<h2 id="upload-local-file"><a class="header" href="#upload-local-file">Upload local file</a></h2>
<p>To upload local file open stream and call one of the file-sending functions:</p>
<pre><code class="language-C#">await using Stream stream = System.IO.File.OpenRead(&quot;../hamlet.pdf&quot;);
Message message = await botClient.SendDocumentAsync(
    chatId: chatId,
    document: InputFile.FromStream(stream: stream, fileName: &quot;hamlet.pdf&quot;),
    caption: &quot;The Tragedy of Hamlet,\nPrince of Denmark&quot;);
</code></pre>
<p>Be aware of limitation for this method - 10 MB max size for photos, 50 MB for other files.</p>
<h2 id="upload-file-by-file-identifier"><a class="header" href="#upload-file-by-file-identifier">Upload file by file identifier</a></h2>
<p>If the file is already stored somewhere on the Telegram servers, you don't need to reupload it: each file object has a <code>FileId</code> property. Simply pass this <code>FileId</code> as a parameter instead of uploading. There are no limits for files sent this way.</p>
<pre><code class="language-C#">var fileId = update.Message.Photo.Last().FileId;
Message message = await botClient.SendPhotoAsync(
    chatId: chatId,
    photo: InputFile.FromFileId(fileId));
</code></pre>
<h2 id="upload-by-url"><a class="header" href="#upload-by-url">Upload by URL</a></h2>
<p>Provide Telegram with an HTTP URL for the file to be sent. Telegram will download and send the file. 5 MB max size for photos and 20 MB max for other types of content.</p>
<pre><code class="language-csharp">Message message = await botClient.SendPhotoAsync(
    chatId: chatId,
    photo: InputFile.FromUri(&quot;https://cdn.pixabay.com/photo/2017/04/11/21/34/giraffe-2222908_640.jpg&quot;));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stickers"><a class="header" href="#stickers">Stickers</a></h1>
<h2 id="sticker-1"><a class="header" href="#sticker-1">Sticker</a></h2>
<p><a href="https://core.telegram.org/bots/api#sendsticker"><img src="https://img.shields.io/badge/Bot_API_method-sendSticker-blue.svg?style=flat-square" alt="send sticker method" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/test/Telegram.Bot.Tests.Integ/Stickers/StickersTests.cs"><img src="https://img.shields.io/badge/Examples-Sticker_Messages-green.svg?style=flat-square" alt="sticker tests" /></a></p>
<p>Telegram stickers are fun and our bot is about to send its very first sticker.
Sticker files should be in <a href="https://developers.google.com/speed/webp/">WebP</a> format.</p>
<p>This code sends the same sticker twice. First by passing HTTP URL to a <a href="https://developers.google.com/speed/webp/">WebP</a> sticker file and
second by reusing <code>FileId</code> of the same sticker on Telegram servers.</p>
<pre><code class="language-c#">Message message1 = await botClient.SendStickerAsync(
    chatId: chatId,
    sticker: InputFile.FromUri(&quot;https://github.com/TelegramBots/book/raw/master/src/docs/sticker-fred.webp&quot;),
    cancellationToken: cancellationToken);

Message message2 = await botClient.SendStickerAsync(
    chatId: chatId,
    sticker: InputFile.FromFileId(message1.Sticker!.FileId),
    cancellationToken: cancellationToken);
</code></pre>
<p><img src="3/docs/shot-sticker_msgs.jpg" alt="sticker messages" /></p>
<p>Try inspecting the <code>sticker1.Sticker</code> property. It is of type [<code>Sticker</code>] and its schema looks similar to a photo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<ul>
<li><a href="4/login-widget.html">Login Widget</a></li>
<li><a href="4/passport/">Passport</a>
<ul>
<li><a href="4/passport/quickstart.html">Quickstart</a></li>
<li><a href="4/passport/files-docs.html">Files &amp; Documents</a></li>
<li><a href="4/passport/errors.html">Data Errors</a></li>
<li><a href="4/passport/key.html">RSA Key</a></li>
<li><a href="4/passport/faq.html">Decryption FAQ</a></li>
</ul>
</li>
<li><a href="4/proxy.html">Proxy</a></li>
<li><a href="4/logging.html">Logging</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-behind-a-proxy"><a class="header" href="#working-behind-a-proxy">Working Behind a Proxy</a></h1>
<p><code>TelegramBotClient</code> allows you to use a proxy for Bot API connections. This guide covers using three different proxy solutions.</p>
<ul>
<li><a href="4/proxy.html#http-proxy">HTTP Proxy</a></li>
<li><a href="4/proxy.html#socks5-proxy">SOCKS5 Proxy</a></li>
<li><a href="4/proxy.html#socks5-proxy-over-tor">SOCKS5 Proxy over Tor (Testing Only)</a></li>
</ul>
<p><img src="4/docs/tg-network.gif" alt="Telegram Network" /></p>
<blockquote>
<p>If you are in a country, such as Iran, where HTTP and SOCKS proxy connections to Telegram servers are blocked, consider using a VPN, using Tor Network, or hosting your bot in other jurisdictions.</p>
</blockquote>
<h2 id="http-proxy"><a class="header" href="#http-proxy">HTTP Proxy</a></h2>
<p>You can configure <code>HttpClient</code> with <code>WebProxy</code> and pass it to the Bot client.</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy webProxy = new (Host: &quot;https://example.org&quot;, Port: 8080)
{
    // Credentials if needed:
    Credentials = new NetworkCredential(&quot;USERNAME&quot;, &quot;PASSWORD&quot;)
};
HttpClient httpClient = new (
    new HttpClientHandler { Proxy = webProxy, UseProxy = true, }
);

var botClient = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<h2 id="socks5-proxy"><a class="header" href="#socks5-proxy">SOCKS5 Proxy</a></h2>
<p>As of .NET 6, <code>SocketsHttpHandler</code> <a href="https://devblogs.microsoft.com/dotnet/dotnet-6-networking-improvements/#socks-proxy-support">is able to use Socks4, Socks4a and Socks5 proxies</a>!</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy proxy = new (&quot;socks5://127.0.0.1:9050&quot;)
{
    Credentials = new NetworkCredential(&quot;USERNAME&quot;, &quot;PASSWORD&quot;)
};
HttpClient httpClient = new (
    new SocketsHttpHandler { Proxy = proxy, UseProxy = true, }
);

var botClient = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<h2 id="socks5-proxy-over-tor"><a class="header" href="#socks5-proxy-over-tor">SOCKS5 Proxy over Tor</a></h2>
<p><strong>Warning: Use for Testing only!</strong></p>
<blockquote>
<p>Do not use this method in a production environment as it has high network latency and poor bandwidth.</p>
</blockquote>
<p>Using Tor, a developer can avoid network restrictions while debugging and testing the code
before a production release.</p>
<ol>
<li>
<p>Install <a href="https://www.torproject.org/">Tor Browser</a></p>
</li>
<li>
<p>Open the <code>torcc</code> file with a text editor (Found in <code>Tor Browser\Browser\TorBrowser\Data\Tor</code>)</p>
</li>
<li>
<p>Add the following lines: (configurations are described below)</p>
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
SocksPort 127.0.0.1:9050
</code></pre>
</li>
<li>
<p>Look at the <a href="4/proxy.html#socks5-proxy">Socks5 proxy</a> example above.</p>
</li>
<li>
<p>Start the Tor Browser</p>
</li>
</ol>
<p>Usage:</p>
<pre><code class="language-csharp">// using System.Net;
// using System.Net.Http;

WebProxy proxy = new (&quot;socks5://127.0.0.1:9050&quot;);

HttpClient httpClient = new (
    new SocketsHttpHandler { Proxy = proxy, UseProxy = true }
);

var botClient = new TelegramBotClient(&quot;YOUR_API_TOKEN&quot;, httpClient);
</code></pre>
<blockquote>
<p>Note that Tor has to be active at all times for the bot to work.</p>
</blockquote>
<h3 id="configurations-in-torcc"><a class="header" href="#configurations-in-torcc">Configurations in <code>torcc</code></a></h3>
<pre><code class="language-text">EntryNodes {NL}
ExitNodes {NL}
StrictNodes 1
</code></pre>
<p>These three lines make sure you use nodes from the Netherlands as much as possible to reduce latency.</p>
<p><code>SocksPort 127.0.0.1:9050</code></p>
<p>This line tells tor to listen on port 9050 for any socks connections.
You can change the port to anything you want (9050 is just the default), only make sure to use the same port in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport"><a class="header" href="#telegram-passport">Telegram Passport</a></h1>
<p><a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/v/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget package" /></a>
<a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/dt/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget downloads" /></a>
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/github/stars/TelegramBots/Telegram.Bot.Extensions.Passport.svg?style=social&amp;label=Stars" alt="repository" /></a></p>
<ul>
<li><a href="4/passport/quickstart.html">Quickstart</a></li>
<li><a href="4/passport/files-docs.html">Files &amp; Documents</a></li>
<li><a href="4/passport/errors.html">Data Errors</a></li>
<li><a href="4/passport/key.html">RSA Key</a></li>
<li><a href="4/passport/faq.html">Decryption FAQ</a></li>
</ul>
<p><img src="4/passport/../docs/photo-tg_passport.gif" alt="telegram passport" /></p>
<p><a href="https://telegram.org/blog/passport">Telegram Passport</a> is a unified authorization method for services that require personal identification.
As a bot developer, you can use it to receive confidential user data in an end-to-end encrypted fashion.
There are several Know Your Customer(KYC) solutions that have already added support for Telegram Passport.</p>
<p>This guide is targeted at bot developers and assumes the audience is already familiar with:</p>
<ul>
<li><a href="https://telegram.org/blog/passport">Telegram Passport</a></li>
<li><a href="https://core.telegram.org/passport/example">Telegram Passport Example</a></li>
<li><a href="https://core.telegram.org/passport">Telegram Passport Manual</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport---quickstart"><a class="header" href="#telegram-passport---quickstart">Telegram Passport - Quickstart</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs"><img src="https://img.shields.io/badge/Examples-Passport_Quickstart-green.svg?style=flat-square" alt="passport quickstart example" /></a></p>
<p>This guide teaches the basics of working with Telegram Passport.
See the complete version of the code at <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/tree/master/src/Quickstart">Quickstart project</a>.
Code snippets on this page are in the context of that project.</p>
<h2 id="package"><a class="header" href="#package">Package</a></h2>
<p><a href="https://www.nuget.org/packages/Telegram.Bot.Extensions.Passport"><img src="https://img.shields.io/nuget/v/Telegram.Bot.Extensions.Passport.svg?style=flat-square" alt="nuget package" /></a></p>
<p>You need to add <code>Telegram.Bot.Extensions.Passport</code> extension package to your project
in addition to the core package (<code>Telegram.Bot</code>).</p>
<p>⭐️ Star the <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport">Telegram.Bot.Extensions.Passport project</a> on GitHub 👍</p>
<pre><code class="language-bash">dotnet add package Telegram.Bot.Extensions.Passport
</code></pre>
<h2 id="encryption-keys"><a class="header" href="#encryption-keys">Encryption Keys</a></h2>
<p>You don't really need to generate any RSA key. Use our sample keys for this demo.
Send the public key to <a href="https://t.me/BotFather">@BotFather</a> using <code>/setpublickey</code> command:</p>
<p><img src="4/passport/../docs/shot-passport_botfather.jpg" alt="Setting public key" /></p>
<p>Copy this public key and send it to BotFather.</p>
<pre><code class="language-text">-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0VElWoQA2SK1csG2/sY/
wlssO1bjXRx+t+JlIgS6jLPCefyCAcZBv7ElcSPJQIPEXNwN2XdnTc2wEIjZ8bTg
BlBqXppj471bJeX8Mi2uAxAqOUDuvGuqth+mq7DMqol3MNH5P9FO6li7nZxI1FX3
9u2r/4H4PXRiWx13gsVQRL6Clq2jcXFHc9CvNaCQEJX95jgQFAybal216EwlnnVV
giT/TNsfFjW41XJZsHUny9k+dAfyPzqAk54cgrvjgAHJayDWjapq90Fm/+e/DVQ6
BHGkV0POQMkkBrvvhAIQu222j+03frm9b2yZrhX/qS01lyjW4VaQytGV0wlewV6B
FwIDAQAB
-----END PUBLIC KEY-----
</code></pre>
<p>Now Telegram client app can encrypt the data for your bot using this key.</p>
<h2 id="request-information-1"><a class="header" href="#request-information-1">Request Information</a></h2>
<p>Bot waits for a text message from user. Once it receives a text message, it generates an authorization request link
and sends that to the user.</p>
<h3 id="authorization-request"><a class="header" href="#authorization-request">Authorization Request</a></h3>
<p><a href="https://core.telegram.org/passport#request-parameters"><img src="https://img.shields.io/badge/Passport_API_type-Request_Parameters-blue.svg?style=flat-square" alt="Request Parameters type" /></a></p>
<p>A passport authorization request means that the bot should ask the user to open a <code>tg://resolve</code> URI in the browser
with specific parameters in its query string.
You can alternatively have a button in an HTML page on your website for that.</p>
<p>Type <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Request/AuthorizationRequestParameters.cs">AuthorizationRequestParameters</a>  helps you in creating such an URI.</p>
<pre><code class="language-c#">AuthorizationRequestParameters authReq = new AuthorizationRequestParameters(
    botId: 123456, // bot user ID
    publicKey: &quot;...&quot;, // public key in PEM format. same as the key above.
    nonce: &quot;unique nonce for this request&quot;,
    scope: new PassportScope(new[] { // a PassportScope object
        new PassportScopeElementOne(&quot;address&quot;),
        new PassportScopeElementOne(&quot;phone_number&quot;)
    })
);
</code></pre>
<p>In <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs">SendAuthorizationRequestAsync</a> method, we ask for <code>address</code> and <code>phone_number</code> scopes.
Then, we generate the query string and ask user to open the link.</p>
<p>You might be wondering what is the magic in here?</p>
<p><a href="https://telegrambots.github.io/Telegram.Bot.Extensions.Passport/redirect.html">https://telegrambots.github.io/Telegram.Bot.Extensions.Passport/redirect.html</a></p>
<p>This web page redirects user to <code>tg://resolve</code> URI, appending whatever query string was passed to it.</p>
<blockquote>
<p>If a user is using an Android device, the URI will start with <code>tg:</code> instead of the default <code>tg://</code>.</p>
</blockquote>
<p><img src="4/passport/../docs/shot-passport_link1.jpg" alt="Passport link 1" />
<img src="4/passport/../docs/shot-passport_link2.jpg" alt="Passport link 2" /></p>
<h3 id="passport-data"><a class="header" href="#passport-data">Passport Data</a></h3>
<p>You, the user, should now be redirected to the Telegram Passport screen in your Telegram client app.
Enter your password and log in.</p>
<blockquote>
<p>Note that the app will ask you to register if this is the first time you are using Telegram Passport.</p>
</blockquote>
<p><img src="4/passport/../docs/shot-passport_login.jpg" alt="Passport login" /></p>
<p>Fill in the <em>address</em> and <em>phone number</em> data. Click on the <em>Authorize</em> button at the end.</p>
<p><img src="4/passport/../docs/shot-passport_adress_phone1.jpg" alt="Passport info 1" />
<img src="4/passport/../docs/shot-passport_adress.jpg" alt="address info" />
<img src="4/passport/../docs/shot-passport_phone.jpg" alt="phone info" />
<img src="4/passport/../docs/shot-passport_adress_phone2.jpg" alt="Passport info 2" /></p>
<p>At this point, your Telegram client app encrypts the actual Telegram Passport data (e.g. address) using the
AES algorithm, and then encrypts the info required for decryption using your bot's public RSA key.
Finally, it sends the result of both encryptions to Telegram servers.</p>
<h3 id="data-decryption"><a class="header" href="#data-decryption">Data Decryption</a></h3>
<p><a href="https://core.telegram.org/bots/api#passportdata"><img src="https://img.shields.io/badge/Bot_API_type-Passport_Data-blue.svg?style=flat-square" alt="Passport Data type" /></a></p>
<p>Your bot now receives a new message update with the encrypted Passport data. The user is also notified in the chat:</p>
<p><img src="4/passport/../docs/shot-passport_update.jpg" alt="Passport update" /></p>
<p>Let's decrypt that gibberish to get the information. That's what <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/Program.cs">DecryptPassportDataAsync</a> method does.</p>
<h4 id="step-1-credentials"><a class="header" href="#step-1-credentials">Step 1: Credentials</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedcredentials"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedCredentials-blue.svg?style=flat-square" alt="EncryptedCredentials type" /></a>
<a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a></p>
<p>You can't just access the encrypted data in the <code>message.passport_data.data</code> array.
Required parameters for their decryption are in the <code>message.passport_data.credentials</code> object.
But that credentials object is encrypted using bot's public key!</p>
<p>We first take the bot's <em>private key</em> this time and decrypt the credentials.</p>
<blockquote>
<p>There are more details about importing a key in PEM format on the <a href="4/passport/key.html">RSA Key page</a>.</p>
</blockquote>
<pre><code class="language-c#">IDecrypter decrypter = new Decrypter();
Credentials credentials = decrypter.DecryptCredentials(
    message.PassportData.Credentials, // EncryptedCredentials object
    GetRsaPrivateKey() // private key as an RSA object
);
</code></pre>
<h4 id="step-2-nonce"><a class="header" href="#step-2-nonce">Step 2: Nonce</a></h4>
<p><a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a>
<a href="https://core.telegram.org/passport#request-parameters"><img src="https://img.shields.io/badge/Passport_API_type-Request_Parameters-blue.svg?style=flat-square" alt="Request Parameters type" /></a></p>
<p>There is a <code>nonce</code> property on the credentials (now decrypted) object.
In order to prevent certain attacks, ensure its value is exactly the same as the nonce you set in the authorization request.
Read more about <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce on Wikipedia</a>.</p>
<h4 id="step-3-residential-address"><a class="header" href="#step-3-residential-address">Step 3: Residential Address</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedpassportelement"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedPassportElement-blue.svg?style=flat-square" alt="EncryptedPassportElement type" /></a>
<a href="https://core.telegram.org/passport#residentialaddress"><img src="https://img.shields.io/badge/Passport_API_type-ResidentialAddress-blue.svg?style=flat-square" alt="ResidentialAddress type" /></a></p>
<p><a href="https://core.telegram.org/passport#securedata"><img src="https://img.shields.io/badge/Passport_API_type-SecureData-blue.svg?style=flat-square" alt="SecureData type" /></a>
<a href="https://core.telegram.org/passport#securevalue"><img src="https://img.shields.io/badge/Passport_API_type-SecureValue-blue.svg?style=flat-square" alt="SecureValue type" /></a>
<a href="https://core.telegram.org/passport#datacredentials"><img src="https://img.shields.io/badge/Passport_API_type-DataCredentials-blue.svg?style=flat-square" alt="DataCredentials type" /></a></p>
<p>It's finally time to see the user's address.
We are looking for an encrypted element with type of <em>address</em> in <code>message.passport_data.data</code> array.
Also, decryption parameters for that are in <code>credentials.secure_data.address.data</code>.
Here is how the decryption magic happens:</p>
<pre><code class="language-c#">EncryptedPassportElement addressElement = message.PassportData.Data.Single(
    el =&gt; el.Type == PassportEnums.Scope.Address
);
ResidentialAddress address = decrypter.DecryptData&lt;ResidentialAddress&gt;(
    encryptedData: addressElement.Data,
    dataCredentials: credentials.SecureData.Address.Data
);
</code></pre>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">DecryptData</a> method does 3 tasks here:</p>
<ol>
<li>Decrypts the data into a JSON-serialized string</li>
<li>Verifies that the data hashes match</li>
<li>Converts from JSON to a .NET object</li>
</ol>
<h4 id="step-4-phone-number"><a class="header" href="#step-4-phone-number">Step 4: Phone Number</a></h4>
<p><a href="https://core.telegram.org/bots/api#encryptedpassportelement"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedPassportElement-blue.svg?style=flat-square" alt="EncryptedPassportElement type" /></a></p>
<p>Values for phone number and email address are not end-to-end encrypted in Telegram Passport and
Telegram stores these values after being verified.</p>
<p>There is no need for decryption at this point.
Just find the element with the type of <em>phone_number</em> in the <code>message.passport_data.data</code> array.</p>
<h3 id="information-demo"><a class="header" href="#information-demo">Information Demo</a></h3>
<p>At the end, bot sends some of the information received to the user for demo purposes.</p>
<p><img src="4/passport/../docs/shot-passport_quickstart.jpg" alt="info demo" /></p>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="passport-files-and-documents"><a class="header" href="#passport-files-and-documents">Passport Files and Documents</a></h1>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Examples-Driver_License_Scope-green.svg?style=flat-square" alt="driver's license scope tests" /></a></p>
<p>We use the driver's license scope here to show decryption of <em>ID document data</em> and <em>passport files</em> for
front side scan, reverse side scan, selfie photo, and translation scan.
That should cover most of the <a href="https://core.telegram.org/passport#fields">field types in Telegram Passport</a>.</p>
<p>Sections below are referring to the test methods in <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs">Driver's License Scope Tests</a> collection.
Here are the steps:</p>
<ol>
<li><a href="4/passport/files-docs.html#authorization-request">Authorization Request</a></li>
<li><a href="4/passport/files-docs.html#drivers-license-info">Driver's License Info</a></li>
<li><a href="4/passport/files-docs.html#passport-message">Passport Message</a></li>
<li><a href="4/passport/files-docs.html#credentials">Credentials</a></li>
<li><a href="4/passport/files-docs.html#id-document-data">ID Document Data</a></li>
<li><a href="4/passport/files-docs.html#passport-file">Passport File</a>
<ul>
<li><a href="4/passport/files-docs.html#front-side-file">Front Side File</a></li>
<li><a href="4/passport/files-docs.html#reverse-side-file">Reverse Side File</a></li>
<li><a href="4/passport/files-docs.html#selfie-file">Selfie File</a></li>
<li><a href="4/passport/files-docs.html#translation-file">Translation File</a></li>
</ul>
</li>
</ol>
<h2 id="authorization-request-1"><a class="header" href="#authorization-request-1">Authorization Request</a></h2>
<p><a href="https://core.telegram.org/passport#passportscope"><img src="https://img.shields.io/badge/Passport_API_type-PassportScope-blue.svg?style=flat-square" alt="PassportScope type" /></a>
<a href="https://core.telegram.org/passport#passportscopeelementone"><img src="https://img.shields.io/badge/Passport_API_type-PassportScopeElementOne-blue.svg?style=flat-square" alt="PassportScopeElementOne type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Generate_Auth_Link-green.svg?style=flat-square" alt="method Should_Generate_Auth_Link" /></a></p>
<p>We start by generating an authorization URI.
Since a driver's license is considered as a proof of identity, we ask for optional data <em>selfie with document</em> and
<em>translation document scan</em> as well.</p>
<p><img src="4/passport/../docs/shot-passport_driver_license_link.jpg" alt="driver's license passport link" /></p>
<h2 id="drivers-license-info"><a class="header" href="#drivers-license-info">Driver's License Info</a></h2>
<p>As a user, provide information for the required fields: front side, reverse side, and document number.
Also, test methods here expect a selfie photo and a file for translation scan.</p>
<p><img src="4/passport/../docs/shot-passport_driver_license1.jpg" alt="driver's license passport 1" />
<img src="4/passport/../docs/shot-passport_driver_license2.jpg" alt="driver's license passport 2" />
<img src="4/passport/../docs/shot-passport_driver_license3.jpg" alt="driver's license passport 3" /></p>
<p>Click the <em>Authorize</em> button at the end.</p>
<h2 id="passport-message"><a class="header" href="#passport-message">Passport Message</a></h2>
<p><a href="https://core.telegram.org/bots/api#passportdata"><img src="https://img.shields.io/badge/Bot_API_type-Passport_Data-blue.svg?style=flat-square" alt="Passport Data type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Validate_Passport_Update-green.svg?style=flat-square" alt="method Should_validate_passport_update" /></a></p>
<p>This test method checks for a Passport message with a driver's license element on it.</p>
<h2 id="credentials"><a class="header" href="#credentials">Credentials</a></h2>
<p><a href="https://core.telegram.org/bots/api#encryptedcredentials"><img src="https://img.shields.io/badge/Bot_API_type-EncryptedCredentials-blue.svg?style=flat-square" alt="EncryptedCredentials type" /></a>
<a href="https://core.telegram.org/passport#credentials"><img src="https://img.shields.io/badge/Passport_API_type-Credentials-blue.svg?style=flat-square" alt="Credentials type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-Decrypt_Credentials-green.svg?style=flat-square" alt="method Should_decrypt_credentials" /></a></p>
<p>We decrypt credentials using the RSA private key and verify that the same nonce is used.</p>
<pre><code class="language-c#">RSA key = EncryptionKey.ReadAsRsa();
IDecrypter decrypter = new Decrypter();
Credentials credentials = decrypter.DecryptCredentials(
    passportData.Credentials,
    key
);
bool isSameNonce = credentials.Nonce == &quot;Test nonce for driver's license&quot;;
</code></pre>
<h2 id="id-document-data"><a class="header" href="#id-document-data">ID Document Data</a></h2>
<p><a href="https://core.telegram.org/passport#iddocumentdata"><img src="https://img.shields.io/badge/Passport_API_type-IdDocumentData-blue.svg?style=flat-square" alt="IdDocumentData type" /></a></p>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Document_Data-green.svg?style=flat-square" alt="method Should_decrypt_document_data" /></a></p>
<p>In our test case, there is only 1 item in the <code>message.passport_data.data</code> array and that's the encrypted element for
the driver's license scope.
We can get information such as document number and expiry date for the license from that element:</p>
<pre><code class="language-c#">IdDocumentData licenseDoc = decrypter.DecryptData&lt;IdDocumentData&gt;(
    encryptedData: element.Data,
    dataCredentials: credentials.SecureData.DriverLicense.Data
);
</code></pre>
<h2 id="passport-file"><a class="header" href="#passport-file">Passport File</a></h2>
<p><a href="https://core.telegram.org/bots/api#passportfile"><img src="https://img.shields.io/badge/Bot_API_type-PassportFile-blue.svg?style=flat-square" alt="PassportFile type" /></a>
<a href="https://core.telegram.org/passport#filecredentials"><img src="https://img.shields.io/badge/Passport_API_type-FileCredentials-blue.svg?style=flat-square" alt="FileCredentials type" /></a></p>
<p>Passport file is an encrypted JPEG file on Telegram servers.
You need to download the passport file and decrypt it using its accompanying <em>file credentials</em> to see
the actual JPEG file content.
In this section we try to demonstrate different use cases that you might have for such files.</p>
<p>No matter the method used, the underlying decryption logic is the same.
It really comes down to your decision on working with <em>streams</em> vs. <em>byte arrays</em>.
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">IDecrypter</a> gives you both options.</p>
<h3 id="front-side-file"><a class="header" href="#front-side-file">Front Side File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Front_Side_File-green.svg?style=flat-square" alt="method Should_decrypt_front_side_file" /></a></p>
<p>A pretty handy extension method is used here to stream writing the front side file to disk.
Method <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/TelegramBotClientPassportExtensions.cs">DownloadAndDecryptPassportFileAsync</a> does a few things:</p>
<ol>
<li>Makes an HTTP request to fetch the encrypted file's info using its <em>passport file_id</em></li>
<li>Makes an HTTP request to download the encrypted file using its <em>file_path</em></li>
<li>Decrypts the encrypted file</li>
<li>Writes the actual content to the destination stream</li>
</ol>
<pre><code class="language-c#">File encryptedFileInfo;
using (System.IO.Stream stream = System.IO.File.OpenWrite(&quot;/path/to/front-side.jpg&quot;))
{
    encryptedFileInfo = await BotClient.DownloadAndDecryptPassportFileAsync(
        element.FrontSide, // PassportFile object for front side
        credentials.SecureData.DriverLicense.FrontSide, // front side FileCredentials
        stream // destination stream for writing the JPEG content to
    );
}
</code></pre>
<blockquote>
<p><strong>Warning</strong>: This method is convenient to use but gives you the least amount of control over the operations.</p>
</blockquote>
<h3 id="reverse-side-file"><a class="header" href="#reverse-side-file">Reverse Side File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Reverse_Side_File-green.svg?style=flat-square" alt="method Should_decrypt_reverse_side_file" /></a></p>
<p>Previous method call is divided into two operations here for reverse side of the license.
Streams are used here as well.</p>
<pre><code class="language-c#">File encryptedFileInfo;
using (System.IO.Stream
    encryptedContent = new System.IO.MemoryStream(element.ReverseSide.FileSize),
    decryptedFile = System.IO.File.OpenWrite(&quot;/path/to/reverse-side.jpg&quot;)
) {
    // fetch the encrypted file info and download it to memory
    encryptedFileInfo = await BotClient.GetInfoAndDownloadFileAsync(
        element.ReverseSide.FileId, // file_id of passport file for reverse side
        encryptedContent // stream to copy the encrypted file into
    );
    // ensure memory stream is at the beginning before reading from it
    encryptedContent.Position = 0;

    // decrypt the file and write it to disk
    await decrypter.DecryptFileAsync(
        encryptedContent,
        credentials.SecureData.DriverLicense.ReverseSide, // reverse side FileCredentials
        decryptedFile // destination stream for writing the JPEG content to
    );
}
</code></pre>
<h3 id="selfie-file"><a class="header" href="#selfie-file">Selfie File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Selfie_File-green.svg?style=flat-square" alt="method Should_decrypt_selfie_file" /></a></p>
<p>We deal with selfie photo as a byte array.
This is essentially the same operation as done above via streams.
We also post the selfie photo to a chat.</p>
<pre><code class="language-c#">// fetch the info of the passport file(selfie) residing on Telegram servers
File encryptedFileInfo = await BotClient.GetFileAsync(element.Selfie.FileId);

// download the encrypted file and get its bytes
byte[] encryptedContent;
using (System.IO.MemoryStream
    stream = new System.IO.MemoryStream(encryptedFileInfo.FileSize)
)
{
    await BotClient.DownloadFileAsync(encryptedFileInfo.FilePath, stream);
    encryptedContent = stream.ToArray();
}

// decrypt the content and get bytes of the actual selfie photo
byte[] selfieContent = decrypter.DecryptFile(
    encryptedContent,
    credentials.SecureData.DriverLicense.Selfie
);

// send the photo to a chat
using (System.IO.Stream stream = new System.IO.MemoryStream(selfieContent)) {
    await BotClient.SendPhotoAsync(
        123456,
        stream,
        &quot;selfie with driver's license&quot;
    );
}
</code></pre>
<h3 id="translation-file"><a class="header" href="#translation-file">Translation File</a></h3>
<p><a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/test/IntegrationTests/Single%20Scope%20Requests/Driver%20License%20Tests.cs"><img src="https://img.shields.io/badge/Test_Method-decrypt_Translation_File-green.svg?style=flat-square" alt="method Should_decrypt_translation_file" /></a></p>
<p>A bot can request certified English translations of a document.
Translations are also encrypted passport files so their decryption is no different from others passport files.</p>
<p>Assuming that the user sends one translation scan only for the license, we receive the translation passport file object in
<code>message.passport_data.data[0].translation[0]</code> and its accompanying file credentials object in
<code>credentials.secure_data.driver_license.translation[0]</code>.</p>
<p>File gets written to disk as a byte array.</p>
<pre><code class="language-c#">PassportFile passportFile = element.Translation[0];
FileCredentials fileCreds = credentials.SecureData.DriverLicense.Translation[0];

// fetch passport file info
File encryptedFileInfo = await BotClient.GetFileAsync(passportFile.FileId);

// download encrypted file and get its bytes
byte[] encryptedContent;
using (System.IO.MemoryStream
    stream = new System.IO.MemoryStream(encryptedFileInfo.FileSize)
)
{
    await BotClient.DownloadFileAsync(encryptedFileInfo.FilePath, stream);
    encryptedContent = stream.ToArray();
}

// decrypt the content and get bytes of the actual selfie photo
byte[] content = decrypter.DecryptFile(
    encryptedContent,
    fileCreds
);

// write the file to disk
await System.IO.File.WriteAllBytesAsync(&quot;/path/to/translation.jpg&quot;, content);
</code></pre>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="passport-data-errors"><a class="header" href="#passport-data-errors">Passport Data Errors</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-rsa-key"><a class="header" href="#import-rsa-key">Import RSA Key</a></h1>
<p>In order to decrypt the credentials you need to provide the private RSA key to <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs">DecryptCredentials</a> method.
If you have the RSA key in <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM format</a>, you cannot simply instantiate an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa?redirectedfrom=MSDN&amp;view=netstandard-2.0">RSA .NET object</a> from it.
Here we discuss two ways of importing your PEM private key.</p>
<h2 id="from-pem-format"><a class="header" href="#from-pem-format">From PEM Format</a></h2>
<p>This is the easier option and recommended <strong>for development time only</strong>.
We can generate an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa?redirectedfrom=MSDN&amp;view=netstandard-2.0">RSA .NET object</a> from an RSA Key in PEM format using the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a>.</p>
<pre><code class="language-bash">dotnet add package BouncyCastle
</code></pre>
<p><a href="http://www.bouncycastle.org/csharp/index.html"><img src="4/passport/../docs/photo-bouncy_castle.gif" alt="bouncy castle c# logo" /></a></p>
<p>Code snippet here shows the conversion from a PEM file to the needed RSA object.</p>
<pre><code class="language-c#">// using System.IO;
// using System.Security.Cryptography;
// using Org.BouncyCastle.Crypto;
// using Org.BouncyCastle.Crypto.Parameters;
// using Org.BouncyCastle.OpenSsl;
// using Org.BouncyCastle.Security;

static RSA GetPrivateKey() {
    string privateKeyPem = File.ReadAllText(&quot;/path/to/private-key.pem&quot;);
    PemReader pemReader = new PemReader(new StringReader(privateKeyPem));
    AsymmetricCipherKeyPair keyPair = (AsymmetricCipherKeyPair) pemReader.ReadObject();
    RSAParameters rsaParameters = DotNetUtilities
        .ToRSAParameters(keyPair.Private as RsaPrivateCrtKeyParameters);
    RSA rsa = RSA.Create(rsaParameters);
    return rsa;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: You don't necessarily need to have a dependency on the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a> in your bot project.
The section below offers a better alternative.</p>
</blockquote>
<h2 id="from-rsa-parameters"><a class="header" href="#from-rsa-parameters">From RSA Parameters</a></h2>
<p>We recommend to JSON-serialize <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> of your key and create an RSA object using its values without any
dependency on the <a href="https://www.nuget.org/packages/BouncyCastle/">BouncyCastle package</a> in production deployment.</p>
<p>Copy <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyUtility.cs">EncryptionKeyUtility</a> and <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> files from our Quickstart project.
Those help with serialization.</p>
<p>You still need to <strong>use BouncyCastle only once</strong> to read the RSA key in PEM format and serialize its parameters:</p>
<pre><code class="language-c#">// ONLY ONCE: read the RSA private key and serialize its parameters to JSON
static void WriteRsaParametersToJson() {
    string privateKeyPem = System.IO.File.ReadAllText(&quot;/path/to/private-key.pem&quot;);
    string json = EncryptionKeyUtility.SerializeRsaParameters(privateKeyPem);
    System.IO.File.WriteAllText(&quot;/path/to/private-key-params.json&quot;, json);
}

// Now, read the JSON file and create an RSA instance
static RSA GetRsaKey() {
    string json = System.IO.File.ReadAllText(&quot;/path/to/private-key-params.json&quot;);
    return EncryptionKeyUtility.GetRsaKeyFromJson(json);
}
</code></pre>
<p>Content of <code>private-key-params.json</code> will look similar to this:</p>
<pre><code class="language-json">{
  &quot;E&quot;: &quot;AQAB&quot;,
  &quot;M&quot;: &quot;0VElW...Fw==&quot;,
  &quot;P&quot;: &quot;56Mdiw...i7FSwDaM=&quot;,
  &quot;Q&quot;: &quot;51UN2sd...J44NTf0=&quot;,
  &quot;D&quot;: &quot;nrXEeOl2Ky...JIQ==&quot;,
  &quot;DP&quot;: &quot;KZYZWbsy.../lk60=&quot;,
  &quot;DQ&quot;: &quot;Y25KgzPj...AdBd0=&quot;,
  &quot;IQ&quot;: &quot;0153...N6Y=&quot;
}
</code></pre>
<p>It's worth mentioning that <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> is just a copy of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> struct.
There are inconsistencies in serialization of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsaparameters?view=netstandard-2.0">RSAParameters</a> type on different .NET platforms
and that's why we use our own <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Quickstart/EncryptionKeyParameters.cs">EncryptionKeyParameters</a> type for serialization.</p>
<blockquote>
<p>For instance, compare <code>RSAParameters</code> implementations on <a href="https://referencesource.microsoft.com/#mscorlib/system/security/cryptography/rsa.cs,21">.NET Framework</a> and <a href="https://github.com/dotnet/corefx/blob/master/src/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RSAParameters.cs">.NET Core</a>.</p>
</blockquote>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-passport-data-decryption---faq"><a class="header" href="#telegram-passport-data-decryption---faq">Telegram Passport Data Decryption - FAQ</a></h1>
<h2 id="what-is-passportdatadecryptionexception"><a class="header" href="#what-is-passportdatadecryptionexception">What is <code>PassportDataDecryptionException</code></a></h2>
<p>Methods on <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/IDecrypter.cs"><code>IDecrypter</code></a> might throw <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Passport/blob/master/src/Telegram.Bot.Extensions.Passport/Decryption/PassportDataDecryptionException.cs"><code>PassportDataDecryptionException</code></a> exception
if an error happens during decryption.
The exception message tells you what went wrong but there is not much you can do to resolve it.
Maybe let your user know the issue and ask for Passport data again.</p>
<p>It is important to pass each piece of encrypted data, e.g. Id Document, Passport File, etc., with the right
accompanying credentials to decryption methods.</p>
<p>Spot the <em>problem in this code</em> decrypting driver's license files:</p>
<pre><code class="language-c#">byte[] selfieContent = decrypter.DecryptFile(
    encSelfieContent, // byte array of encrypted selfie file
    credentials.SecureData.DriverLicense.FrontSide // WRONG! use selfie file credentials
);
// throws PassportDataDecryptionException: &quot;Data hash mismatch at position 123.&quot;
</code></pre>
<!-- ----------- -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram-login-widget"><a class="header" href="#telegram-login-widget">Telegram Login Widget</a></h1>
<p>Everything related to the <a href="https://core.telegram.org/widgets/login">Telegram Login Widget</a> has been moved to a separate repository:
<a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.LoginWidget"><code>Telegram.Bot.Extensions.LoginWidget</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systems-integration-tests"><a class="header" href="#systems-integration-tests">Systems Integration Tests</a></h1>
<p>Integration tests are meant to test the project with real data from Telegram. They are semi-automated tests and tester(s) need to interact with bot for some cases during the test execution. Tests could be used as a playground for exploring Bot API methods.</p>
<h2 id="sample-test-diagnostics-output"><a class="header" href="#sample-test-diagnostics-output">Sample Test Diagnostics Output</a></h2>
<p>All the test output goes into the supergroup/private chats specified in configurations or interactively during test execution. You can see some samples of test output below.</p>
<p>Admin bots can change chat photo.</p>
<p><img src="4/docs/testcase-chatphoto.jpg" alt="Test Case: Set Chat Photo" /></p>
<p>Invoices could be paid in private chats.</p>
<p><img src="4/docs/testcase-payment.jpg" alt="Test Case: Set Chat Photo" /></p>
<h2 id="how-tests-works"><a class="header" href="#how-tests-works">How Tests Works</a></h2>
<p>These integration tests are written just like regular unit tests with xUnit framework so they seem to be unit tests. When you run test(s), bot makes a request to Bot API and you should see results(message or service notification) in the chat with bot.</p>
<p>When you build the solution, you will see them in Test Explorer window. Tests could be run through .NET Core's CLI as well and that's how this project's CI is set up.</p>
<p>A bot, of course, is needed to test Bot API. This document refers to its user name as <em>MyTestBot</em>.</p>
<p><em>Tester</em> refers to user name of person testing the bot. Multiple testers could interact with bot during
test execution. If super group chat has other members that are not listed as testers, bot ignores their
messages during test execution. Testers must have user names assigned and their user names should be set
in test configurations before hand.</p>
<p>All the tests happen in two chats. A Super Group chat and a Private chat with one of the testers.</p>
<p>Test cases that need tester's interaction to continue, have a limit of usually 2 minutes to wait for receiving an expected update from API.</p>
<p>Tests could be run individually, in collections, or all at once. All the test collection and test cases within them are ordered and tests will not run in parallel.</p>
<h2 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h2>
<p>Create a Super Group and add bot to it. Promote bot to admin and make sure it has all the permissions. This group needs to have another regular(non-admin) member to be used in tests for chat administration methods(such as Kick, Restrict, Unban). A super group with 2 testers in it, one admin and the other non-admin member, is enough.</p>
<p>Bot should have some features enabled, usually through BotFather, in order to pass tests. These features are listed below:</p>
<ul>
<li>Inline Queries</li>
<li>Payment Provider</li>
</ul>
<p>For making testing process more convenient, set the following commands for MyTestBot as well. The purpose for these commands is explained in the sections below.</p>
<pre><code class="language-text">test - Start test execution
  me - Select me for testing admin methods
</code></pre>
<h2 id="test-configurations"><a class="header" href="#test-configurations">Test Configurations</a></h2>
<p>You can see a list of configuration keys in <code>appsettings.json</code> file. Make a copy of this file and store your configurations there. In addition to <code>appsettings.json</code> and <code>appsettings.Development.json</code>, environment variables prefixed by <code>TelegramBot_</code> are also read into program.</p>
<pre><code class="language-bash">cp appsettings.json appsettings.Development.json
</code></pre>
<h3 id="required-settings"><a class="header" href="#required-settings">Required Settings</a></h3>
<p>Only 2 values must be provided before test execution.</p>
<h4 id="api-token"><a class="header" href="#api-token">API Token</a></h4>
<p>This is required for executing any test case.</p>
<pre><code class="language-json">{
  &quot;ApiToken&quot;: &quot;MyTestBot-API-TOKEN&quot;
  /* ... */
}
</code></pre>
<h4 id="allowed-users"><a class="header" href="#allowed-users">Allowed Users</a></h4>
<p>A comma separated list indicating user name(s) of tester(s). Any update coming from users other than the ones listed here are discarded during test execution.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;AllowedUserNames&quot;: &quot;tester1, Tester2, TESTER3&quot;
  /* ... */
}
</code></pre>
<h3 id="optional-settings"><a class="header" href="#optional-settings">Optional Settings</a></h3>
<p>The following settings are not required for two reasons. Either bot can ask for them during test execution or it is not a required setting for all test cases.</p>
<p>Bot will ask testers in supergroup/private chat for the necessary information. It would be faster to set all the optional settings as well because it makes testing process faster and less manual.</p>
<blockquote>
<p>For obtaining values of necessary settings, you can set breakpoints in some test methods and extract values such as chat id or user id.</p>
</blockquote>
<h4 id="supergroup-chat-id"><a class="header" href="#supergroup-chat-id">Supergroup Chat Id</a></h4>
<p>Bot send  messages to this chat in almost all test cases except cases like sending payments that must be to a private chat.</p>
<p>If not set, before starting any test method, bot waits for a tester to send it a <code>/test</code> command in a super group chat (that bot is also a member of).</p>
<pre><code class="language-json">{
  /* ... */
  &quot;SuperGroupChatId&quot;: -1234567890
  /* ... */
}
</code></pre>
<h4 id="payment-settings"><a class="header" href="#payment-settings">Payment Settings</a></h4>
<h5 id="required-payment-provider-token"><a class="header" href="#required-payment-provider-token">[Required] Payment Provider Token</a></h5>
<p>This token is <strong>required</strong> for any test case regarding payments and must be provided before starting tests.</p>
<p>Consult Telegram API documentations and talk to BotFather to get a test token from a payment provider.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;PaymentProviderToken&quot;: &quot;MY-PAYMENT-PROVIDER-TOKEN&quot;
  /* ... */
}
</code></pre>
<h5 id="testerprivatechatid"><a class="header" href="#testerprivatechatid">TesterPrivateChatId</a></h5>
<p>Invoices could only be sent to private chats. If not set, bot will wait for a tester to send it <code>/test</code> command in a private chat.</p>
<pre><code class="language-json">{
  /* ... */
  &quot;TesterPrivateChatId&quot;: 1234567890
  /* ... */
}
</code></pre>
<h4 id="chat-administration"><a class="header" href="#chat-administration">Chat Administration</a></h4>
<p>For this type of tests, bot should be a privileged admin of that super group. Methods such as kick or unban will be performed on a regular (non-admin) tester in that chat.</p>
<p>If the following 3 settings are not set, bot will ask a tester to send it <code>/me</code> command in a private chat with bot.</p>
<ul>
<li>Regular Member's User Id</li>
<li>Regular Member's User Name</li>
<li>Regular Member's Private Chat Id</li>
</ul>
<pre><code class="language-json">{
  /* ... */
  &quot;RegularMemberUserId&quot;: 1234567890,
  &quot;RegularMemberUserName&quot;: &quot;tester3&quot;,
  &quot;RegularMemberPrivateChatId&quot;: 1234567890
  /* ... */
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<blockquote>
<p>This chapter is not yet written.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-14x"><a class="header" href="#migration-guide-for-version-14x">Migration guide for version 14.x</a></h1>
<h2 id="date-and-time"><a class="header" href="#date-and-time">Date and Time</a></h2>
<p>All <code>DateTime</code> values are now in UTC format. Here are some examples of usage:</p>
<pre><code class="language-csharp">// Use UTC time when making a request
await BotClient.KickChatMemberAsync(
    chatId: -9876,
    userId: 1234,
    untilDate: DateTime.UtcNow.AddDays(2)
);
</code></pre>
<pre><code class="language-csharp">// Convert to local time (not recommended though)
DateTime localTime = update.Message.Date.ToLocalTime();
</code></pre>
<h2 id="keyboard-buttons"><a class="header" href="#keyboard-buttons">Keyboard Buttons</a></h2>
<p>Many keyboard button types are removed from project. It is more convenient to use factory methods on <code>KeyboardButton</code> and <code>InlineKeyboardButton</code> classes.</p>
<p>Here are some examples:</p>
<pre><code class="language-csharp">// Message having an inline keyboard button with URL that redirects to a page
await BotClient.SendTextMessageAsync(
    chatId: -9876,
    text: &quot;Check out the source code&quot;,
    replyMarkup: new InlineKeyboardMarkup(
        InlineKeyboardButton.WithUrl(&quot;Repository&quot;, &quot;https://github.com/TelegramBots/Telegram.Bot&quot;)
    )
);
</code></pre>
<pre><code class="language-csharp">// Message to a private chat having a 2-row reply keyboard
await BotClient.SendTextMessageAsync(
    chatId: 1234,
    text: &quot;Share your contact &amp; location&quot;,
    replyMarkup: new ReplyKeyboardMarkup(
        new [] { KeyboardButton.WithRequestContact(&quot;Share Contact&quot;) },
        new [] { KeyboardButton.WithRequestLocation(&quot;Share Location&quot;) },
    )
);
</code></pre>
<h2 id="getfileasync"><a class="header" href="#getfileasync"><code>GetFileAsync()</code></a></h2>
<p>Downloading a file from Telegram Bot API has 2 steps (<a href="https://core.telegram.org/bots/api#getfile">see docs here</a>):</p>
<ol>
<li>Get file info by calling <code>getFile</code></li>
<li>Download file from <code>https://api.telegram.org/file/bot&lt;token&gt;/&lt;file_path&gt;</code></li>
</ol>
<p><code>GetFileAsync()</code> is replaced by 3 methods. Method <code>GetInfoAndDownloadFileAsync()</code> looks very similar to old <code>GetFileAsync()</code>:</p>
<pre><code class="language-csharp">// Gets file info and saves it to &quot;path/to/file.pdf&quot;
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;))
{
    File fileInfo = await BotClient.GetInfoAndDownloadFileAsync(
        fileId: &quot;BsdfgLg4Khdlsn-bldBD&quot;,
        destination: fileStream
    );
}
</code></pre>
<blockquote>
<p>Note that calling the method <code>GetInfoAndDownloadFileAsync()</code> results in 2 HTTP requests (steps 1 and 2 above) being sent to the Bot API.</p>
</blockquote>
<p>There are two more methods that assist you with downloading files:</p>
<pre><code class="language-csharp">// New version of GetFileAsync() only gets the file info (step 1)
File fileInfo = await BotClient.GetFileAsync(&quot;BsdfgLg4Khdlsn-bldBD&quot;);

// Download file from server (step 2)
using (var fileStream = System.IO.File.OpenWrite(&quot;path/to/file.pdf&quot;)) {
    await BotClient.DownloadFileAsync(
        filePath: fileInfo.FilePath,
        destination: fileStream
    );
}
</code></pre>
<h2 id="getupdatesasync-setwebhookasync"><a class="header" href="#getupdatesasync-setwebhookasync"><code>GetUpdatesAsync()</code>, <code>SetWebhookAsync()</code></a></h2>
<p>Value <code>All</code> is removed from enum <code>Telegram.Bot.Types.Enums.UpdateType</code>. In order to get all kind of updates, pass an empty list such as <code>Array.Empty&lt;UpdateType&gt;()</code> for <code>allowedUpdates</code> argument.</p>
<h2 id="setwebhookasync"><a class="header" href="#setwebhookasync"><code>SetWebhookAsync()</code></a></h2>
<p>Parameter <code>url</code> is required. If you intend to remove the webhook, it is recommended to use <code>DeleteWebhookAsync()</code> instead. However, you could achieve the same result by passing <code>string.Empty</code> value to <code>url</code> argument.</p>
<h2 id="answerinlinequeryasync-and-inlinequeryresult"><a class="header" href="#answerinlinequeryasync-and-inlinequeryresult"><code>AnswerInlineQueryAsync()</code> and <code>InlineQueryResult</code></a></h2>
<p>Classes <code>InlineQueryResultNew</code> and <code>InlineQueryResultCache</code> are removed. <code>InlineQueryResult</code> has become the only shared base type for all inline query result classes.</p>
<p>Many shared and redundant properties are removed. This might require significant changes to your <code>.cs</code> files if your bot is in <em>inline mode</em>. Fortunately, all input query results now have constructors with only the required properties as their parameters. This is the preferred way to instantiate input query result instances e.g.:</p>
<p>Instead of:</p>
<pre><code class="language-csharp">// bad way. easy to get exceptions
var documentResult = new InlineQueryResultDocument
{
    Id = &quot;some-id&quot;,
    Url = &quot;https://example.com/document.pdf&quot;,
    Title = &quot;Some title&quot;,
    MimeType = &quot;application/pdf&quot;
};
</code></pre>
<p>You should use:</p>
<pre><code class="language-csharp">// good way
var documentResult = new InlineQueryResultDocument(
    id: &quot;some-id&quot;,
    documentUrl: &quot;https://example.com/document.pdf&quot;,
    title: &quot;Some title&quot;,
    mimeType: &quot;application/pdf&quot;
);
</code></pre>
<h2 id="sendmediagroupasync"><a class="header" href="#sendmediagroupasync"><code>SendMediaGroupAsync()</code></a></h2>
<p><code>InputMediaType</code> is renamed to <code>InputMedia</code>.</p>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<h2 id="inline-message-overloads"><a class="header" href="#inline-message-overloads">Inline Message Overloads</a></h2>
<p>Many inline message methods have been replaced with their overloads.</p>
<ul>
<li><code>EditInlineMessageTextAsync</code>--&gt; <code>EditMessageTextAsync</code></li>
</ul>
<blockquote>
<p><em>ToDo</em></p>
</blockquote>
<h2 id="filetosend"><a class="header" href="#filetosend"><code>FileToSend</code></a></h2>
<p>New classes have replaced <code>FileToSend</code> struct.</p>
<ul>
<li><code>InputFileStream</code>:</li>
<li><code>InputTelegramFile</code>:</li>
<li><code>InputOnlineFile</code>:</li>
</ul>
<p>In many cases, you can use implicit casting to pass parameters.</p>
<pre><code class="language-csharp">Stream stream = System.IO.File.OpenRead(&quot;photo.png&quot;);
var message = await BotClient.SendPhotoAsync(&quot;chat id&quot;, stream);

string fileId = &quot;file_id on Telegram servers&quot;;
var message = await BotClient.SendPhotoAsync(&quot;chat id&quot;, fileId);
</code></pre>
<blockquote>
<p><em>ToDo</em>. implicit casts</p>
</blockquote>
<h2 id="updatetype-and-messagetype"><a class="header" href="#updatetype-and-messagetype"><code>UpdateType</code> and <code>MessageType</code></a></h2>
<p>Values in these two enums are renamed e.g. <code>UpdateType.MessageUpdate</code> is now <code>UpdateType.Message</code>.</p>
<p><code>MessageType.Service</code> is removed. Now each type of message has its own <code>MessageType</code> value e.g. when a chat member leaves a group, corresponding update contains a message type of <code>MessageType.ChatMemberLeft</code> value.</p>
<h2 id="videonote"><a class="header" href="#videonote"><code>VideoNote</code></a></h2>
<p>Properties <code>Width</code> and <code>Height</code> are removed. Vide notes are squared and <code>Length</code> property represents both width and height.</p>
<h2 id="constructor-parameters-instead-of-public-setters"><a class="header" href="#constructor-parameters-instead-of-public-setters">Constructor Parameters Instead of Public Setters</a></h2>
<p>Many types now have the required parameters in their constructors. To avoid running into problems or getting exceptions, we recommend providing all required values in the constructor e.g.:</p>
<pre><code class="language-c#">//bad way:
var markup = new InlineKeyboardMarkup
    {
        Keyboard = buttonsArray,
        ResizeKeyboard = true
    };

// better:
var markup = new InlineKeyboardMarkup(buttonsArray)
    {
        ResizeKeyboard = true
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-170"><a class="header" href="#migration-guide-for-version-170">Migration guide for version 17.0</a></h1>
<p>There are several breaking changes in v17:</p>
<ul>
<li>New exceptions handling logic</li>
<li>Removal of update and message events</li>
<li>Removal of API methods from <code>ITelegramBotClient</code> interface and moving them into extension methods in the same namespace (that shouldn't break anyone's sources as long as they don't employ reflection or make their own interface implementations)</li>
<li>Working with default enum values</li>
</ul>
<p>These are the most user facing breaking changes you should be aware of during migration.</p>
<p>Let's dive deep on the migrations.</p>
<h2 id="new-exceptions-handling-logic"><a class="header" href="#new-exceptions-handling-logic">New exceptions handling logic</a></h2>
<p>v17 brings a new base type for exceptions: <code>RequestException</code>. <code>ApiRequestException</code>  inherits from <code>RequestException</code> and is thrown only when an actual error response with the correct body is received from the Bot API. In other situations <code>RequestException</code> will be thrown instead containing actual exception as <code>InnerException</code> if there is one, e.g. serialization or connection-related exceptions.</p>
<p>If you used <code>ApiRequestException</code> and <code>HttpRequestException</code> to handle most exception now you have to replace <code>HttpRequestException</code> with <code>RequestException</code> and look for the inner exception. All valid errors with JSON body from Telegram are now thrown as <code>ApiRequestException</code> including <code>429: Too Many Requests</code>.</p>
<p>Since <code>5XX</code> responses don't usually include correct JSON body they are thrown as <code>RequestException</code> with <code>HttpRequestException</code> inside.</p>
<p>Look at the following example on how to handle different kinds of exceptions. You might not need to implement everything as you see, it's there only for demonstration purposes.</p>
<pre><code class="language-csharp">try
{
    await bot.SendTextMessageAsync(chatId, &quot;Hello&quot;);
}
catch (ApiRequestException exception)
{
    switch (exception.StatusCode)
    {
        case 400:
            // Handle incorrect requests exceptions
            break;
        case 401:
            // Handle incorrect bot token exception (revoked tokens)
            break;
        case 403:
            // Handle authorization exceptions (blocked users, unaccessible chats, etc)
            break;
        case 429:
            // Handle rate limiting exception
            break;
        default:
            // Handle other errors with valid json body: it includes status code and description of the error
            break;
    }
}
catch (RequestException exception)
{
    if (exception.InnerException is HttpRequestException httpRequestException)
    {
        // Handle connection exceptions or 5XX exceptions from the Bot API
    }
    else if (exception.InnerException is JsonSerializationException serializationException)
    {
        // Handle serialization exception when a request or a response can't be serialized for some reason
    }
    else
    {
        // Handle all other exceptions
    }
}
catch (OperationCancelledException exception)
{
    // Handle cancellation exception, e.g. when CancellationToken is cancelled
}
</code></pre>
<h2 id="removal-of-events"><a class="header" href="#removal-of-events">Removal of events</a></h2>
<p>In v17 we removed events and introduced a new way of getting updates with <a href="https://github.com/TelegramBots/Telegram.Bot.Extensions.Polling">Telegram.Bot.Extensions.Polling</a> package. You can find an example in <a href="./1/example-bot.html">First Chat Bot</a> article.</p>
<h2 id="removal-of-api-methods-from-itelegrambotclient-interface"><a class="header" href="#removal-of-api-methods-from-itelegrambotclient-interface">Removal of API methods from <code>ITelegramBotClient</code> interface</a></h2>
<p>This change shouldn't affect most users, the methods are still there, but instead of being implementations of the interface they are now extension methods. It makes the interface leaner and easier to implement for custom clients and for decorators (e.g. rate limiters implemented as decorators). There isn't really a migration path for those who used these for some reason.</p>
<h2 id="working-with-default-enum-values"><a class="header" href="#working-with-default-enum-values">Working with default enum values</a></h2>
<p>We changed how we work with enums. The most notable change is the default value: there is none, all our enums are now start with 1 (exception <code>UpdateType</code> and <code>MessageType</code> since they are not a part of the Bot API and we fully control these). <code>0</code> value is left unassigned for a purpose: if we encounter an unknown value in the response from the Bot API we assign <code>0</code> as its value.</p>
<p>Let's imagine that Telegram adds new <code>MessageEntity</code> value. From now on all unknown values can be handled in the <code>default</code> case of <code>switch</code> statement.</p>
<pre><code class="language-csharp">MessageEntity entity = message.Entities.First();

switch (entity.Type)
{
    case MessageEntityType.Username:
        // ...
        break;
    case MessageEntityType.Command:
        // ...
        break;
    default:
        // All unknown values will go there
        break;
}
</code></pre>
<p>Also some default enums values were removed, e.g. <code>ParseMode.Default</code> since we started using nullable types for every optional value and <code>ParseMode.Default</code> lost it's use. If a message doesn't have any markup you'll receive <code>null</code> in places where <code>ParseMode</code> type was used or if you want to explicitly indicate an absence of markup pass <code>null</code> instead.</p>
<h2 id="other-breaking-changes"><a class="header" href="#other-breaking-changes">Other breaking changes</a></h2>
<h3 id="constructor-accepting-iwebproxy"><a class="header" href="#constructor-accepting-iwebproxy">Constructor accepting IWebProxy</a></h3>
<p>We removed constructor accepting <code>IWebProxy</code>. Now you have to configure HttpClient yourself to use proxy. You can find examples in <a href="./4/proxy.html#http-proxy">Working Behind a Proxy</a> article.</p>
<h3 id="inputmediatype"><a class="header" href="#inputmediatype">InputMediaType</a></h3>
<p>Property <code>Type</code> in <code>IInputMedia</code> was changed to an enum <code>InputMediaType</code> for easier discoverability. So if you relied string values like <code>photo</code>, <code>video</code>, <code>animation</code> and so on now you need to switch to using enums. As a result you'll get autocomplete in IDEs and more predictability of what types of input media there are.</p>
<h3 id="encryptedpassportelementtype"><a class="header" href="#encryptedpassportelementtype">EncryptedPassportElementType</a></h3>
<p>Property <code>Type</code> of <code>EncryptedPassportElement</code> was replace with an enum for the same reason with <code>EncryptedPassportElementType</code> enum.</p>
<h3 id="chatmember"><a class="header" href="#chatmember">ChatMember</a></h3>
<p>As part of Bot API 5.3 implementation <code>ChatMember</code> type was split into a hierarchy of types with a discriminator field <code>Status</code>. If you need to access some data from the derived class you should use pattern matching or type casting like this:</p>
<pre><code class="language-csharp">ChatMember member = ... //;

if (chatMember is ChatMemberKicked kickedMember)
{
    // now you can access properties of a kicked chat member
    if (kickedMember.Until is not null)
    {
        // do something with the value of Until
    }
}
</code></pre>
<h3 id="chatid"><a class="header" href="#chatid">ChatId</a></h3>
<p>Fields <code>Identifier</code> and <code>Username</code> are now get-only properties. It shouldn't break most people's code as it's not a source breaking change. If you used reflection to find these fields you should to look for properties now.</p>
<h3 id="inlinequeryresultbase"><a class="header" href="#inlinequeryresultbase">InlineQueryResultBase</a></h3>
<p>Type <code>InlineQueryResultBase</code> is renamed to <code>InlineQueryResult</code> to match Bot API type hierarchy.</p>
<h3 id="nullability"><a class="header" href="#nullability">Nullability</a></h3>
<p>From now on all properties that are optional will use nullable types, e.g. <code>int?</code>, <code>string?</code>, because default values of such properties might be an actual values and isn't distinguishable from a lack of value. From now if a property is <code>null</code> you can be sure that it's value was not present in a response from the Bot API.</p>
<h3 id="replykeyboardmarkup"><a class="header" href="#replykeyboardmarkup">ReplyKeyboardMarkup</a></h3>
<p>Since <code>ResizeKeyboard</code> and <code>OneTimeKeyboard</code> are optional, we removed them from <code>ReplyKeyboardMarkup</code> constructor. You have to use <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-initialize-objects-by-using-an-object-initializer">object initialization syntax</a> to configure these properties:</p>
<pre><code class="language-csharp">var replyKeyboardMarkup = new ReplyKeyboardMarkup(
    new KeyboardButton[][]
    {
        new KeyboardButton[] { &quot;1.1&quot;, &quot;1.2&quot; },
        new KeyboardButton[] { &quot;2.1&quot;, &quot;2.2&quot; },
    })
    {
        ResizeKeyboard = true
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-180"><a class="header" href="#migration-guide-for-version-180">Migration guide for version 18.0</a></h1>
<p>Most breaking changes in v18 come from new Bot API changes, such as:</p>
<ol>
<li>In <a href="https://core.telegram.org/bots/api#april-16-2022">Bot API 6.0</a> <code>voice_chat*</code> related message properties were
deprecated in favour of <code>video_chat*</code> with the same semantics and shape.</li>
<li>With introduction of video stickers in <a href="https://core.telegram.org/bots/api#january-31-2022">Bot API 5.7</a> we needed a way
to separate methods for different sticker types. So static .WEBP <code>*StickerSet*</code> methods and requests were given a <code>Static</code> prefix.</li>
<li>Removed <code>untilDate</code> parameter from <code>TelegramBotClientExtensions.BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class.</li>
<li>As of the next update some users will be able to upload up to 4GB files, so we changed <code>FileBase.FileSize</code> type to <code>long?</code>.</li>
<li>A new way of configuring the client.</li>
<li><code>ApiRequestEventArgs</code> contains full request data.</li>
</ol>
<p>Complete list of changes is available in <a href="https://github.com/TelegramBots/Telegram.Bot/blob/master/CHANGELOG.md">CHANGELOG</a></p>
<h2 id="1-removal-of-voicechat-properties-in-message-object"><a class="header" href="#1-removal-of-voicechat-properties-in-message-object">1. Removal of <code>VoiceChat*</code> properties in <code>Message</code> object</a></h2>
<p>Telegram renamed <code>voice_chat_*</code> properties in the <code>Message</code> class and with <code>video_chat_*</code> onces so we replaced
corresponding <code>MessageType</code> enum members with the new ones.</p>
<p>Following properties in <code>Message</code> class and corresponding enum members in <code>MessageType</code> enum were changed:</p>
<pre><code class="language-diff">-VoiceChatScheduled
-VoiceChatStarted
-VoiceChatEnded
-VoiceChatParticipantsInvited
+VideoChatScheduled
+VideoChatStarted
+VideoChatEnded
+VideoChatParticipantsInvited
</code></pre>
<p>Also property <code>CanManageVoiceChats</code> in <code>ChatMemberAdministrator</code> and <code>PromoteChatMemberRequest</code> classes was renamed to
<code>CanManageVideoChats</code>.</p>
<h2 id="2-renaming-static-sticker-methods-and-classes"><a class="header" href="#2-renaming-static-sticker-methods-and-classes">2. Renaming static sticker methods and classes</a></h2>
<p>With introduction of video stickers in <a href="https://core.telegram.org/bots/api#january-31-2022">Bot API 5.7</a> we needed a way
to separate methods for different sticker types. We already used <code>Animated</code> and <code>Video</code> suffix for methods related to animated
and video stickers so we decided to do the same for the static stickers:</p>
<ul>
<li>Classes <code>CreateNewStickerSetRequest</code> and <code>AddStickerToSetRequest</code> were renamed to <code>CreateNewStaticStickerSetRequest</code>
and <code>AddStaticStickerToSetRequest</code>.</li>
<li>Methods <code>CreateNewStickerSetAsync</code> and <code>AddStickerToSetAsync</code> where renamed to
<code>CreateStaticNewStickerSetAsync</code> and <code>AddStaticStickerToSetAsync</code>.</li>
</ul>
<h2 id="3-removal-of-untildate-parameter-from-banchatsenderchatasync-method-and-untildate-property-from-banchatsenderchatrequest-class"><a class="header" href="#3-removal-of-untildate-parameter-from-banchatsenderchatasync-method-and-untildate-property-from-banchatsenderchatrequest-class">3. Removal of <code>untilDate</code> parameter from <code>BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class</a></h2>
<p>The <code>untilDate</code> parameter from <code>TelegramBotClientExtensions.BanChatSenderChatAsync</code> method and <code>UntilDate</code> property from <code>BanChatSenderChatRequest</code> class were removed from the Bot API.</p>
<h2 id="4-lifting-of-the-filesize-limit"><a class="header" href="#4-lifting-of-the-filesize-limit">4. Lifting of the FileSize limit</a></h2>
<p>As of the next update some users will be able to upload up to 4GB files, so we changed <code>FileBase.FileSize</code> type to <code>long?</code> to accommodate this change.</p>
<h2 id="5-a-new-way-of-client-configuration"><a class="header" href="#5-a-new-way-of-client-configuration">5. A new way of client configuration</a></h2>
<p>Starting with this release client configuration parameters should be passed through <code>TelegramBotClientOptions</code> class.
You need to create an instance of <code>TelegramBotClientOptions</code> and pass it to the client:</p>
<pre><code class="language-csharp">using Telegram.Bot;

var options = new TelegramBotClientOptions(
    token: &quot;&lt;token&gt;&quot;

    // pass an optional baseUrl if you want to use a custom bot server
    baseUrl: &quot;https://custombotserverdomain.com&quot;,

    // pass an optional flag `true` if you want to use test environment
    useTestEnvironment = true
);

var client = new TelegramBotClient(options);
</code></pre>
<p>If you don't know about test environment you can read more about it in the official
<a href="https://core.telegram.org/bots/webapps#using-bots-in-the-test-environment">documentation</a>.</p>
<p>If you don't need extra configuration options you can still use the constructor that accepts a token and an instance of <code>HttpClient</code>:</p>
<pre><code class="language-csharp">var client = new TelegramBotClient(&quot;&lt;token&gt;&quot;);
</code></pre>
<h2 id="6-polling-functionality-in-the-core-library"><a class="header" href="#6-polling-functionality-in-the-core-library">6. Polling functionality in the core library</a></h2>
<p>The latest biggest change which is not a breaking one, but nevertheless worth a note: deprecation of
<code>Telegram.Bot.Extensions.Polling</code> package.</p>
<p>All the functionality from the package was merged into the core library under namespace <code>Telegram.Bot.Polling</code>.</p>
<p>Name of the method <code>HandleErrorAsync</code> in <code>IUpdateHandler</code> interface was quite confusing from the beginning since a lot
of people assumed they can handle all errors in it, but in reality it's used only for handling errors during polling.
We decided to give it a more appropriate name: <code>HandlePollingErrorAsync</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-190"><a class="header" href="#migration-guide-for-version-190">Migration guide for version 19.0</a></h1>
<h2 id="topics-in-groups"><a class="header" href="#topics-in-groups">Topics in Groups</a></h2>
<p>New topics functionality allow bots interact with users in topic specified by <code>messageThreadId</code> parameter.</p>
<p>We try to keep our Bot API implementation as close to <a href="https://core.telegram.org/bots/api#forumtopicclosed">Telegram Bot API</a> as possible. This means, that the new <code>messageThreadId</code> now the first optional parameter for a variety of methods.</p>
<p>Consider to use named parameters to avoid confusion with changed parameter order.</p>
<pre><code class="language-diff">-Message message = await BotClient.SendTextMessageAsync(
-    _fixture.SupergroupChat.Id,
-    &quot;Please click on *Notify* button.&quot;,
-    cancellationToken);
+Message message = await BotClient.SendTextMessageAsync(
+    chatId: _fixture.SupergroupChat.Id,
+    text: &quot;Please click on *Notify* button.&quot;,
+    messageThreadId: threadId,
+    cancellationToken: cancellationToken);
</code></pre>
<h2 id="new-inputfile-hierarchy"><a class="header" href="#new-inputfile-hierarchy">New InputFile Hierarchy</a></h2>
<p>Old <code>InputMedia*</code> class hierarchy poorly reflected actual file-related APIs.</p>
<p>We removed old hierarchy of <code>InputFile</code> related classes such as <code>InputOnlineFile</code>, <code>InputTelegramFile</code>, <code>InputFileStream</code>, etc., and also removed all implicit casts to them. From now on you should explicitly specify one of file types: <code>InputFileStream</code> for <code>Stream</code> content, <code>InputFileUrl</code> for URL and <code>InputFileId</code> if you want to use existing <code>file_id</code>. For convenience the base <code>InputType</code> class has factory methods to create the correct types:</p>
<ul>
<li><code>InputFile.FromStream(Stream stream, string? fileName = default)</code> for streams</li>
<li><code>InputFile.FromString(string urlOrFileId)</code> for URLs or file ids</li>
<li><code>InputFile.FromUri(Uri url)</code> - for URLs as strings</li>
<li><code>InputFile.FromUri(string url)</code> - for URLs as <code>URI</code>s</li>
<li><code>InputFile.FromFileId(string fileId)</code> - for file ids</li>
</ul>
<p>The migration scheme looks like that:</p>
<div class="table-wrapper"><table><thead><tr><th>Previous method</th><th>New method</th></tr></thead><tbody>
<tr><td><code>new InputTelegramType(string)</code></td><td><code>InputFile.FromId(string)</code>, <code>InputFile.FromString(string)</code></td></tr>
<tr><td><code>new InputTelegramType(Stream, string?)</code></td><td><code>InputFile.FromStream(Stream, string?)</code></td></tr>
<tr><td><code>new InputFileStream(Stream)</code></td><td><code>InputFile.FromStream(Stream)</code></td></tr>
<tr><td><code>new InputOnlineFile(string)</code></td><td><code>InputFile.FromId(string)</code>, <code>InputFile.FromString(string)</code>, <code>InputFile.FromString(string)</code>, <code>InputFile.FromUrl(string)</code>, <code>InputFile.FromUrl(Uri)</code></td></tr>
<tr><td><code>new InputOnlineFile(Stream, string?)</code></td><td><code>InputFile.FromStream(Stream, string?)</code></td></tr>
<tr><td>raw <code>Stream</code></td><td><code>InputFile.FromStream(Stream)</code></td></tr>
<tr><td>raw <code>string</code></td><td><code>InputFile.FromString(string)</code></td></tr>
<tr><td>raw <code>URI</code></td><td><code>InputFile.FromUrl(URI)</code></td></tr>
</tbody></table>
</div>
<h2 id="chatid-implicit-conversion"><a class="header" href="#chatid-implicit-conversion">ChatId implicit conversion</a></h2>
<p>Implicit conversion from <code>ChatId</code> to <code>string</code> was removed due to complaints and problems it caused. The migration path is to explicitly call <code>ChatId.ToString()</code> method.</p>
<h2 id="stickers-1"><a class="header" href="#stickers-1">Stickers</a></h2>
<ul>
<li>All methods and types with animated, static and video sticker distinction were removed and replaced with a single set of sticker related methods per new Bot API updates: <code>AddAnimatedStickerToSetAsync</code>, <code>AddStaticStickerToSetAsync</code>, <code>AddVideoStickerToSetAsync</code>, etc. Remove the words <code>Static</code>, <code>Animated</code> and <code>Video</code> from sticker related methods in your code</li>
<li>Associated emojies and masks were moved to a separate type <code>InputSticker</code>, use them there instead, consult the official Bot API docs for a more detailed information</li>
</ul>
<h2 id="net-core-31-removed-as-a-separate-target-framework"><a class="header" href="#net-core-31-removed-as-a-separate-target-framework">.NET Core 3.1 removed as a separate target framework</a></h2>
<p>Since .NET Core 3.1 LTS status is not officialy supported anymore we changed the target to <code>netstandard2.0</code> and <code>net6.0</code> instead. If you're using .NET Core 3.1 or .NET 5 runtimes you need to use the build for <code>netstandard2.0</code> instead. If you relied on <code>IAsyncEnumerable</code> implementation of poller you need to move to .NET 6 instead.</p>
<h2 id="other-changes"><a class="header" href="#other-changes">Other changes</a></h2>
<ul>
<li><code>Message.Type</code> returns <code>MessageType.Animation</code> when the message contains an <code>Animation</code>, use <code>MessageType.Animation</code> instead of <code>MessageType.Document</code> to check if the message contains an animation</li>
<li>Property <code>CanSendMediaMessages</code> was removed from the types <code>ChatMemberRestricted</code> and <code>ChatPermissions</code> and replaced with more granular permissions, use them instead</li>
<li>Removed method <code>GetChatMembersCountAsync</code>, use <code>GetChatMemberCountAsync</code></li>
<li>Removed method <code>KickChatMemberAsync</code>, use <code>BanChatMemberAsync</code></li>
<li>Properties and types <code>VoiceChatEnded</code>, <code>VoiceChatParticipantsInvited</code>,
<code>VoiceChatScheduled</code>, <code>VoiceChatStarted</code> removed, use methods and types which start with <code>Video*</code> instead</li>
<li>All propties with the word <code>Thumb</code> in them were renamed to contain the word <code>Thumbnail</code> per new Bot API updates</li>
<li>A new type <code>InlineQueryResultsButton</code> is used instead of <code>SwitchPmText</code> and <code>SwitchPmParameter</code> properties, consult the official Bot API docs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-for-version-21x"><a class="header" href="#migration-guide-for-version-21x">Migration guide for version 21.x</a></h1>
<p>Migrate directly to version 21, don't bother about version 20.</p>
<h2 id="renamed-parameter-replytomessageid--replyparameters"><a class="header" href="#renamed-parameter-replytomessageid--replyparameters">Renamed parameter <em>replyToMessageId:</em> → <em>replyParameters:</em></a></h2>
<p>That parameter was renamed and you can still pass a <strong>messageId</strong> for simple replies.</p>
<p>Or you can pass a <a href="https://core.telegram.org/bots/api#replyparameters">ReplyParameters</a> structure for more advanced reply configuration.</p>
<h2 id="renamed-parameter-disablewebpagepreview--linkpreviewoptions"><a class="header" href="#renamed-parameter-disablewebpagepreview--linkpreviewoptions">Renamed parameter <em>disableWebPagePreview:</em> → <em>linkPreviewOptions:</em></a></h2>
<p>That parameter was renamed and you can still pass <code>true</code> to disable web preview.</p>
<p>Or you can pass a <a href="https://core.telegram.org/bots/api#linkpreviewoptions">LinkPreviewOptions</a> structure for more precise preview configuration.</p>
<h2 id="changed-bool--bool"><a class="header" href="#changed-bool--bool">Changed <code>bool?</code> → <code>bool</code></a></h2>
<p>Many boolean parameters or fields are now simply of type <code>bool</code>.</p>
<p>In most cases, it shouldn't impact your existing code, or rather simplify it. Previously <code>null</code> values are now just <code>false</code>.</p>
<h2 id="changed-parsemode--parsemode"><a class="header" href="#changed-parsemode--parsemode">Changed <code>ParseMode?</code> → <code>ParseMode</code></a></h2>
<p>When you don't need to specify a ParseMode, just pass <code>default</code> or <code>ParseMode.None</code>.</p>
<h2 id="better-backward-compatibility-and-simplification-of-code"><a class="header" href="#better-backward-compatibility-and-simplification-of-code">Better backward-compatibility and simplification of code</a></h2>
<p>We added/restored features &amp; implicit conversions that make your code simpler:</p>
<ul>
<li><code>InputFile</code>: just pass a <code>string</code>/<code>Stream</code> for file_id/url/stream content <em>(as was possible in previous versions of Telegram.Bot)</em></li>
<li><code>InputMedia*</code>: just pass an <code>InputFile</code> when you don't need to associate caption or such</li>
<li><code>MessageId</code>: auto-converts to/from <code>int</code> (and also from <code>Message</code>)</li>
<li><code>ReactionType</code>: just pass a <code>string</code> when you want to send an emoji</li>
<li><code>ReactionType</code>: just pass a <code>long</code> when you want to send a custom emoji (id)</li>
<li>Some other obvious implicit conversion operators for structures containing a single property</li>
<li>No more enforcing <code>init;</code> properties, so you can adjust the content of fields as you wish or modify a structure returned by the API <em>(before passing it back to the API if you want)</em></li>
<li>Restored some <code>MessageType</code> enum value that were removed (renamed) recently (easier compatibility)</li>
</ul>
<h2 id="maybeinaccessiblemessage"><a class="header" href="#maybeinaccessiblemessage">MaybeInaccessibleMessage</a></h2>
<p>This class hierarchy was introduced in Bot API 7.0 and broke existing code and added unnecessary complexity.</p>
<p>This was removed in our library v21 and you will just receive directly a Message.</p>
<p>To identify an &quot;inaccessible message&quot;, you can just check <code>message.Type == MessageType.Unknown</code> or <code>message.Date == default</code>.</p>
<h2 id="chat-and-chatfullinfo"><a class="header" href="#chat-and-chatfullinfo">Chat and ChatFullInfo</a></h2>
<p>In previous versions, the big <code>Chat</code> structure contained many fields that were filled only after a call to GetChatAsync.</p>
<p>This structure is now split into <code>Chat</code> and <code>ChatFullInfo</code> structures.</p>
<p>The new <code>Chat</code> structure contains only common fields that are always filled.
The new <code>ChatFullInfo</code> structure inherits from <code>Chat</code> and is returned only by GetChatAsync method, with all the extra fields.</p>
<h2 id="request-structures"><a class="header" href="#request-structures">Request structures</a></h2>
<p>Request structures (types ending with <code>Request</code>) are NOT the recommended way to use the library in your projects.</p>
<p>They are to be considered as low-level raw access to Bot API structures for advanced programmers, and might change/break at any time in the future.</p>
<p>If you have existing code using them, you can use the <code>MakeRequestAsync</code> method to send those requests.
(Other methods will be removed soon)</p>
<h2 id="payments-with-telegram-stars"><a class="header" href="#payments-with-telegram-stars">Payments with Telegram Stars</a></h2>
<p>To make a payment in <a href="https://t.me/BotNews/90">Telegram Stars</a> with SendInvoiceAsync, set the following parameters:</p>
<ul>
<li><code>providerToken:</code> <code>null</code> or <code>&quot;&quot;</code></li>
<li><code>currency:</code> <code>&quot;XTR&quot;</code></li>
<li><code>prices:</code> with a single price</li>
<li>no tip amounts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="how-do-i-use-an-httpsocks-proxy"><a class="header" href="#how-do-i-use-an-httpsocks-proxy">How do I use an HTTP/Socks proxy?</a></h2>
<p>Look at the wiki page: <a href="4/proxy.html">Working Behind a Proxy</a>.</p>
<h2 id="i-got-a-409-error-what-do-i-do"><a class="header" href="#i-got-a-409-error-what-do-i-do">I got a '409' error. What do I do?</a></h2>
<p>You are trying to receive updates multiple times at the same time. Either you are calling GetUpdates from two instances of the bot, or you are calling GetUpdates while a web hook is already set. That is not supported by the API, only receive on one instance.</p>
<h2 id="how-do-i-get-the-user-id-from-a-username"><a class="header" href="#how-do-i-get-the-user-id-from-a-username">How do I get the user id from a username?</a></h2>
<p>There is no way to do that with the API directly.
You could store a list of known usernames, mapped to ids.
This is <em>not</em> recommended, because usernames can be changed.</p>
<h2 id="how-do-i-get-updates-in-channels"><a class="header" href="#how-do-i-get-updates-in-channels">How do I get updates in channels?</a></h2>
<p>If you are using polling, you will have to subscribe to the <code>OnUpdate</code> event.
Check the <code>UpdateType</code> of the <code>Update</code>. If it is <code>UpdateType.ChannelPost</code> then the <code>Update.ChannelPost</code> property will be set.</p>
<h2 id="i-have-serialization-issues-or-null-values-in-update-object-in-my-webhook-what-do-i-do"><a class="header" href="#i-have-serialization-issues-or-null-values-in-update-object-in-my-webhook-what-do-i-do">I have serialization issues or null values in <code>Update</code> object in my webhook. What do I do?</a></h2>
<p>If you're using ASP.NET Core 3.0+ you need to install additional Nuget package: <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson/">Microsoft.AspNetCore.Mvc.NewtonsoftJson</a>. For more information read <a href="https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&amp;tabs=visual-studio#use-newtonsoftjson-in-an-aspnet-core-30-mvc-project">this page</a> about migrating from previous versions of ASP.NET Core.</p>
<h2 id="is-there-a-way-to-get-a-list-of-users-in-a-group-or-a-channel"><a class="header" href="#is-there-a-way-to-get-a-list-of-users-in-a-group-or-a-channel">Is there a way to get a list of users in a group or a channel?</a></h2>
<p>There's no API to get all users in a chat, there's only <a href="https://core.telegram.org/bots/api#getchatmember"><code>getChatMember</code></a> request to obtain a
<a href="https://core.telegram.org/bots/api#chatmember"><code>ChatMember</code></a> object knowing it's <code>user_id</code>.</p>
<p>You can keep track of users observing new messages in a chat and saving user info into a database.</p>
<h2 id="this-faq-doesnt-have-my-question-on-it-where-can-i-get-my-torch-and-pitchfork"><a class="header" href="#this-faq-doesnt-have-my-question-on-it-where-can-i-get-my-torch-and-pitchfork">This FAQ doesn't have my question on it. Where can I get my torch and pitchfork?</a></h2>
<p>Check the <a href="https://core.telegram.org/bots/faq"><code>Bots FAQ by Telegram</code></a> and if that doesn't pan out, feel free to let us know in the <a href="https://t.me/joinchat/B35YY0QbLfd034CFnvCtCA">public group chat</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
